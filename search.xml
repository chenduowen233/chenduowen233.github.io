<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《华为防火墙技术漫谈》04</title>
      <link href="/%E3%80%8A%E5%8D%8E%E4%B8%BA%E9%98%B2%E7%81%AB%E5%A2%99%E6%8A%80%E6%9C%AF%E6%BC%AB%E8%B0%88%E3%80%8B04/"/>
      <url>/%E3%80%8A%E5%8D%8E%E4%B8%BA%E9%98%B2%E7%81%AB%E5%A2%99%E6%8A%80%E6%9C%AF%E6%BC%AB%E8%B0%88%E3%80%8B04/</url>
      
        <content type="html"><![CDATA[<h1 id="读书笔记-《华为防火墙技术漫谈》04"><a href="#读书笔记-《华为防火墙技术漫谈》04" class="headerlink" title="读书笔记-《华为防火墙技术漫谈》04"></a>读书笔记-《华为防火墙技术漫谈》04</h1><h2 id="三、安全防范"><a href="#三、安全防范" class="headerlink" title="三、安全防范"></a>三、安全防范</h2><h3 id="3、流量型攻击之SYN-Flood攻击及防御"><a href="#3、流量型攻击之SYN-Flood攻击及防御" class="headerlink" title="3、流量型攻击之SYN Flood攻击及防御"></a>3、流量型攻击之SYN Flood攻击及防御</h3><p><strong>DDoS（Distributed Denial of Service分布式拒绝服务</strong>）攻击指的是攻击者通过掌控大量僵尸主机（俗称“肉鸡”），向目标服务器发送精心构造的大规模攻击数据包，导致目标服务器所在网络链路的过载和系统资源的耗尽，从而使被攻击方无法为正常用户提供服务，产生拒绝服务的效果。</p><p><strong>SYN Flood</strong>攻击是一种基于TCP协议栈的攻击，为了理解SYN Flood攻击及其防御机制，我们需要先从TCP连接的建立过程开始。在TCP/IP协议中，TCP协议负责提供可靠的连接服务。在数据从一方发送到另一方之前，必须首先建立一条连接通道，这就是著名的TCP三次握手过程。</p><p>SYN Flood攻击正是利用了TCP三次握手的机制。攻击者向目标服务器发送大量的SYN请求数据包，这些请求的源地址通常是虚构的或无法到达的。当服务器回应这些请求并发送SYN+ACK数据包后，却不会收到相应的ACK回应数据包，导致服务器上建立大量半开连接。这样，服务器的资源会被这些半开连接耗尽，无法应对正常请求。</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20231029220121945.png" alt="image-20231029220121945"></p><p>在防范SYN Flood攻击时，防火墙通常采用两种方法：</p><p><strong>1. TCP代理</strong>：启用TCP代理后，防火墙接收到SYN请求数据包时，会代替服务器发送SYN+ACK数据包。如果随后没有收到客户端的ACK回应数据包，防火墙会判定该SYN请求为异常，保持半开连接一段时间后放弃。如果防火墙收到客户端的ACK回应数据包，就会代替客户端与服务器完成TCP三次握手，后续客户端的数据包将直接传递给服务器。这个过程对客户端和服务器来说都是透明的。</p><p><strong>2. TCP源探测</strong>：通过启动TCP源探测，防火墙在收到SYN请求数据包后，会回应一个带有错误确认号的SYN+ACK数据包。如果没有收到客户端的RST回应数据包，防火墙将判定该SYN请求为异常，即客户端是虚假源。如果防火墙收到客户端的RST回应数据包，就会判定该SYN请求为正常，客户端被列入白名单，其后续数据包将被视为合法。</p><p>这两种方法各有利弊，TCP代理需要高性能防火墙以代替服务器承受半开连接的负担，而TCP源探测则需要确认客户端支持TCP协议。在网络环境中，路径不一致的情况下，TCP代理可能会遇到问题。这是因为客户端的请求经过防火墙，而服务器的响应不会经过防火墙。在这种情况下，防火墙向服务器发送SYN请求时，服务器的SYN+ACK响应不会经过防火墙，从而导致TCP代理功能失败。</p><h3 id="4、流量型攻击之UDP-Flood攻击及防御"><a href="#4、流量型攻击之UDP-Flood攻击及防御" class="headerlink" title="4、流量型攻击之UDP Flood攻击及防御"></a>4、流量型攻击之UDP Flood攻击及防御</h3><p>UDP协议与TCP协议有着根本的不同，UDP属于一种无连接协议，以其速度优势而著称，远超越了TCP。正是由于UDP协议的广泛应用，攻击者得以借助其平台来发动UDP Flood攻击。<strong>UDP Flood</strong>攻击属于一种带宽型攻击，攻击者通过操控僵尸主机向目标服务器发送大量UDP数据包，这些UDP数据包通常具有庞大的字节数和极快的传输速率，其危害通常包括：</p><ol><li>消耗网络带宽资源，可能导致链路拥塞，甚至使网络崩溃。</li><li>大规模UDP Flood攻击，涉及源IP地址和目标端口的变换，可能导致依赖会话转发的网络设备性能下降，甚至耗尽其会话资源，最终导致网络瘫痪。</li></ol><p>与SYN Flood攻击不同，防火墙在防御UDP Flood攻击时无法像源探测那样建立连接。</p><p>在应对UDP Flood攻击时，防火墙最简单的防御方法是采用限流策略，通过限流来控制UDP数据包在网络链路上的传输速率，确保其保持在合理的带宽范围内。防火墙上有四种主要限流方式：</p><ol><li><p>基于流量入接口的限流：以特定的入接口流量为统计对象，对通过该接口的UDP流量进行统计和限制，超出部分将被丢弃。</p></li><li><p>基于目标IP地址的限流：以某个IP地址作为统计对象，对到达该IP地址的UDP流量进行统计和限制，超出部分将被丢弃。</p></li><li><p>基于目标安全区域的限流：以某个安全区域作为统计对象，对到达该区域的UDP流量进行统计和限制，超出部分将被丢弃。</p></li><li><p>基于会话的限流：对每个UDP会话中的数据包传输速率进行统计，如果会话中的UDP数据包速率达到警戒阈值，该会话将被锁定，后续命中该会话的UDP数据包都将被丢弃。当会话在连续3秒或更长时间内没有流量传输时，防火墙将解锁该会话，允许后续的数据包通过。</p></li></ol><p>另一种有效的防御方法是指纹学习，它基于事实，即UDP Flood攻击的数据包通常具有相似的特征字段，例如包含相同的字符串或整个UDP数据包的内容相似。攻击者通常使用相同的数据包构造方式和高频发送攻击目标，因此攻击数据包之间存在高度相似性。指纹学习利用这一特性来检测攻击数据包并采取相应措施。</p><p>综上所述，防火墙应对UDP Flood攻击主要采用限流和指纹学习两种方式，每种方式都有其优点和限制。限流方式虽然能够快速控制UDP流量，但可能导致丢弃正常数据包。指纹学习方式相对理性，不会轻易丢弃数据包，但需要一定的学习过程。对于网络安全，选择适合特定环境和需求的防御策略非常关键。</p><h3 id="5、应用层攻击之DNS-Flood攻击及防御"><a href="#5、应用层攻击之DNS-Flood攻击及防御" class="headerlink" title="5、应用层攻击之DNS Flood攻击及防御"></a>5、应用层攻击之DNS Flood攻击及防御</h3><p><strong>DNS Flood</strong>攻击指的是攻击者向DNS服务器发送大量的不存在的域名解析请求，导致DNS服务器瘫痪，无法处理正常的域名解析请求。</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20231029220649978.png" alt="image-20231029220649978"></p><p>DNS源探测方式可以很好地防御DNS Flood攻击，但是在现网的实际环境中，并不是所有场景都适用。因为在源探测过程中，防火墙会要求客户端通过TCP协议发送DNS请求，但并不是所有的客户端都支持用TCP协议发送DNS请求，所以这种方式在使用过程中也有限制。如果真实的客户端不支持用TCP协议发送DNS请求，使用此功能时，就会影响正常业务。</p><h3 id="5、应用层攻击之HTTP-Flood攻击及防御"><a href="#5、应用层攻击之HTTP-Flood攻击及防御" class="headerlink" title="5、应用层攻击之HTTP Flood攻击及防御"></a>5、应用层攻击之HTTP Flood攻击及防御</h3><p>HTTP Flood攻击是指攻击者操控僵尸主机向目标服务器发送大量HTTP请求，这些请求通常包含与数据库操作有关的统一资源标识符（Uniform Resource Identifier，URI）或其他消耗系统资源的URI，其目的是使目标服务器资源不堪重负，无法有效响应正常请求。对抗HTTP Flood攻击时，采用了HTTP中的一项技术：HTTP重定向。</p><p>HTTP重定向实际上相当于Web服务器进行“自我修复”。通常，当客户端请求一个已经过期的URL时，Web服务器会将客户端的请求重定向到一个新的URI，以确保客户端能够获得所需的内容。这一过程如下图所示。</p><p>在启用HTTP探测后，防火墙会接收到HTTP请求，并代替HTTP服务器回应该请求，将客户端的访问指向一个新的虚构URL。如果随后防火墙没有收到客户端对该URL的请求，就会将该客户端视为虚假源。但如果防火墙收到了客户端对该URL的请求，就会将该客户端标识为真实源，并将其IP地址添加到白名单中。此后，防火墙会继续向客户端发送HTTP重定向命令，将其访问重定向到最初的URL，即客户端最初请求的那个URL。在白名单的老化之前，防火墙将认为后续由该客户端发送的HTTP请求是合法的。</p><p>HTTP源探测方法能够有效地抵御HTTP Flood攻击，但在实际网络环境中，必须确认客户端是否支持重定向功能。例如，某些常见的设备，如机顶盒，可能不支持重定向功能。因此，在采用HTTP源探测时，必须确保网络中不存在这类不支持重定向的客户端，以免影响正常业务。</p><h2 id="四、网络地址转化NAT"><a href="#四、网络地址转化NAT" class="headerlink" title="四、网络地址转化NAT"></a>四、网络地址转化NAT</h2><h2 id="1、源NAT"><a href="#1、源NAT" class="headerlink" title="1、源NAT"></a>1、源NAT</h2><p>源NAT技术对IP报文的源地址进行转换，将私网IP地址映射成公网IP地址，使众多私网用户能够借助有限数量的公网IP地址访问Internet，从而显著减少对公网IP地址的消耗。这个整个NAT转换过程对于内部网络中的用户和Internet上的主机来说都是完全透明的。</p><p>NAT地址池是一个抽象的概念，将”公网IP地址的集合”比喻为一个”IP地址池”或容器。防火墙在执行地址转换时，会从NAT地址池中随机选择一个公网IP地址，然后用它来代替私网IP地址进行转换。选择哪个公网IP地址是随机的，与配置时的顺序或IP地址的大小等因素无关。</p><p>NAT地址池配置完成后，将被NAT策略所引用。NAT策略类似于安全策略，由条件和动作组成。不同之处在于，NAT策略中的动作有两种选择：源NAT转换和不进行NAT转换。当动作选择为”源NAT转换”时，必须引用NAT地址池。</p><p>多个NAT策略之间存在匹配顺序。如果报文匹配了某个NAT策略，将按照该策略引用的地址池进行地址转换；如果报文没有匹配到任何NAT策略，将继续向下匹配。</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20231029222840757.png" alt="image-20231029222840757"></p><p><strong>1、NAT No-PAT</strong><br>“No-PAT”表示不进行端口转换，因此NAT No-PAT方式只进行IP地址转换，因此也被称为”一对一地址转换”。</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20231029222914711.png" alt="image-20231029222914711"></p><p><strong>2、NAPT</strong><br>NAPT（Network Address and Port Translation）表示网络地址和端口转换，即同时对IP地址和端口进行转换，也可以称为PAT（PAT不仅指端口转换，还包括IP地址和端口同时转换）。NAPT是一种最广泛应用的地址转换方式，可使用有限数量的公网IP地址满足众多私网用户访问Internet的需求。</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20231029223102037.png" alt="image-20231029223102037"></p><p>NAPT方式和NAT No-PAT方式在配置上的区别仅在于：NAPT方式的NAT策略在引用NAT地址池时不需要配置关键字”no-pat”，其他配置都相同。</p><p>此外需要注意，NAPT方式不会生成Server-map表，这一点与NAT No-PAT方式不同。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《华为防火墙技术漫谈》03</title>
      <link href="/%E3%80%8A%E5%8D%8E%E4%B8%BA%E9%98%B2%E7%81%AB%E5%A2%99%E6%8A%80%E6%9C%AF%E6%BC%AB%E8%B0%88%E3%80%8B03/"/>
      <url>/%E3%80%8A%E5%8D%8E%E4%B8%BA%E9%98%B2%E7%81%AB%E5%A2%99%E6%8A%80%E6%9C%AF%E6%BC%AB%E8%B0%88%E3%80%8B03/</url>
      
        <content type="html"><![CDATA[<h1 id="读书笔记-《华为防火墙技术漫谈》03"><a href="#读书笔记-《华为防火墙技术漫谈》03" class="headerlink" title="读书笔记-《华为防火墙技术漫谈》03"></a>读书笔记-《华为防火墙技术漫谈》03</h1><h2 id="二、安全策略"><a href="#二、安全策略" class="headerlink" title="二、安全策略"></a>二、安全策略</h2><h3 id="3、本地区域的安全策略"><a href="#3、本地区域的安全策略" class="headerlink" title="3、本地区域的安全策略"></a>3、本地区域的安全策略</h3><p>在网络管理中，管理员通常需要登录到防火墙进行各项管理操作。同时，防火墙还需要建立虚拟专用网络（VPN）以与Internet上的设备或用户进行通信。此外，在网络中，防火墙和路由器之间还需要运行开放最短路径优先（OSPF）路由协议，以确保数据的顺畅传输。还有，防火墙通常需要与认证服务器进行连接以验证用户身份等等。</p><p>为了保证这些业务能够正常运行，必须在防火墙上配置相应的安全策略，以允许防火墙接收来自不同业务的数据包。具体来说，这涉及到在防火墙的本地区域和与各业务使用的接口相关的安全区域之间的安全策略配置。</p><p>（1）OSPF协议相关的本地区域安全策略配置</p><p>在这一实验中，我们将验证防火墙如何参与OSPF路由计算，也就是验证防火墙接口所在的安全区域与本地区域之间的安全策略配置。在某些情况下，防火墙不仅透传OSPF路由报文，而是参与了OSPF路由计算，接收和发送OSPF报文的两个接口可能位于不同的安全区域。在这种情况下，必须配置相应的安全策略以确保OSPF报文的正常传输。</p><p>通常情况下，单播报文受到安全策略的控制，因此需要配置相应的安全策略来允许这些报文通过防火墙。而组播报文则不受安全策略的控制，因此无需配置相应的安全策略来管理它们。</p><p>另外，根据网络类型的不同，OSPF报文的类型也会有所不同。当网络类型为广播类型时，OSPF报文中的数据传送（DD）报文和链路状态请求（LSR）报文都属于单播报文，因此需要配置相应的安全策略。而当网络类型为点对点（P2P）时，所有的OSPF报文都属于组播报文，因此无需配置特定的安全策略来管理它们。</p><p>在实际的网络环境中，如果防火墙上的OSPF运行状态出现异常，管理员还可以从安全策略的角度入手，检查是否由于未正确配置相应的安全策略以允许报文通过而导致的问题。</p><h3 id="4、ASPF"><a href="#4、ASPF" class="headerlink" title="4、ASPF"></a>4、ASPF</h3><p>应用：</p><ol><li>帮助FTP数据报文穿越防火墙</li><li>协助QQ和MSN报文在防火墙上通畅传递</li><li>支持用户自定义协议报文的无缝穿越防火墙</li></ol><p>此外，防火墙上的ASPF功能还可用于阻断HTTP协议中的潜在有害插件。HTTP协议常包含Java和ActiveX插件，它们容易被利用制成木马和病毒，对内部网络主机的安全构成威胁。通常，Java和ActiveX插件随HTTP报文的负载一同传输，如果仅检查HTTP报文的头部信息，这些插件难以辨识。因此，必须借助ASPF对HTTP报文的负载信息进行检测、识别并拦截Java和ActiveX插件，从而保护内部网络主机。</p><p>配置阻断HTTP协议中有害插件的操作非常简单，在安全区域的域间或域内执行”<code>detect activex-blocking</code>“或”<code>detect java-blocking</code>“命令即可完成。不同型号的防火墙产品在支持情况和命令格式上可能略有不同。</p><p>FTP协议是一个经典的多通道协议，其工作原理涉及FTP客户端和FTP服务器建立两个连接：控制连接和数据连接。控制连接用于传输FTP指令和参数，其中包括建立数据连接所需的信息；数据连接用于获取目录和传输数据。</p><p>根据数据连接的方式，FTP协议有两种工作模式：</p><ol><li>主动模式（PORT模式）：FTP服务器主动向FTP客户端发起数据连接</li><li>被动模式（PASV模式）：FTP服务器被动接受FTP客户端发起的数据连接</li></ol><p>ASPF主要用于检测报文的应用层信息，记录应用层信息中包含的重要数据，使得一些未明确定要放行的报文能够正常传递，即使未被包括在安全策略中。</p><p>应用层信息中关键数据的记录被称为”server-map表项”。当报文匹配该表项时，它将不再受制于安全策略，这等同于在防火墙上开辟了一种”隐形通道”。这个”server-map表项”不会永久存在，它会在一段时间后自动删除，确保”隐形通道”不会永远存在，这有助于保持安全性。要查看”server-map表项”，可以使用调试命令”<code>display firewall server-map</code>“。</p><p>另外，华为防火墙可以通过以下命令来查看策略的命中次数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 显示IPv4安全策略中名称为abc的规则的统计信息。</span><br><span class="line">display security-policy statistics ip rule 安全策略的名字</span><br></pre></td></tr></table></figure><p>另外，要查看ACL的命中次数，可以使用如下命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dis acl all //查看ACL的命中次数</span><br></pre></td></tr></table></figure><h2 id="三、安全防范"><a href="#三、安全防范" class="headerlink" title="三、安全防范"></a>三、安全防范</h2><h3 id="1、DoS攻击简介"><a href="#1、DoS攻击简介" class="headerlink" title="1、DoS攻击简介"></a>1、DoS攻击简介</h3><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/202310222231027.png"></p><p><strong>Dos</strong>是<strong>Denial of Service</strong>的简称，即拒绝服务。造成Dos的攻击行为被称为Dos攻击，其目的是使计算机或网络无法正常提供服务。</p><p>2、单包攻击及防御</p><p>最常见的Dos攻击就是单包攻击，一般都是以个人为单位的攻击者发动的，攻击报文比较单一。</p><ul><li>畸形报文攻击：通常指攻击者发送大量有缺陷的报文，从而造成被攻击的系统在处理这类报文时崩溃。</li><li>扫描类攻击：是一种潜在的攻击行为，并不造成直接的破坏结果，通常是攻击者发动真正攻击前的网络探测行为。</li><li>特殊控制类报文攻击：也是一种潜在的攻击行为，并不造成直接的破坏结果，攻击者通过发送特殊控制报文探测网络结构，为后续发动真正的攻击做准备。</li></ul><h4 id="（1）Ping-of-Death攻击及防御"><a href="#（1）Ping-of-Death攻击及防御" class="headerlink" title="（1）Ping of Death攻击及防御"></a>（1）Ping of Death攻击及防御</h4><p>P报文头中的长度字段为16位，表示IP报文的最大长度为65535字节。一些早期版本的操作系统对报文的大小是有限制的，如果收到大小超过65535字节的报文，会出现内存分配错误，进而导致系统崩溃。Ping of Death攻击指的就是攻击者不断的通过Ping命令向受害者发送超过65535字节的报文，导致受害者的系统崩溃。</p><p>防火墙是通过判定报文的大小是否大于65535字节来防御Ping of Death攻击的，如果报文大于65535字节，则判定为攻击报文，防火墙直接丢弃该报文。</p><h4 id="（2）Land攻击及防御"><a href="#（2）Land攻击及防御" class="headerlink" title="（2）Land攻击及防御"></a>（2）Land攻击及防御</h4><p>Land攻击是指攻击者向受害者发送伪造的TCP报文，此TCP报文的源地址和目的地址同为受害者的IP地址。这将导致受害者向它自己的地址发送回应报文，从而造成资</p><p>源的消耗。</p><p>防火墙在防御Land攻击时，检查TCP报文的源地址和目的地址是否相同，或者TCP报文的源地址是否为环回地址，如果TCP报文的源地址和目的地址相同或者源地址为环回地址，则直接丢弃该报文。</p><h4 id="（3）IP地址扫描攻击"><a href="#（3）IP地址扫描攻击" class="headerlink" title="（3）IP地址扫描攻击"></a>（3）IP地址扫描攻击</h4><p>IP地址扫描攻击是指攻击者使用ICMP报文（如执行Ping和Tracert命令）探测目标地址，或者使用TCP/UDP报文对特定地址发起连接，通过判断是否有应答报文，确定目标地址是否连接在网络上。</p><p>防火墙防御IP地址扫描攻击时，对收到的TCP，UDP，ICMP报文进行检测，某个源IP地址连续发送报文时，如果该IP发送的报文的目的IP地址与其发送的前一个报文的目的IP地址不同，则记为一次异常。当异常次数超过预定义的值，则认为该源IP正在进行IP地址扫描攻击，防火墙会将该源IP地址加入黑名单，后续收到来自该源IP地址的报文时，直接丢弃。</p><h4 id="（4）防御单包攻击的配置建议"><a href="#（4）防御单包攻击的配置建议" class="headerlink" title="（4）防御单包攻击的配置建议"></a>（4）防御单包攻击的配置建议</h4><p>针对现网实际环境中比较常见的一些攻击类型，开启防御功能后，防火墙可以很好地进行防范，对性能方面没有影响。而扫描类攻击在防御过程中比较消耗防火墙的性能，建议仅在发生扫描类攻击时再开启。</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/202310222249602.png"></p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《华为防火墙技术漫谈》02</title>
      <link href="/%E3%80%8A%E5%8D%8E%E4%B8%BA%E9%98%B2%E7%81%AB%E5%A2%99%E6%8A%80%E6%9C%AF%E6%BC%AB%E8%B0%88%E3%80%8B02/"/>
      <url>/%E3%80%8A%E5%8D%8E%E4%B8%BA%E9%98%B2%E7%81%AB%E5%A2%99%E6%8A%80%E6%9C%AF%E6%BC%AB%E8%B0%88%E3%80%8B02/</url>
      
        <content type="html"><![CDATA[<h1 id="读书笔记-《华为防火墙技术漫谈》02"><a href="#读书笔记-《华为防火墙技术漫谈》02" class="headerlink" title="读书笔记-《华为防火墙技术漫谈》02"></a>读书笔记-《华为防火墙技术漫谈》02</h1><h2 id="一、防火墙基础知识"><a href="#一、防火墙基础知识" class="headerlink" title="一、防火墙基础知识"></a>一、防火墙基础知识</h2><h3 id="4、调试"><a href="#4、调试" class="headerlink" title="4、调试"></a>4、调试</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Current Total Sessions : 5</span><br><span class="line">icmp VPN: public --&gt; public ID: c387fe127dddb48858634f7b51</span><br><span class="line">Zone: trust --&gt; untrust TTL: 00:00:20 Left: 00:00:15</span><br><span class="line">Recv Interface: GigabitEthernet1/0/1</span><br><span class="line">Interface: GigabitEthernet1/0/0 NextHop: 172.16.0.1 MAC: 5489-985b-694f</span><br><span class="line">&lt;--packets: 1 bytes: 60 --&gt; packets: 1 bytes: 60</span><br><span class="line">192.168.10.1:20603 --&gt; 172.16.0.1:2048 PolicyName: trust-untrust</span><br></pre></td></tr></table></figure><ul><li>Zone：表示报文在安全区域之间流动的方向，trust –&gt; untrust表示报文是从Trust区域流向Untrust区域。</li><li>TTL：表示报文的老化时间，这条会话到期后，这条会话也将会被清楚。</li><li>Left：表示该会话的剩余时间。</li><li>Interface：出接口</li><li>Nexthop：下一跳地址</li><li>MAC地址：报文去往的下一跳MAC地址，本组网中是WEB服务器的MAC地址。</li><li>&lt;–packets：1 bytes: 60 表示会话反向方向上的报文统计信息，即WEB服务器向PC发送报文的个数和字节数</li><li>–&gt; packets：1 bytes: 60 表示会话正向方向上的报文统计信息，即PC向WEB服务器发送报文的个数和字节数</li></ul><p>华为防火墙为不同的协议设置了响应的会话默认老化时间，比如ICMP的会话老化时间是20s,DNS的会话老化时间是30S等。</p><p>通常情况下采用这些默认值就可以保证各个协议正常运行，如果需要调整默认值，可以通过 firewall session aging-time 命令在配置。如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【FW] firewall session aging-time dns 10</span><br></pre></td></tr></table></figure><p>当我们需要解决与防火墙相关的问题时，调试是一个不可或缺的步骤。我们可以使用调试命令<code>display zone</code> 来查看防火墙安全区域的状态。防火墙的核心技术在于分析双方通信的连接状态，并随后建立会话以辅助后续报文的传输。因此，当业务无法正常通信时，检查会话是否成功建立在防火墙上，是一个至关重要的故障排查步骤。</p><p>一旦我们完成了防火墙的配置，但业务仍然无法正常运行，我们可以使用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【FW] display firewall session table </span><br></pre></td></tr></table></figure><p>命令在防火墙上查看是否存在与该业务相关的会话。然后，根据情况继续深入排查问题。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[fw]display firewall statistics system discard</span><br><span class="line"></span><br><span class="line">packets discard statistic </span><br><span class="line">total packets discarded: 2</span><br><span class="line">interzone miss packets discarded: 2</span><br></pre></td></tr></table></figure><h4 id="1、防火墙上不存在该业务的会话"><a href="#1、防火墙上不存在该业务的会话" class="headerlink" title="1、防火墙上不存在该业务的会话"></a>1、防火墙上不存在该业务的会话</h4><p>如果防火墙上没有为该业务建立会话，可能的原因包括：第一，业务报文没有到达防火墙；第二，业务报文被防火墙丢弃。</p><p>造成的具体原因包括：</p><ul><li>某个接口未被分配到正确的安全区域。</li><li>防火墙无法找到相关的ARP表项，导致报文被丢弃。</li><li>防火墙的路由配置出现问题。</li><li>防火墙仅收到了后续报文，而未收到首包报文。</li><li>防火墙上的会话数量已经达到规格限制，无法再创建新的会话。</li></ul><h4 id="2、防火墙上存在该业务的会话"><a href="#2、防火墙上存在该业务的会话" class="headerlink" title="2、防火墙上存在该业务的会话"></a>2、防火墙上存在该业务的会话</h4><p>如果在防火墙上存在与该业务相关的会话，这意味着会话在正向方向上有统计信息（即有报文经过），但在反向方向上没有统计信息（即没有报文经过）。导致会话反向方向上没有统计信息的原因可能是回应报文未能到达防火墙，或者回应报文被防火墙丢弃。在这种情况下，首先需要检查报文在到达防火墙之前是否被其他网络设备丢弃，然后查看防火墙上的丢包统计信息。</p><h2 id="二、安全策略"><a href="#二、安全策略" class="headerlink" title="二、安全策略"></a>二、安全策略</h2><p>安全策略是基于不同安全区域之间的域间关系来制定的，其内容包括两个主要组成部分：</p><ol><li><p>条件：检查报文的依据，防火墙将报文中携带的信息与条件逐一对比，以此来判断报文是否匹配。</p></li><li><p>动作：每一条策略都会包括一个动作，可以是允许<code>permit</code> 或拒绝通过 <code>deny</code> 每一条策略中只能有一个动作</p></li></ol><p>需要特别注意的是，在安全策略中的条件可以包括多个字段，如<strong>源地址、目的地址、源端口、目的端口</strong>等等。这些字段之间的关系是“与”的关系，也就是说，只有当报文中的信息与所有字段都匹配时，才能算作是匹配了该策略。</p><p>另外，如果在同一个字段中存在多个匹配项，例如多个源地址或多个目的地址，那么这些匹配项之间是“或”的关系。这意味着只要报文匹配其中的一个匹配项，就可以认为匹配了该条件。</p><h3 id="1、匹配顺序"><a href="#1、匹配顺序" class="headerlink" title="1、匹配顺序"></a>1、匹配顺序</h3><p>安全策略之间是存在顺序的，防火墙在两个安全区域之间转发报文时，会按照<strong>从上到下的顺序逐条查找域间存在的安全策略</strong>。如果报文匹配了某条安全策略，将会执行该策略中的动作，要么允许通过，要么拒绝通过，而不会再继续查找其他策略。只有当报文没有匹配任何一条策略时，防火墙才会考虑缺省包过滤，执行其中配置的动作。</p><p>基于上述实现方式，我们在配置安全策略时要遵循“先精细，后粗犷”的原则。具体来说，就是先配置匹配范围小、条件精确的安全策略，然后在配置匹配范围大、条件宽泛的安全策略。相信大家都配置过ACL规则，安全策略的配置和ACL规则是同一个道理。</p><p>例如：</p><p>允许Trust安全区域到Untrust安全区域的、源地址是192.168.0.0/24网段、目的地址是172.16.0.0/24网段的报文通过。</p><p>拒绝192.168.0.0网段中的特定地址192.168.0.100 访问172.16.0.0/24网段，首先要先配置第一条安全策略：拒绝Trust 安全区域到Untrust 安全区域的、源地址是192.1689.0.100的报文通过；然后配置第二条安全策略：允许Trust安全区域到Untrust安全区域的、源地址是192.168.0.0/24网段、目的地址是172.16.0.0/24网段的报文通过。</p><p>防火墙在查找安全策略时，源地址是192.168.0.100的报文会首先命中第一条策略，然后执行拒绝通过的动作；而192.168.0.0/24网段的其他报文会命中第二条策略，执行允许通过的动作。如果我们把两条安全策略的顺序调换，源地址是192.168.0.100的报文就永远不会命中动作为拒绝通过的那条策略，目的也没法达到。</p><p>最后，如果没有任何安全策略与报文匹配，防火墙将执行缺省包过滤中配置的动作。</p><p>默认情况下，缺省包过滤的动作是拒绝通过。有时候，为了简化配置，会把两个安全区域之间缺省包过滤的动作设置为允许通过。这样操作确实省事省时，但是会带来极大的安全风险，网络隔离和访问控制都没法实现。</p><p>华为防火墙默认情况下，报文在安全区域之内流动是不受安全策略控制的。报文可以自由通行。</p><h3 id="2、安全策略发展历程"><a href="#2、安全策略发展历程" class="headerlink" title="2、安全策略发展历程"></a>2、安全策略发展历程</h3><p>华为的防火墙策略主要历经了三个阶段：基于ACL的包过滤阶段、融合UTM的安全策略阶段、一体化安全策略阶段。</p><ol><li>基于ACL的包过滤阶段：<ul><li>初期的防火墙技术主要是基于访问控制列表（ACL）的包过滤，这是一种简单而有效的方法，用于控制流经防火墙的数据包。ACL主要依赖于源和目标IP地址、协议类型、端口等基本条件来过滤流量。</li><li>这个阶段的防火墙主要用于实现基本的网络访问控制，可以阻止不明流量或恶意流量的通过，但缺乏高级安全功能。</li></ul></li><li>融合UTM的安全策略阶段：<ul><li>随着网络攻击的不断演变，华为的防火墙逐渐融合了统一威胁管理（UTM）功能，加强了网络安全的多层次保护。</li><li>在这一阶段，防火墙不仅可以进行基本的包过滤，还具备了威胁检测、入侵检测系统（IDS）和入侵防御系统（IPS）等高级安全功能。此外，它还提供了反病毒、内容过滤、应用控制等特性。</li><li>安全策略不再仅仅依赖于ACL，而是基于更多的条件来决定流量的允许或拒绝，这增强了对恶意流量的检测和防御能力。</li></ul></li><li>一体化安全策略阶段：<ul><li>华为防火墙在这一阶段迈向了一体化的安全策略管理，将安全策略的配置和管理集成在一起，简化了网络安全管理和监控。</li><li>这一阶段的防火墙提供了更灵活的安全策略控制，可以根据不同的条件、应用、用户等因素进行决策，从而更好地满足复杂网络环境下的需求。</li><li>一体化的安全策略管理还允许管理员更方便地创建、维护和监视安全策略，提高了整体网络安全的可管理性和响应速度。</li></ul></li></ol><p>总的来说，华为的防火墙策略经历了从基本的包过滤到高级的威胁管理，再到一体化安全策略管理的演进，以适应不断增长的网络安全挑战。这些阶段的演进使华为防火墙成为一种强大的工具，能够在多层次、多维度上保护网络免受各种安全威胁的侵害。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《华为防火墙技术漫谈》01</title>
      <link href="/%E3%80%8A%E5%8D%8E%E4%B8%BA%E9%98%B2%E7%81%AB%E5%A2%99%E6%8A%80%E6%9C%AF%E6%BC%AB%E8%B0%88%E3%80%8B01/"/>
      <url>/%E3%80%8A%E5%8D%8E%E4%B8%BA%E9%98%B2%E7%81%AB%E5%A2%99%E6%8A%80%E6%9C%AF%E6%BC%AB%E8%B0%88%E3%80%8B01/</url>
      
        <content type="html"><![CDATA[<h1 id="读书笔记-《华为防火墙技术漫谈》01"><a href="#读书笔记-《华为防火墙技术漫谈》01" class="headerlink" title="读书笔记-《华为防火墙技术漫谈》01"></a>读书笔记-《华为防火墙技术漫谈》01</h1><h2 id="一、防火墙基础知识"><a href="#一、防火墙基础知识" class="headerlink" title="一、防火墙基础知识"></a>一、防火墙基础知识</h2><h3 id="1、防火墙基本概念"><a href="#1、防火墙基本概念" class="headerlink" title="1、防火墙基本概念"></a>1、防火墙基本概念</h3><p>防火墙主要用于保护一个网络免受来自另一个网络的攻击和入侵行为。由于其隔离和防御性质，防火墙可以在不同位置进行灵活部署，例如网络边界、子网隔离等，例如在企业网络出口、大型网络内部子网隔离以及数据中心边界等地。</p><p>防火墙与路由器和交换机有着明显的区别。路由器用于连接不同的网络，通过路由协议确保网络之间的互联互通，以确保数据包能够被正确转发到目标地。交换机则用于构建局域网，作为局域网通信的关键中继点，通过二层和三层交换来快速转发数据包。相比之下，防火墙的主要部署位置是网络边界，其主要任务是对进出网络的访问行为进行严格控制，安全防护是其核心特点。而路由器和交换机的本质是数据包的转发，而防火墙的本质是流量的控制和审查。</p><p>防火墙的功能包括以下几个关键点：</p><ol><li><p><strong>包过滤</strong>：防火墙能够审查网络数据包的源地址、目标地址、端口号和协议等信息，并根据预定义的规则来决定是否允许数据包通过或将其丢弃。</p></li><li><p><strong>状态检测</strong>：一些高级防火墙可以追踪网络连接的状态，以确保只有已建立的合法连接能够传输数据，而不允许未经请求的数据进入网络。</p></li><li><p><strong>NAT（网络地址转换）</strong>：防火墙可以执行网络地址转换，使内部网络上的多台计算机共享一个公共IP地址，从而提高网络安全性并减少IP地址的使用。</p></li><li><p><strong>应用层过滤</strong>：某些高级防火墙能够检查数据包中的应用层协议信息，以便防止恶意应用和攻击。</p></li><li><p><strong>代理服务</strong>：一些防火墙可以充当代理服务器，与外部服务器通信，以隐藏内部网络的细节。</p></li><li><p><strong>VPN支持</strong>：某些防火墙提供虚拟专用网络（VPN）功能，用于安全加密和连接远程网络。</p></li></ol><p>这些功能协助防火墙在网络中扮演关键的安全角色，确保网络免受未经授权的访问和潜在威胁的影响。</p><h3 id="2、接口、网络和安全区域"><a href="#2、接口、网络和安全区域" class="headerlink" title="2、接口、网络和安全区域"></a>2、接口、网络和安全区域</h3><p><strong>安全区域（Security Zone）</strong>是指由一个或多个接口组成的集合，它在防火墙中的作用是划分网络，并确定报文流动的路径。每个接口只能归属于一个安全区域，这意味着防火墙中的接口必须被明确定义为属于某个特定的安全区域，以便有效地控制流量的流向和实施安全策略。</p><p>在华为防火墙中，安全区域一般被分为以下四种：</p><ol><li><p><strong>Trust（受信任）区域</strong>：通常用于定义内部用户所在的网络，代表了高度受信任的网络。</p></li><li><p><strong>Untrust（不受信任）区域</strong>：通常用于表示不受信任的网络，例如互联网等不安全的网络。</p></li><li><p><strong>Dmz（半信任）区域</strong>：在该区域内的网络具有中等程度的受信任性，通常用于定义内部服务器所在的网络。</p></li><li><p><strong>Local（本地）区域</strong>：本地区域代表了防火墙本身。所有由防火墙主动发出的报文被视为来自本地区域，而需要防火墙响应和处理而不是转发的报文被视为送达本地区域。尽管Local区域中不能添加额外的接口，但防火墙上的所有接口都隐含属于Local区域。</p></li></ol><p>在华为防火墙中，每个安全区域都必须分配一个唯一的<strong>安全级别</strong>，该级别的范围通常在1到100之间。安全级别数值越高，表示该区域内的网络越受信任。文中将四个区域的安全级别设为：Local: 100，Trust:85，DMZ: 50，Untrust: 5</p><p>需要注意的是，在防火墙中，数据包的源和目的安全区域的确定方式会根据不同情况而有所不同。通常情况下，数据包的源安全区域可以根据接收数据包的接口来确定，而目的安全区域可以通过查找路由表来确定。在VPN场景中，防火墙会解封装报文，并根据路由表来确定目的安全区域，同时通过反向查找路由表的方式来确定源安全区域。</p><p>这些安全区域和级别的设置以及源目安全区域的确定方式，有助于防火墙实施流量控制和安全策略，确保网络的安全性和隔离。</p><h3 id="3、安全区域的配置"><a href="#3、安全区域的配置" class="headerlink" title="3、安全区域的配置"></a>3、安全区域的配置</h3><p>在安全区域的设置中，首先需要创建一个新的安全区域，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[FW] firewall zone name test //创建安全区域</span><br></pre></td></tr></table></figure><p>然后，为了将接口加入到这个安全区域中，必须先为该安全区域设置一个安全级别，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[fw-zone-test] set priority 10 //必须先设置安全级别，才能将接口加入到安全区域</span><br></pre></td></tr></table></figure><p>接下来，可以将特定接口（例如：gi 0/0/1）添加到已创建的安全区域，示例如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[fw-zone-test] add interface gi 0/0/1 //将接口 gi 0/0/1 加入安全区域</span><br></pre></td></tr></table></figure><p>需要注意的是，防火墙不仅支持物理接口，还支持逻辑接口，例如子接口、vlanif接口、GRE中的TUNNEL接口，以及L2TP中的virtual-template接口等。这些接口在配置时也需要将其加入到相应的安全区域中。</p><h3 id="4、状态监测与会话机制"><a href="#4、状态监测与会话机制" class="headerlink" title="4、状态监测与会话机制"></a>4、状态监测与会话机制</h3><p>状态监测采用基于连接的检测机制，将所有属于同一连接的通信双方之间交互的报文视为一个整体的数据流。这意味着同一个数据流内的报文不再被看作孤立的个体，而是相互关联的。举例来说，当为数据流的第一个报文建立会话时，后续报文将直接匹配会话进行转发，无需再次进行规则检查，从而提高了转发效率。</p><p>会话表的结构如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http VPN: public ----&gt; public 192.168.0.1:2049 ----&gt; 172.16.0.1:80</span><br></pre></td></tr></table></figure><p>在会话表中，各部分的含义如下：</p><ul><li><code>http</code> 表示协议</li><li><code>192.168.0.1</code> 表示源地址</li><li><code>2049</code> 表示源端口</li><li><code>172.16.0.1</code> 表示目的地址</li><li><code>80</code> 表示目的端口</li></ul><p>五元组，即源地址、源端口、目的地址、目的端口和协议，唯一确定了一条连接。任何具有相同这五个元素的报文都可视为属于同一条流。</p><p>对于某些协议，其报文中可能没有端口信息。以ICMP协议为例，其报文中没有端口信息。在这种情况下，防火墙会将ICMP报文头中的ID字段值作为ICMP会话的源端口，同时会将固定值2048作为ICMP会话的目的端口。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java八股</title>
      <link href="/Java%E5%85%AB%E8%82%A1/"/>
      <url>/Java%E5%85%AB%E8%82%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="Java面向对象有哪些特征，如何应用"><a href="#Java面向对象有哪些特征，如何应用" class="headerlink" title="Java面向对象有哪些特征，如何应用"></a><strong>Java面向对象有哪些特征，如何应用</strong></h1><p>​        面向对象编程是利用类和对象编程的一种思想。万物可归类，类是对于世界事物的高度抽象 ，不同的事物之间有不同的关系 ，一个类自身与外界的封装关系，一个父类和子类的继承关系， 一个类和多个类的多态关系。万物皆对象，对象是具体的世界事物，面向对象的三大特征封装，继承，多态。封装，封装说明一个类行为和属性与其他类的关系，低耦合，高内聚；继承是父类和子类的关系，多态说的是类与类的关系。</p><p>​        封装隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据。对外界而已它的内部细节是隐藏的，暴露给外界的只是它的访问方法。属性的封装：使用者只能通过事先定制好的方法来访问数据，可以方便地加入逻辑控制，限制对属性的 不合理操作；方法的封装：使用者按照既定的方式调用方法，不必关心方法的内部实现，便于使用； 便于修改，增强 代码的可维护性；</p><p>​        继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力。在本质上是特殊~一般的关系，即常说的is-a关系。子类继承父类，表明子类是一种特殊的父类，并且具有父类所不具有的一些属性或方法。从多种实现类中抽象出一个基类，使其具备多种实现类的共同特性 ，当实现类用extends关键字继承了基类（父类）后，实现类就具备了这些相同的属性。继承的类叫做子类（派生类或者超类），被继承的类叫做父类（或者基类）。比如从猫类、狗类、虎类中可以抽象出一个动物类，具有和猫、狗、虎类的共同特性（吃、跑、叫等）。Java通过extends关键字来实现继承，父类中通过private定义的变量和方法不会被继承，不能在子类中直接操作父类通过private定义的变量以及方法。继承避免了对一般类和特殊类之间共同特征进行的重复描述，通过继承可以清晰地表达每一项共同特征所适应的概念范围，在一般类中定义的属性和操作适应于这个类本身以及它以下的每一层特殊类的全部对象。运用继承原则使得系统模型比较简练也比较清晰。</p><p>​        相比于封装和继承，Java多态是三大特性中比较难的一个，封装和继承最后归结于多态， 多态指的是类和类的关系，两个类由继承关系，存在有方法的重写，故而可以在调用时有父类引用指向子类对象。多态必备三个要素：继承，重写，父类引用指向子类对象。</p><h1 id="HashMap原理是什么，在jdk1-7和1-8中有什么区别"><a href="#HashMap原理是什么，在jdk1-7和1-8中有什么区别" class="headerlink" title="HashMap原理是什么，在jdk1.7和1.8中有什么区别"></a>HashMap原理是什么，在jdk1.7和1.8中有什么区别</h1><p>HashMap 根据键的 hashCode 值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为 null。HashMap 非线程安全，即任一时刻可以有多个线程同时写 HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections 的 synchronizedMap 方法使 HashMap 具有线程安全的能力，或者使用 ConcurrentHashMap。我们用下面这张图来介绍</p><p>HashMap 的结构。</p><p><strong>JAVA7</strong> 实现 </p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/Java7_HashMap.jpg" style="zoom:67%;" /><p>大方向上，HashMap 里面是一个数组，然后数组中每个元素是一个单向链表。上图中，每个绿色</p><p>的实体是嵌套类 Entry 的实例，Entry 包含四个属性：key, value, hash 值和用于单向链表的 next。 </p><ol><li><p>capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。 </p></li><li><p>loadFactor：负载因子，默认为 0.75。 </p></li><li><p>threshold：扩容的阈值，等于 capacity * loadFactor </p></li></ol><p>**JAVA8实现 **</p><p>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组+链表+红黑树 组成。 </p><p>根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决</p><p>于链表的长度，为 O(n)。为了降低这部分的开销，在 Java8 中，当链表中的元素超过了 8 个以后，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。 </p><img src="../../../牛客网最新java面试八股文MD课件/最全MD请看-200题目和答案（xin）分布式+微服务+MYSQL+Redis+JVM+Spring等等/images/Java8_HashMap.jpg" style="zoom:67%;" /><h1 id="ArrayList和LinkedList有什么区别"><a href="#ArrayList和LinkedList有什么区别" class="headerlink" title="ArrayList和LinkedList有什么区别"></a>ArrayList和LinkedList有什么区别</h1><p>ArrayList和LinkedList都实现了List接口，他们有以下的不同点：<br>ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。<br>相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。<br>LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。<br>也可以参考ArrayList vs. LinkedList。</p><ol><li><p>因为 Array 是基于索引 (index) 的数据结构，它使用索引在数组中搜索和读取数据是很快的。 Array 获取数据的时间复杂度是 O(1), 但是要删除数据却是开销很大的，因为这需要重排数组中的所有数据。</p></li><li><p>相对于 ArrayList ， LinkedList 插入是更快的。因为 LinkedList 不像 ArrayList 一样，不需要改变数组的大小，也不需要在数组装满的时候要将所有的数据重新装入一个新的数组，这是 ArrayList 最坏的一种情况，时间复杂度是 O(n) ，而 LinkedList 中插入或删除的时间复杂度仅为 O(1) 。 ArrayList 在插入数据时还需要更新索引（除了插入数组的尾部）。</p></li><li><p>类似于插入数据，删除数据时， LinkedList 也优于 ArrayList 。</p></li><li><p>LinkedList 需要更多的内存，因为 ArrayList 的每个索引的位置是实际的数据，而 LinkedList 中的每个节点中存储的是实际的数据和前后节点的位置 ( 一个 LinkedList 实例存储了两个值： Node<E> first 和 Node<E> last 分别表示链表的其实节点和尾节点，每个 Node 实例存储了三个值： E item,Node next,Node pre) 。</p></li></ol><p>什么场景下更适宜使用 LinkedList，而不用ArrayList</p><ol><li><p>你的应用不会随机访问数据 。因为如果你需要LinkedList中的第n个元素的时候，你需要从第一个元素顺序数到第n个数据，然后读取数据。</p></li><li><p>你的应用更多的插入和删除元素，更少的读取数据 。因为插入和删除元素不涉及重排数据，所以它要比ArrayList要快。</p></li></ol><p>换句话说，ArrayList的实现用的是数组，LinkedList是基于链表，ArrayList适合查找，LinkedList适合增删</p><p> 以上就是关于 ArrayList和LinkedList的差别。你需要一个不同步的基于索引的数据访问时，请尽量使用ArrayList。ArrayList很快，也很容易使用。但是要记得要给定一个合适的初始大小，尽可能的减少更改数组的大小。</p><h1 id="高并发中的集合有哪些问题"><a href="#高并发中的集合有哪些问题" class="headerlink" title="高并发中的集合有哪些问题"></a>高并发中的集合有哪些问题</h1><p>**第一代线程安全集合类 **</p><p>Vector、Hashtable </p><p>是怎么保证线程安排的： 使用synchronized修饰方法*</p><p>缺点：效率低下 </p><p><strong>第二代线程非安全集合类</strong></p><p>ArrayList、HashMap</p><p>线程不安全，但是性能好，用来替代Vector、Hashtable             </p><p>使用ArrayList、HashMap，需要线程安全怎么办呢？ </p><p>使用 Collections.<em>synchronizedList</em>(list); Collections.<em>synchronizedMap</em>(m); </p><p>底层使用synchronized代码块锁 虽然也是锁住了所有的代码，但是锁在方法里边，并所在方法外边性能可以理解为稍有提高吧。毕竟进方法本身就要分配资源的 </p><p><strong>第三代线程安全集合类</strong></p><p>在大量并发情况下如何提高集合的效率和安全呢？ </p><p>java.util.concurrent.* </p><p>ConcurrentHashMap：</p><p>CopyOnWriteArrayList ：</p><p>CopyOnWriteArraySet：   注意 不是CopyOnWriteHashSet*</p><p>底层大都采用Lock锁（1.8的ConcurrentHashMap不使用Lock锁），保证安全的同时，性能也很高。       </p><h1 id="jdk1-8的新特性有哪些"><a href="#jdk1-8的新特性有哪些" class="headerlink" title="jdk1.8的新特性有哪些"></a>jdk1.8的新特性有哪些</h1><h3 id="一、接口的默认方法"><a href="#一、接口的默认方法" class="headerlink" title="一、接口的默认方法"></a>一、接口的默认方法</h3><p>Java 8允许我们给接口添加一个非抽象的方法实现，只需要使用 default关键字即可，这个特征又叫做扩展方法，示例如下：</p><p>代码如下:</p><p>interface Formula { double calculate(int a);</p><p>default double sqrt(int a) { return Math.sqrt(a); } }</p><p>Formula接口在拥有calculate方法之外同时还定义了sqrt方法，实现了Formula接口的子类只需要实现一个calculate方法，默认方法sqrt将在子类上可以直接使用。</p><p>代码如下:</p><p>Formula formula = new Formula() { @Override public double calculate(int a) { return sqrt(a * 100); } };</p><p>formula.calculate(100); // 100.0 formula.sqrt(16); // 4.0</p><p>文中的formula被实现为一个匿名类的实例，该代码非常容易理解，6行代码实现了计算 sqrt(a * 100)。在下一节中，我们将会看到实现单方法接口的更简单的做法。</p><p>译者注： 在Java中只有单继承，如果要让一个类赋予新的特性，通常是使用接口来实现，在C++中支持多继承，允许一个子类同时具有多个父类的接口与功能，在其他语言中，让一个类同时具有其他的可复用代码的方法叫做mixin。新的Java 8 的这个特新在编译器实现的角度上来说更加接近Scala的trait。 在C#中也有名为扩展方法的概念，允许给已存在的类型扩展方法，和Java 8的这个在语义上有差别。</p><h3 id="二、Lambda-表达式"><a href="#二、Lambda-表达式" class="headerlink" title="二、Lambda 表达式"></a>二、Lambda 表达式</h3><p>首先看看在老版本的Java中是如何排列字符串的：</p><p>代码如下:</p><p>List<String> names = Arrays.asList(“peterF”, “anna”, “mike”, “xenia”);</p><p>Collections.sort(names, new Comparator<String>() { @Override public int compare(String a, String b) { return b.compareTo(a); } });</p><p>只需要给静态方法 Collections.sort 传入一个List对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给sort方法。</p><p>在Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，lambda表达式：</p><p>代码如下:</p><p>Collections.sort(names, (String a, String b) -&gt; { return b.compareTo(a); });</p><p>看到了吧，代码变得更段且更具有可读性，但是实际上还可以写得更短：</p><p>代码如下:</p><p>Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));</p><p>对于函数体只有一行代码的，你可以去掉大括号{}以及return关键字，但是你还可以写得更短点：</p><p>代码如下:</p><p>Collections.sort(names, (a, b) -&gt; b.compareTo(a));</p><p>Java编译器可以自动推导出参数类型，所以你可以不用再写一次类型。接下来我们看看lambda表达式还能作出什么更方便的东西来：</p><h3 id="三、函数式接口"><a href="#三、函数式接口" class="headerlink" title="三、函数式接口"></a>三、函数式接口</h3><p>Lambda表达式是如何在java的类型系统中表示的呢？每一个lambda表达式都对应一个类型，通常是接口类型。而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为 默认方法 不算抽象方法，所以你也可以给你的函数式接口添加默认方法。</p><p>我们可以将lambda表达式当作任意只包含一个抽象方法的接口类型，确保你的接口一定达到这个要求，你只需要给你的接口添加 @FunctionalInterface 注解，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的。</p><p>示例如下：</p><p>代码如下:</p><p>@FunctionalInterface interface Converter&lt;F, T&gt; { T convert(F from); } Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from); Integer converted = converter.convert(“123”); System.out.println(converted); // 123</p><p>需要注意如果@FunctionalInterface如果没有指定，上面的代码也是对的。</p><p>译者注 将lambda表达式映射到一个单方法的接口上，这种做法在Java 8之前就有别的语言实现，比如Rhino JavaScript解释器，如果一个函数参数接收一个单方法的接口而你传递的是一个function，Rhino 解释器会自动做一个单接口的实例到function的适配器，典型的应用场景有 org.w3c.dom.events.EventTarget 的addEventListener 第二个参数 EventListener。</p><h3 id="四、方法与构造函数引用"><a href="#四、方法与构造函数引用" class="headerlink" title="四、方法与构造函数引用"></a>四、方法与构造函数引用</h3><p>前一节中的代码还可以通过静态方法引用来表示：</p><p>代码如下:</p><p>Converter&lt;String, Integer&gt; converter = Integer::valueOf; Integer converted = converter.convert(“123”); System.out.println(converted); // 123</p><p>Java 8 允许你使用 :: 关键字来传递方法或者构造函数引用，上面的代码展示了如何引用一个静态方法，我们也可以引用一个对象的方法：</p><p>代码如下:</p><p>converter = something::startsWith; String converted = converter.convert(“Java”); System.out.println(converted); // “J”</p><p>接下来看看构造函数是如何使用::关键字来引用的，首先我们定义一个包含多个构造函数的简单类：</p><p>代码如下:</p><p>class Person { String firstName; String lastName;</p><p>Person() {}</p><p>Person(String firstName, String lastName) { this.firstName = firstName; this.lastName = lastName; } }</p><p>接下来我们指定一个用来创建Person对象的对象工厂接口：</p><p>代码如下:</p><p>interface PersonFactory<P extends Person> { P create(String firstName, String lastName); }</p><p>这里我们使用构造函数引用来将他们关联起来，而不是实现一个完整的工厂：</p><p>代码如下:</p><p>PersonFactory<Person> personFactory = Person::new; Person person = personFactory.create(“Peter”, “Parker”);</p><p>我们只需要使用 Person::new 来获取Person类构造函数的引用，Java编译器会自动根据PersonFactory.create方法的签名来选择合适的构造函数。</p><h3 id="五、Lambda-作用域"><a href="#五、Lambda-作用域" class="headerlink" title="五、Lambda 作用域"></a>五、Lambda 作用域</h3><p>在lambda表达式中访问外层作用域和老版本的匿名对象中的方式很相似。你可以直接访问标记了final的外层局部变量，或者实例的字段以及静态变量。</p><h3 id="六、访问局部变量"><a href="#六、访问局部变量" class="headerlink" title="六、访问局部变量"></a>六、访问局部变量</h3><p>我们可以直接在lambda表达式中访问外层的局部变量：</p><p>代码如下:</p><p>final int num = 1; Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num);</p><p>stringConverter.convert(2); // 3</p><p>但是和匿名对象不同的是，这里的变量num可以不用声明为final，该代码同样正确：</p><p>代码如下:</p><p>int num = 1; Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num);</p><p>stringConverter.convert(2); // 3</p><p>不过这里的num必须不可被后面的代码修改（即隐性的具有final的语义），例如下面的就无法编译：</p><p>代码如下:</p><p>int num = 1; Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num); num = 3;</p><p>在lambda表达式中试图修改num同样是不允许的。</p><h3 id="七、访问对象字段与静态变量"><a href="#七、访问对象字段与静态变量" class="headerlink" title="七、访问对象字段与静态变量"></a>七、访问对象字段与静态变量</h3><p>和本地变量不同的是，lambda内部对于实例的字段以及静态变量是即可读又可写。该行为和匿名对象是一致的：</p><p>代码如下:</p><p>class Lambda4 { static int outerStaticNum; int outerNum;</p><p>void testScopes() { Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; { outerNum = 23; return String.valueOf(from); };</p><p>Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; {  outerStaticNum = 72;  return String.valueOf(from);  }; } }</p><h3 id="八、访问接口的默认方法"><a href="#八、访问接口的默认方法" class="headerlink" title="八、访问接口的默认方法"></a>八、访问接口的默认方法</h3><p>还记得第一节中的formula例子么，接口Formula定义了一个默认方法sqrt可以直接被formula的实例包括匿名对象访问到，但是在lambda表达式中这个是不行的。 Lambda表达式中是无法访问到默认方法的，以下代码将无法编译：</p><p>代码如下:</p><p>Formula formula = (a) -&gt; sqrt( a * 100); Built-in Functional Interfaces</p><p>JDK 1.8 API包含了很多内建的函数式接口，在老Java中常用到的比如Comparator或者Runnable接口，这些接口都增加了@FunctionalInterface注解以便能用在lambda上。 Java 8 API同样还提供了很多全新的函数式接口来让工作更加方便，有一些接口是来自Google Guava库里的，即便你对这些很熟悉了，还是有必要看看这些是如何扩展到lambda上使用的。</p><p><strong>Predicate****接口</strong></p><p>Predicate 接口只有一个参数，返回boolean类型。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）：</p><p>代码如下:</p><p>Predicate<String> predicate = (s) -&gt; s.length() &gt; 0;</p><p>predicate.test(“foo”); // true predicate.negate().test(“foo”); // false</p><p>Predicate<Boolean> nonNull = Objects::nonNull; Predicate<Boolean> isNull = Objects::isNull;</p><p>Predicate<String> isEmpty = String::isEmpty; Predicate<String> isNotEmpty = isEmpty.negate();</p><p><strong>Function</strong> <strong>接口</strong></p><p>Function 接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（compose, andThen）：</p><p>代码如下:</p><p>Function&lt;String, Integer&gt; toInteger = Integer::valueOf; Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);</p><p>backToString.apply(“123”); // “123”</p><p><strong>Supplier</strong> <strong>接口</strong> Supplier 接口返回一个任意范型的值，和Function接口不同的是该接口没有任何参数</p><p>代码如下:</p><p>Supplier<Person> personSupplier = Person::new; personSupplier.get(); // new Person</p><p><strong>Consumer</strong> <strong>接口</strong> Consumer 接口表示执行在单个参数上的操作。</p><p>代码如下:</p><p>Consumer<Person> greeter = (p) -&gt; System.out.println(“Hello, “ + p.firstName); greeter.accept(new Person(“Luke”, “Skywalker”));</p><p><strong>Comparator</strong> <strong>接口</strong> Comparator 是老Java中的经典接口， Java 8在此之上添加了多种默认方法：</p><p>代码如下:</p><p>Comparator<Person> comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);</p><p>Person p1 = new Person(“John”, “Doe”); Person p2 = new Person(“Alice”, “Wonderland”);</p><p>comparator.compare(p1, p2); // &gt; 0 comparator.reversed().compare(p1, p2); // &lt; 0</p><p><strong>Optional</strong> <strong>接口</strong></p><p>Optional 不是函数是接口，这是个用来防止NullPointerException异常的辅助类型，这是下一届中将要用到的重要概念，现在先简单的看看这个接口能干什么：</p><p>Optional 被定义为一个简单的容器，其值可能是null或者不是null。在Java 8之前一般某个函数应该返回非空对象但是偶尔却可能返回了null，而在Java 8中，不推荐你返回null而是返回Optional。</p><p>代码如下:</p><p>Optional<String> optional = Optional.of(“bam”);</p><p>optional.isPresent(); // true optional.get(); // “bam” optional.orElse(“fallback”); // “bam”</p><p>optional.ifPresent((s) -&gt; System.out.println(s.charAt(0))); // “b”</p><p><strong>Stream</strong> <strong>接口</strong></p><p>java.util.Stream 表示能应用在一组元素上一次执行的操作序列。Stream 操作分为中间操作或者最终操作两种，最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样你就可以将多个操作依次串起来。Stream 的创建需要指定一个数据源，比如 java.util.Collection的子类，List或者Set， Map不支持。Stream的操作可以串行执行或者并行执行。</p><p>首先看看Stream是怎么用，首先创建实例代码的用到的数据List：</p><p>代码如下:</p><p>List<String> stringCollection = new ArrayList&lt;&gt;(); stringCollection.add(“ddd2”); stringCollection.add(“aaa2”); stringCollection.add(“bbb1”); stringCollection.add(“aaa1”); stringCollection.add(“bbb3”); stringCollection.add(“ccc”); stringCollection.add(“bbb2”); stringCollection.add(“ddd1”);</p><p>Java 8扩展了集合类，可以通过 Collection.stream() 或者 Collection.parallelStream() 来创建一个Stream。下面几节将详细解释常用的Stream操作：</p><p><strong>Filter</strong> <strong>过滤</strong></p><p>过滤通过一个predicate接口来过滤并只保留符合条件的元素，该操作属于中间操作，所以我们可以在过滤后的结果来应用其他Stream操作（比如forEach）。forEach需要一个函数来对过滤后的元素依次执行。forEach是一个最终操作，所以我们不能在forEach之后来执行其他Stream操作。</p><p>代码如下:</p><p>stringCollection .stream() .filter((s) -&gt; s.startsWith(“a”)) .forEach(System.out::println);</p><p>// “aaa2”, “aaa1”</p><p><strong>Sort</strong> <strong>排序</strong></p><p>排序是一个中间操作，返回的是排序好后的Stream。如果你不指定一个自定义的Comparator则会使用默认排序。</p><p>代码如下:</p><p>stringCollection .stream() .sorted() .filter((s) -&gt; s.startsWith(“a”)) .forEach(System.out::println);</p><p>// “aaa1”, “aaa2”</p><p>需要注意的是，排序只创建了一个排列好后的Stream，而不会影响原有的数据源，排序之后原数据stringCollection是不会被修改的：</p><p>代码如下:</p><p>System.out.println(stringCollection); // ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1</p><p><strong>Map</strong> <strong>映射</strong> 中间操作map会将元素根据指定的Function接口来依次将元素转成另外的对象，下面的示例展示了将字符串转换为大写字符串。你也可以通过map来讲对象转换成其他类型，map返回的Stream类型是根据你map传递进去的函数的返回值决定的。</p><p>代码如下:</p><p>stringCollection .stream() .map(String::toUpperCase) .sorted((a, b) -&gt; b.compareTo(a)) .forEach(System.out::println);</p><p>// “DDD2”, “DDD1”, “CCC”, “BBB3”, “BBB2”, “AAA2”, “AAA1”</p><p><strong>Match</strong> <strong>匹配</strong></p><p>Stream提供了多种匹配操作，允许检测指定的Predicate是否匹配整个Stream。所有的匹配操作都是最终操作，并返回一个boolean类型的值。</p><p>代码如下:</p><p>boolean anyStartsWithA = stringCollection .stream() .anyMatch((s) -&gt; s.startsWith(“a”));</p><p>System.out.println(anyStartsWithA); // true</p><p>boolean allStartsWithA = stringCollection .stream() .allMatch((s) -&gt; s.startsWith(“a”));</p><p>System.out.println(allStartsWithA); // false</p><p>boolean noneStartsWithZ = stringCollection .stream() .noneMatch((s) -&gt; s.startsWith(“z”));</p><p>System.out.println(noneStartsWithZ); // true</p><p><strong>Count</strong> <strong>计数</strong> 计数是一个最终操作，返回Stream中元素的个数，返回值类型是long。</p><p>代码如下:</p><p>long startsWithB = stringCollection .stream() .filter((s) -&gt; s.startsWith(“b”)) .count();</p><p>System.out.println(startsWithB); // 3</p><p><strong>Reduce</strong> <strong>规约</strong></p><p>这是一个最终操作，允许通过指定的函数来讲stream中的多个元素规约为一个元素，规越后的结果是通过Optional接口表示的：</p><p>代码如下:</p><p>Optional<String> reduced = stringCollection .stream() .sorted() .reduce((s1, s2) -&gt; s1 + “#” + s2);</p><p>reduced.ifPresent(System.out::println); // “aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2”</p><p><strong>并行****Streams</strong></p><p>前面提到过Stream有串行和并行两种，串行Stream上的操作是在一个线程中依次完成，而并行Stream则是在多个线程上同时执行。</p><p>下面的例子展示了是如何通过并行Stream来提升性能：</p><p>首先我们创建一个没有重复元素的大表：</p><p>代码如下:</p><p>int max = 1000000; List<String> values = new ArrayList&lt;&gt;(max); for (int i = 0; i &lt; max; i++) { UUID uuid = UUID.randomUUID(); values.add(uuid.toString()); }</p><p>然后我们计算一下排序这个Stream要耗时多久， 串行排序：</p><p>代码如下:</p><p>long t0 = System.nanoTime();</p><p>long count = values.stream().sorted().count(); System.out.println(count);</p><p>long t1 = System.nanoTime();</p><p>long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0); System.out.println(String.format(“sequential sort took: %d ms”, millis));</p><p>// 串行耗时: 899 ms 并行排序：</p><p>代码如下:</p><p>long t0 = System.nanoTime();</p><p>long count = values.parallelStream().sorted().count(); System.out.println(count);</p><p>long t1 = System.nanoTime();</p><p>long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0); System.out.println(String.format(“parallel sort took: %d ms”, millis));</p><p>// 并行排序耗时: 472 ms 上面两个代码几乎是一样的，但是并行版的快了50%之多，唯一需要做的改动就是将stream()改为parallelStream()。</p><p><strong>Map</strong></p><p>前面提到过，Map类型不支持stream，不过Map提供了一些新的有用的方法来处理一些日常任务。</p><p>代码如下:</p><p>Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</p><p>for (int i = 0; i &lt; 10; i++) { map.putIfAbsent(i, “val” + i); }</p><p>map.forEach((id, val) -&gt; System.out.println(val)); 以上代码很容易理解， putIfAbsent 不需要我们做额外的存在性检查，而forEach则接收一个Consumer接口来对map里的每一个键值对进行操作。</p><p>下面的例子展示了map上的其他有用的函数：</p><p>代码如下:</p><p>map.computeIfPresent(3, (num, val) -&gt; val + num); map.get(3); // val33</p><p>map.computeIfPresent(9, (num, val) -&gt; null); map.containsKey(9); // false</p><p>map.computeIfAbsent(23, num -&gt; “val” + num); map.containsKey(23); // true</p><p>map.computeIfAbsent(3, num -&gt; “bam”); map.get(3); // val33</p><p>接下来展示如何在Map里删除一个键值全都匹配的项：</p><p>代码如下:</p><p>map.remove(3, “val3”); map.get(3); // val33</p><p>map.remove(3, “val33”); map.get(3); // null</p><p>另外一个有用的方法：</p><p>代码如下:</p><p>map.getOrDefault(42, “not found”); // not found</p><p>对Map的元素做合并也变得很容易了：</p><p>代码如下:</p><p>map.merge(9, “val9”, (value, newValue) -&gt; value.concat(newValue)); map.get(9); // val9</p><p>map.merge(9, “concat”, (value, newValue) -&gt; value.concat(newValue)); map.get(9); // val9concat</p><p>Merge做的事情是如果键名不存在则插入，否则则对原键对应的值做合并操作并重新插入到map中。</p><h3 id="九、Date-API"><a href="#九、Date-API" class="headerlink" title="九、Date API"></a>九、Date API</h3><p>Java 8 在包java.time下包含了一组全新的时间日期API。新的日期API和开源的Joda-Time库差不多，但又不完全一样，下面的例子展示了这组新API里最重要的一些部分：</p><p><strong>Clock</strong> <strong>时钟</strong></p><p>Clock类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代 System.currentTimeMillis() 来获取当前的微秒数。某一个特定的时间点也可以使用Instant类来表示，Instant类也可以用来创建老的java.util.Date对象。</p><p>代码如下:</p><p>Clock clock = Clock.systemDefaultZone(); long millis = clock.millis();</p><p>Instant instant = clock.instant(); Date legacyDate = Date.from(instant); // legacy java.util.Date</p><p><strong>Timezones</strong> <strong>时区</strong></p><p>在新API中时区使用ZoneId来表示。时区可以很方便的使用静态方法of来获取到。 时区定义了到UTS时间的时间差，在Instant时间点对象到本地日期对象之间转换的时候是极其重要的。</p><p>代码如下:</p><p>System.out.println(ZoneId.getAvailableZoneIds()); // prints all available timezone ids</p><p>ZoneId zone1 = ZoneId.of(“Europe/Berlin”); ZoneId zone2 = ZoneId.of(“Brazil/East”); System.out.println(zone1.getRules()); System.out.println(zone2.getRules());</p><p>// ZoneRules[currentStandardOffset=+01:00] // ZoneRules[currentStandardOffset=-03:00]</p><p><strong>LocalTime</strong> <strong>本地时间</strong></p><p>LocalTime 定义了一个没有时区信息的时间，例如 晚上10点，或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差：</p><p>代码如下:</p><p>LocalTime now1 = LocalTime.now(zone1); LocalTime now2 = LocalTime.now(zone2);</p><p>System.out.println(now1.isBefore(now2)); // false</p><p>long hoursBetween = ChronoUnit.HOURS.between(now1, now2); long minutesBetween = ChronoUnit.MINUTES.between(now1, now2);</p><p>System.out.println(hoursBetween); // -3 System.out.println(minutesBetween); // -239</p><p>LocalTime 提供了多种工厂方法来简化对象的创建，包括解析时间字符串。</p><p>代码如下:</p><p>LocalTime late = LocalTime.of(23, 59, 59); System.out.println(late); // 23:59:59</p><p>DateTimeFormatter germanFormatter = DateTimeFormatter .ofLocalizedTime(FormatStyle.SHORT) .withLocale(Locale.GERMAN);</p><p>LocalTime leetTime = LocalTime.parse(“13:37”, germanFormatter); System.out.println(leetTime); // 13:37</p><p><strong>LocalDate</strong> <strong>本地日期</strong></p><p>LocalDate 表示了一个确切的日期，比如 2014-03-11。该对象值是不可变的，用起来和LocalTime基本一致。下面的例子展示了如何给Date对象加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。</p><p>代码如下:</p><p>LocalDate today = LocalDate.now(); LocalDate tomorrow = today.plus(1, ChronoUnit.DAYS); LocalDate yesterday = tomorrow.minusDays(2);</p><p>LocalDate independenceDay = LocalDate.of(2014, Month.JULY, 4); DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();</p><p>System.out.println(dayOfWeek); // FRIDAY 从字符串解析一个LocalDate类型和解析LocalTime一样简单：</p><p>代码如下:</p><p>DateTimeFormatter germanFormatter = DateTimeFormatter .ofLocalizedDate(FormatStyle.MEDIUM) .withLocale(Locale.GERMAN);</p><p>LocalDate xmas = LocalDate.parse(“24.12.2014”, germanFormatter); System.out.println(xmas); // 2014-12-24</p><p><strong>LocalDateTime</strong> <strong>本地日期时间</strong></p><p>LocalDateTime 同时表示了时间和日期，相当于前两节内容合并到一个对象上了。LocalDateTime和LocalTime还有LocalDate一样，都是不可变的。LocalDateTime提供了一些能访问具体字段的方法。</p><p>代码如下:</p><p>LocalDateTime sylvester = LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59);</p><p>DayOfWeek dayOfWeek = sylvester.getDayOfWeek(); System.out.println(dayOfWeek); // WEDNESDAY</p><p>Month month = sylvester.getMonth(); System.out.println(month); // DECEMBER</p><p>long minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY); System.out.println(minuteOfDay); // 1439</p><p>只要附加上时区信息，就可以将其转换为一个时间点Instant对象，Instant时间点对象可以很容易的转换为老式的java.util.Date。</p><p>代码如下:</p><p>Instant instant = sylvester .atZone(ZoneId.systemDefault()) .toInstant();</p><p>Date legacyDate = Date.from(instant); System.out.println(legacyDate); // Wed Dec 31 23:59:59 CET 2014</p><p>格式化LocalDateTime和格式化时间和日期一样的，除了使用预定义好的格式外，我们也可以自己定义格式：</p><p>代码如下:</p><p>DateTimeFormatter formatter = DateTimeFormatter .ofPattern(“MMM dd, yyyy - HH:mm”);</p><p>LocalDateTime parsed = LocalDateTime.parse(“Nov 03, 2014 - 07:13”, formatter); String string = formatter.format(parsed); System.out.println(string); // Nov 03, 2014 - 07:13</p><p>和java.text.NumberFormat不一样的是新版的DateTimeFormatter是不可变的，所以它是线程安全的。</p><h3 id="十、Annotation-注解"><a href="#十、Annotation-注解" class="headerlink" title="十、Annotation 注解"></a>十、Annotation 注解</h3><p>在Java 8中支持多重注解了，先看个例子来理解一下是什么意思。 首先定义一个包装类Hints注解用来放置一组具体的Hint注解：</p><p>代码如下:</p><p>@interface Hints { Hint[] value(); }</p><p>@Repeatable(Hints.class) @interface Hint { String value(); }</p><p>Java 8允许我们把同一个类型的注解使用多次，只需要给该注解标注一下@Repeatable即可。</p><p>例 1: 使用包装类当容器来存多个注解（老方法）</p><p>代码如下:</p><p>@Hints({@Hint(“hint1”), @Hint(“hint2”)}) class Person {}</p><p>例 2：使用多重注解（新方法）</p><p>代码如下:</p><p>@Hint(“hint1”) @Hint(“hint2”) class Person {}</p><p>第二个例子里java编译器会隐性的帮你定义好@Hints注解，了解这一点有助于你用反射来获取这些信息：</p><p>代码如下:</p><p>Hint hint = Person.class.getAnnotation(Hint.class); System.out.println(hint); // null</p><p>Hints hints1 = Person.class.getAnnotation(Hints.class); System.out.println(hints1.value().length); // 2</p><p>Hint[] hints2 = Person.class.getAnnotationsByType(Hint.class); System.out.println(hints2.length); // 2</p><p>即便我们没有在Person类上定义@Hints注解，我们还是可以通过 getAnnotation(Hints.class) 来获取 @Hints注解，更加方便的方法是使用 getAnnotationsByType 可以直接获取到所有的@Hint注解。 另外Java 8的注解还增加到两种新的target上了：</p><p>代码如下:</p><p>@Target({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE}) @interface MyAnnotation {}</p><p>关于Java 8的新特性就写到这了，肯定还有更多的特性等待发掘。JDK 1.8里还有很多很有用的东西，比如Arrays.parallelSort, StampedLock和CompletableFuture等等。</p><h1 id="Java中重写和重载有哪些区别"><a href="#Java中重写和重载有哪些区别" class="headerlink" title="Java中重写和重载有哪些区别"></a>Java中重写和重载有哪些区别</h1><p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态</p><p>性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为</p><p>重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方</p><p>法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。</p><p>方法重载的规则：</p><p>1.方法名一致，参数列表中参数的顺序，类型，个数不同。</p><p>2.重载与方法的返回值无关，存在于父类和子类，同类中。</p><p>3.可以抛出不同的异常，可以有不同修饰符</p><p>方法重写的规则：</p><p>1.参数列表必须完全与被重写方法的一致，返回类型必须完全与被重写方法的返回类型一致。</p><p>2.构造方法不能被重写，声明为 final 的方法不能被重写，声明为 static 的方法不能被重写，但是能够被再次</p><p>声明。</p><p>3.访问权限不能比父类中被重写的方法的访问权限更低。</p><p>4.重写的方法能够抛出任何非强制异常（UncheckedException，也叫非运行时异常），无论被重写的方法是</p><p>否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则</p><p>可以。</p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB.png" style="zoom:80%;" /><h1 id="接口和抽象类有哪些区别"><a href="#接口和抽象类有哪些区别" class="headerlink" title="接口和抽象类有哪些区别"></a>接口和抽象类有哪些区别</h1><p>不同：</p><p>抽象类：</p><p>1.抽象类中可以定义构造器</p><p>2.可以有抽象方法和具体方法</p><p>3.接口中的成员全都是 public 的</p><p>4.抽象类中可以定义成员变量</p><p>5.有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法</p><p>6.抽象类中可以包含静态方法</p><p>7.一个类只能继承一个抽象类</p><p>接口：</p><p>1.接口中不能定义构造器</p><p>2.方法全部都是抽象方法</p><p>3.抽象类中的成员可以是 private、默认、protected、public</p><p>4.接口中定义的成员变量实际上都是常量</p><p>5.接口中不能有静态方法</p><p>6.一个类可以实现多个接口</p><p>相同：</p><p>1.不能够实例化</p><p>2.可以将抽象类和接口类型作为引用类型</p><p>3.一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要</p><p>被声明为抽象类</p><h1 id="怎样声明一个类不会被继承，什么场景下会用"><a href="#怎样声明一个类不会被继承，什么场景下会用" class="headerlink" title="怎样声明一个类不会被继承，什么场景下会用"></a>怎样声明一个类不会被继承，什么场景下会用</h1><p>如果一个类被final修饰，此类不可以有子类，不能被其它类继承，如果一个中的所有方法都没有重写的需要，当前类没有子类也罢，就可以使用final修饰类。</p><h1 id="Java中-和equals有哪些区别"><a href="#Java中-和equals有哪些区别" class="headerlink" title="Java中==和equals有哪些区别"></a>Java中==和equals有哪些区别</h1><p>equals 和== 最大的区别是一个是方法一个是运算符。</p><p>==：如果比较的对象是基本数据类型，则比较的是数值是否相等；如果比较的是引用数据类型，则比较的是对象</p><p>的地址值是否相等。</p><p>equals()：用来比较方法两个对象的内容是否相等。</p><p>注意：equals 方法不能用于基本数据类型的变量，如果没有对 equals 方法进行重写，则比较的是引用类型的变</p><p>量所指向的对象的地址。</p><h1 id="String、StringBuffer、StringBuilder区别及使用场景"><a href="#String、StringBuffer、StringBuilder区别及使用场景" class="headerlink" title="String、StringBuffer、StringBuilder区别及使用场景"></a>String、StringBuffer、StringBuilder区别及使用场景</h1><p>Java 平台提供了两种类型的字符串：String 和 StringBuffer/StringBuilder，它们都可以储存和操作字符串，区别</p><p>如下。</p><p>1）String 是只读字符串，也就意味着 String 引用的字符串内容是不能被改变的。初学者可能会有这样的误解：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String str = “abc”；</span><br><span class="line">str = “bcd”;</span><br></pre></td></tr></table></figure><p>如上，字符串 str 明明是可以改变的呀！其实不然，str 仅仅是一个引用对象，它指向一个字符串对象“abc”。第</p><p>二行代码的含义是让 str 重新指向了一个新的字符串“bcd”对象，而“abc”对象并没有任何改变，只不过该对象已</p><p>经成为一个不可及对象罢了。</p><p>2）StringBuffer/StringBuilder 表示的字符串对象可以直接进行修改。</p><p>3）StringBuilder 是 Java5 中引入的，它和 StringBuffer 的方法完全相同，区别在于它是在单线程环境下使用的，</p><p>因为它的所有方法都没有被 synchronized 修饰，因此它的效率理论上也比 StringBuffer 要高。</p><p><img src="../../../%E7%89%9B%E5%AE%A2%E7%BD%91%E6%9C%80%E6%96%B0java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87MD%E8%AF%BE%E4%BB%B6/%E6%9C%80%E5%85%A8MD%E8%AF%B7%E7%9C%8B-200%E9%A2%98%E7%9B%AE%E5%92%8C%E7%AD%94%E6%A1%88%EF%BC%88xin%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F+%E5%BE%AE%E6%9C%8D%E5%8A%A1+MYSQL+Redis+JVM+Spring%E7%AD%89%E7%AD%89/images/StringBuilder.png"></p><h1 id="Java代理的几种实现方式"><a href="#Java代理的几种实现方式" class="headerlink" title="Java代理的几种实现方式"></a>Java代理的几种实现方式</h1><p>第一种:静态代理,只能静态的代理某些类或者某些方法,不推荐使用,功能比较弱,但是编码简单</p><p>第二种:动态代理,包含Proxy代理和CGLIB动态代理</p><h2 id="Proxy代理是JDK内置的动态代理"><a href="#Proxy代理是JDK内置的动态代理" class="headerlink" title="Proxy代理是JDK内置的动态代理"></a>Proxy代理是JDK内置的动态代理</h2><p>​         特点:面向接口的,不需要导入三方依赖的动态代理,可以对多个不同的接口进行增强,通过反射读取注解时,只能读取到接口上的注解</p><p>​         原理:面向接口,只能对实现类在实现接口中定义的方法进行增强</p><p>定义接口和实现</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.proxy;</span><br><span class="line"></span><br><span class="line">public interface UserService &#123;</span><br><span class="line">    public String getName(int id);</span><br><span class="line"></span><br><span class="line">    public Integer getAge(int id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.proxy;</span><br><span class="line"></span><br><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String getName(int id) &#123;</span><br><span class="line">        System.out.println(&quot;------getName------&quot;);</span><br><span class="line">        return &quot;riemann&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Integer getAge(int id) &#123;</span><br><span class="line">        System.out.println(&quot;------getAge------&quot;);</span><br><span class="line">        return 26;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.proxy;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class MyInvocationHandler implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    public Object target;</span><br><span class="line"></span><br><span class="line">    MyInvocationHandler() &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MyInvocationHandler(Object target) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        if (&quot;getName&quot;.equals(method.getName())) &#123;</span><br><span class="line">            System.out.println(&quot;++++++before &quot; + method.getName() + &quot;++++++&quot;);</span><br><span class="line">            Object result = method.invoke(target, args);</span><br><span class="line">            System.out.println(&quot;++++++after &quot; + method.getName() + &quot;++++++&quot;);</span><br><span class="line">            return result;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Object result = method.invoke(target, args);</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.proxy;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">public class Main1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        UserService userService = new UserServiceImpl();</span><br><span class="line">        InvocationHandler invocationHandler = new MyInvocationHandler(userService);</span><br><span class="line">        UserService userServiceProxy = (UserService) Proxy.newProxyInstance(userService.getClass().getClassLoader(),</span><br><span class="line">                userService.getClass().getInterfaces(),invocationHandler);</span><br><span class="line">        System.out.println(userServiceProxy.getName(1));</span><br><span class="line">        System.out.println(userServiceProxy.getAge(1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h2><p>​        特点:面向父类的动态代理,需要导入第三方依赖</p><p>​        原理:面向父类,底层通过子类继承父类并重写方法的形式实现增强</p><p>Proxy和CGLIB是非常重要的代理模式,是springAOP底层实现的主要两种方式</p><p>CGLIB的核心类：<br>net.sf.cglib.proxy.Enhancer – 主要的增强类<br>net.sf.cglib.proxy.MethodInterceptor – 主要的方法拦截类，它是Callback接口的子接口，需要用户实现<br>net.sf.cglib.proxy.MethodProxy – JDK的java.lang.reflect.Method类的代理类，可以方便的实现对源对象方法的调用,如使用：<br>Object o = methodProxy.invokeSuper(proxy, args);//虽然第一个参数是被代理对象，也不会出现死循环的问题。</p><p>net.sf.cglib.proxy.MethodInterceptor接口是最通用的回调（callback）类型，它经常被基于代理的AOP用来实现拦截（intercept）方法的调用。这个接口只定义了一个方法<br>public Object intercept(Object object, java.lang.reflect.Method method,<br>Object[] args, MethodProxy proxy) throws Throwable;</p><p>第一个参数是代理对像，第二和第三个参数分别是拦截的方法和方法的参数。原来的方法可能通过使用java.lang.reflect.Method对象的一般反射调用，或者使用 net.sf.cglib.proxy.MethodProxy对象调用。net.sf.cglib.proxy.MethodProxy通常被首选使用，因为它更快。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.proxy.cglib;</span><br><span class="line"></span><br><span class="line">import net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line">import net.sf.cglib.proxy.MethodProxy;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"> </span><br><span class="line">public class CglibProxy implements MethodInterceptor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;++++++before &quot; + methodProxy.getSuperName() + &quot;++++++&quot;);</span><br><span class="line">        System.out.println(method.getName());</span><br><span class="line">        Object o1 = methodProxy.invokeSuper(o, args);</span><br><span class="line">        System.out.println(&quot;++++++before &quot; + methodProxy.getSuperName() + &quot;++++++&quot;);</span><br><span class="line">        return o1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.proxy.cglib;</span><br><span class="line"> </span><br><span class="line">import com.test3.service.UserService;</span><br><span class="line">import com.test3.service.impl.UserServiceImpl;</span><br><span class="line">import net.sf.cglib.proxy.Enhancer;</span><br><span class="line"> </span><br><span class="line">public class Main2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CglibProxy cglibProxy = new CglibProxy();</span><br><span class="line"> </span><br><span class="line">        Enhancer enhancer = new Enhancer();</span><br><span class="line">        enhancer.setSuperclass(UserServiceImpl.class);</span><br><span class="line">        enhancer.setCallback(cglibProxy);</span><br><span class="line"> </span><br><span class="line">        UserService o = (UserService)enhancer.create();</span><br><span class="line">        o.getName(1);</span><br><span class="line">        o.getAge(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="hashcode和equals如何使用"><a href="#hashcode和equals如何使用" class="headerlink" title="hashcode和equals如何使用"></a>hashcode和equals如何使用</h1><p>equals()源自于java.lang.Object,该方法用来简单验证两个对象的相等性。Object类中定义的默认实现只检查两个对象的对象引用，以验证它们的相等性。 通过重写该方法,可以自定义验证对象相等新的规则,如果你使用ORM处理一些对象的话，你要确保在hashCode()和equals()对象中使用getter和setter而不是直接引用成员变量 </p><p>hashCode()源自于java.lang.Object ,该方法用于获取给定对象的唯一的整数(散列码)。当这个对象需要存储在哈希表这样的数据结构时，这个整数用于确定桶的位置。默认情况下，对象的hashCode()方法返回对象所在内存地址的整数表示。hashCode()是HashTable、HashMap和HashSet使用的。默认的，Object类的hashCode()方法返回这个对象存储的内存地址的编号。</p><p>hash散列算法,使得在hash表中查找一个记录速度变O(1). 每个记录都有自己的hashcode,散列算法按照hashcode把记录放置在合适的位置. 在查找一个记录,首先先通过hashcode快速定位记录的位置.然后再通过equals来比较是否相等。如果hashcode没找到，则不equal，元素不存在于哈希表中；即使找到了，也只需执行hashcode相同的几个元素的equal，如果不equal，还是不存在哈希表中。</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/HashMap1.7hashcodequals.png"></p><h1 id="HashMap和HashTable的区别及底层实现"><a href="#HashMap和HashTable的区别及底层实现" class="headerlink" title="HashMap和HashTable的区别及底层实现"></a>HashMap和HashTable的区别及底层实现</h1><h2 id="HashMap和HashTable对比"><a href="#HashMap和HashTable对比" class="headerlink" title="HashMap和HashTable对比"></a>HashMap和HashTable对比</h2><ol><li>HashTable线程同步，HashMap非线程同步。</li><li>HashTable不允许&lt;键,值&gt;有空值，HashMap允许&lt;键,值&gt;有空值。</li><li>HashTable使用Enumeration，HashMap使用Iterator。</li><li>HashTable中hash数组的默认大小是11，增加方式的old*2+1，HashMap中hash数组的默认大小是16，增长方式是2的指数倍。</li></ol><p>5.HashMap jdk1.8之前list + 链表 jdk1.8之后list + 链表,当链表长度到8时，转化为红黑树</p><p>6.HashMap链表插入节点的方式 在Java1.7中，插入链表节点使用<strong>头插法</strong>。Java1.8中变成了<strong>尾插法</strong>  </p><p>7.Java1.8的hash()中，将hash值高位（前16位）参与到取模的运算中，使得计算结果的不确定性增强，降低发生哈希碰撞的概率</p><h2 id="HashMap扩容优化"><a href="#HashMap扩容优化" class="headerlink" title="HashMap扩容优化:"></a>HashMap扩容优化:</h2><p>扩容以后,1.7对元素进行rehash算法,计算原来每个元素在扩容之后的哈希表中的位置,1.8借助2倍扩容机制,元素不需要进行重新计算位置</p><p>JDK 1.8 在扩容时并没有像 JDK 1.7 那样，重新计算每个元素的哈希值，而是通过高位运算<strong>（e.hash &amp; oldCap）</strong>来确定元素是否需要移动，比如 key1 的信息如下：</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/1621414916379-1621752756248.png"></p><p>使用 e.hash &amp; oldCap 得到的结果，高一位为 0，当结果为 0 时表示元素在扩容时位置不会发生任何变化，而 key 2 信息如下</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/1621414931120-1621752756248.png"></p><p>高一位为 1，当结果为 1 时，表示元素在扩容时位置发生了变化，新的下标位置等于原下标位置 + 原数组长度**hashmap,**<strong>不必像1.7一样全部重新计算位置</strong></p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/1621414949373.png" style="zoom:67%;" /><h2 id="为什么hashmap扩容的时候是两倍？"><a href="#为什么hashmap扩容的时候是两倍？" class="headerlink" title="为什么hashmap扩容的时候是两倍？"></a>为什么hashmap扩容的时候是两倍？</h2><p>查看源代码</p><p>在存入元素时,放入元素位置有一个 (n-1)&amp;hash 的一个算法,和hash&amp;(newCap-1),这里用到了一个&amp;位运算符</p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/1621415056875.png" style="zoom:67%;" />   <p>当HashMap的容量是16时，它的二进制是10000，(n-1)的二进制是01111，与hash值得计算结果如下</p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/1621415081690.png" style="zoom:67%;" /><p>下面就来看一下HashMap的容量不是2的n次幂的情况，当容量为10时，二进制为01010，(n-1)的二进制是01001，向里面添加同样的元素，结果为</p><img src="../../../牛客网最新java面试八股文MD课件/最全MD请看-200题目和答案（xin）分布式+微服务+MYSQL+Redis+JVM+Spring等等/images/1621415094318.png" style="zoom:67%;" /><p>可以看出，有三个不同的元素进过&amp;运算得出了同样的结果，严重的hash碰撞了</p><p>只有当n的值是2的N次幂的时候，进行&amp;位运算的时候，才可以只看后几位，而不需要全部进行计算</p><h2 id="hashmap线程安全的方式？"><a href="#hashmap线程安全的方式？" class="headerlink" title="hashmap线程安全的方式？"></a>hashmap线程安全的方式？</h2><p>HashMap不是线程安全的,往往在写程序时需要通过一些方法来回避.其实JDK原生的提供了2种方法让HashMap支持线程安全.</p><p>方法一:通过Collections.synchronizedMap()返回一个新的Map,这个新的map就是线程安全的. 这个要求大家习惯基于接口编程,因为返回的并不是HashMap,而是一个Map的实现.</p><p>方法二:重新改写了HashMap,具体的可以查看java.util.concurrent.ConcurrentHashMap. 这个方法比方法一有了很大的改进.</p><p>方法一特点: </p><p>通过Collections.synchronizedMap()来封装所有不安全的HashMap的方法,就连toString, hashCode都进行了封装. 封装的关键点有2处,1)使用了经典的synchronized来进行互斥, 2)使用了代理模式new了一个新的类,这个类同样实现了Map接口.在Hashmap上面,synchronized锁住的是对象,所以第一个申请的得到锁,其他线程将进入阻塞,等待唤醒. 优点:代码实现十分简单,一看就懂.缺点:从锁的角度来看,方法一直接使用了锁住方法,基本上是锁住了尽可能大的代码块.性能会比较差.</p><p>方法二特点:</p><p>重新写了HashMap,比较大的改变有如下几点.使用了新的锁机制,把HashMap进行了拆分,拆分成了多个独立的块,这样在高并发的情况下减少了锁冲突的可能,使用的是NonfairSync. 这个特性调用CAS指令来确保原子性与互斥性.当如果多个线程恰好操作到同一个segment上面,那么只会有一个线程得到运行.</p><p>优点:需要互斥的代码段比较少,性能会比较好. ConcurrentHashMap把整个Map切分成了多个块,发生锁碰撞的几率大大降低,性能会比较好. 缺点:代码繁琐</p><h1 id="Java异常处理方式"><a href="#Java异常处理方式" class="headerlink" title="Java异常处理方式"></a>Java异常处理方式</h1><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20201109173809704.png"  /><p>Java 通过面向对象的方法进行异常处理，一旦方法抛出异常，系统自动根据该异常对象寻找合适异常处理器（Exception Handler）来处理该异常，把各种不同的异常进行分类，并提供了良好的接口。在 Java 中，每个异常都是一个对</p><p>象，它是 Throwable 类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并可以对其进行处理。Java 的异常处理是通过 5 个关键词来实现的：try、 catch、throw、throws 和 finally。</p><p>在Java应用中，异常的处理机制分为声明异常，抛出异常和捕获异常。</p><p>throw和throws的区别：<br>（1）位置不同：<br>throw：方法内部<br>throws: 方法的签名处，方法的声明处</p><p>（2）内容不同：<br>throw+异常对象（检查异常，运行时异常）<br>throws+异常的类型（可以多个类型，用，拼接）</p><p>（3）作用不同：<br>throw：异常出现的源头，制造异常。<br>throws:在方法的声明处，告诉方法的调用者，这个方法中可能会出现我声明的这些异常。然后调用者对这个异常进行处理：<br>要么自己处理要么再继续向外抛出异常</p><h2 id="1-throws声明异常"><a href="#1-throws声明异常" class="headerlink" title="1.throws声明异常"></a>1.throws声明异常</h2><p>通常，应该捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下</p><p>去。传递异常可以在方法签名处使用 throws 关键字声明可能会抛出的异常。注意</p><p>非检查异常（Error、RuntimeException 或它们的子类）不可使用 throws 关键字来声明要抛出的异常。</p><p>​       一个方法出现编译时异常，就需要 try-catch/ throws 处理，否则会导致编译错误</p><h2 id="2-throw抛出异常"><a href="#2-throw抛出异常" class="headerlink" title="2.throw抛出异常"></a>2.throw抛出异常</h2><p>如果你觉得解决不了某些异常问题，且不需要调用者处理，那么你可以抛出异常。 throw关键字作用是在方法内部抛出一个Throwable类型的异常。任何Java代码都可以通过throw语句抛出异常。</p><h2 id="3-trycatch捕获异常"><a href="#3-trycatch捕获异常" class="headerlink" title="3.trycatch捕获异常"></a>3.trycatch捕获异常</h2><p>程序通常在运行之前不报错，但是运行后可能会出现某些未知的错误，但是还不想直接抛出到上一级，那么就需要通过try…catch…的形式进行异常捕获，之后根据不同的异常情况来进行相应的处理。如何选择异常类型</p><p>可以根据下图来选择是捕获异常，声明异常还是抛出异常</p><img src="../../../牛客网最新java面试八股文MD课件/最全MD请看-200题目和答案（xin）分布式+微服务+MYSQL+Redis+JVM+Spring等等/images/image-20201109173855168.png"  /><h1 id="自定义异常在生产中如何应用"><a href="#自定义异常在生产中如何应用" class="headerlink" title="自定义异常在生产中如何应用"></a>自定义异常在生产中如何应用</h1><p> Java虽然提供了丰富的异常处理类，但是在项目中还会经常使用自定义异常，其主要原因是Java提供的异常类在某些情况下还是不能满足实际需球。例如以下情况：<br>  1、系统中有些错误是符合Java语法，但不符合业务逻辑。</p><p>  2、在分层的软件结构中，通常是在表现层统一对系统其他层次的异常进行捕获处理。 </p><h1 id="如何实现一个IOC容器"><a href="#如何实现一个IOC容器" class="headerlink" title="如何实现一个IOC容器?"></a>如何实现一个IOC容器?</h1><p>​        IOC(Inversion of Control),意思是控制反转，不是什么技术，而是一种设计思想，IOC意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。</p><p>​        在传统的程序设计中，我们直接在对象内部通过new进行对象创建，是程序主动去创建依赖对象，而IOC是有专门的容器来进行对象的创建，即IOC容器来控制对象的创建。</p><p>​        在传统的应用程序中，我们是在对象中主动控制去直接获取依赖对象，这个是正转，反转是由容器来帮忙创建及注入依赖对象，在这个过程过程中，由容器帮我们查找级注入依赖对象，对象只是被动的接受依赖对象。</p><p>​        1、先准备一个基本的容器对象，包含一些map结构的集合，用来方便后续过程中存储具体的对象</p><p>​        2、进行配置文件的读取工作或者注解的解析工作，将需要创建的bean对象都封装成BeanDefinition对象存储在容器中</p><p>​        3、容器将封装好的BeanDefinition对象通过反射的方式进行实例化，完成对象的实例化工作</p><p>​        4、进行对象的初始化操作，也就是给类中的对应属性值就行设置，也就是进行依赖注入，完成整个对象的创建，变成一个完整的bean对象，存储在容器的某个map结构中</p><p>​        5、通过容器对象来获取对象，进行对象的获取和逻辑处理工作</p><p>​        6、提供销毁操作，当对象不用或者容器关闭的时候，将无用的对象进行销毁</p><h1 id="说说你对Spring-的理解？"><a href="#说说你对Spring-的理解？" class="headerlink" title="说说你对Spring 的理解？"></a>说说你对Spring 的理解？</h1><p>官网地址：<a href="https://spring.io/projects/spring-framework#overview">https://spring.io/projects/spring-framework#overview</a></p><p>压缩包下载地址：<a href="https://repo.spring.io/release/org/springframework/spring/">https://repo.spring.io/release/org/springframework/spring/</a></p><p>源码地址：<a href="https://github.com/spring-projects/spring-framework">https://github.com/spring-projects/spring-framework</a></p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Spring makes it easy to create Java enterprise applications. It provides everything you need to embrace the Java language in an enterprise environment, with support for Groovy and Kotlin as alternative languages on the JVM, and with the flexibility to create many kinds of architectures depending on an application’s needs. As of Spring Framework 5.1, Spring requires JDK 8+ (Java SE 8+) and provides out-of-the-box support for JDK 11 LTS. Java SE 8 update 60 is suggested as the minimum patch release for Java 8, but it is generally recommended to use a recent patch release.</span><br><span class="line"></span><br><span class="line">Spring supports a wide range of application scenarios. In a large enterprise, applications often exist for a long time and have to run on a JDK and application server whose upgrade cycle is beyond developer control. Others may run as a single jar with the server embedded, possibly in a cloud environment. Yet others may be standalone applications (such as batch or integration workloads) that do not need a server.</span><br><span class="line"></span><br><span class="line">Spring is open source. It has a large and active community that provides continuous feedback based on a diverse range of real-world use cases. This has helped Spring to successfully evolve over a very long time.</span><br><span class="line"></span><br><span class="line">Spring 使创建 Java 企业应用程序变得更加容易。它提供了在企业环境中接受 Java 语言所需的一切,，并支持 Groovy 和 Kotlin 作为 JVM 上的替代语言，并可根据应用程序的需要灵活地创建多种体系结构。 从 Spring Framework 5.0 开始，Spring 需要 JDK 8(Java SE 8+)，并且已经为 JDK 9 提供了现成的支持。</span><br><span class="line"></span><br><span class="line">Spring支持各种应用场景， 在大型企业中, 应用程序通常需要运行很长时间，而且必须运行在 jdk 和应用服务器上，这种场景开发人员无法控制其升级周期。 其他可能作为一个单独的jar嵌入到服务器去运行，也有可能在云环境中。还有一些可能是不需要服务器的独立应用程序(如批处理或集成的工作任务)。</span><br><span class="line"></span><br><span class="line">Spring 是开源的。它拥有一个庞大而且活跃的社区，提供不同范围的，真实用户的持续反馈。这也帮助Spring不断地改进,不断发展。</span><br></pre></td></tr></table></figure><h1 id="你觉得Spring的核心是什么？"><a href="#你觉得Spring的核心是什么？" class="headerlink" title="你觉得Spring的核心是什么？"></a>你觉得Spring的核心是什么？</h1><p>​        spring是一个开源框架。</p><p>​        spring是为了简化企业开发而生的，使得开发变得更加优雅和简洁。</p><p>​        spring是一个<strong>IOC</strong>和<strong>AOP</strong>的容器框架。</p><p>​                IOC：控制反转</p><p>​                AOP：面向切面编程</p><p>​                容器：包含并管理应用对象的生命周期，就好比用桶装水一样，spring就是桶，而对象就是水</p><h1 id="说一下使用spring的优势？"><a href="#说一下使用spring的优势？" class="headerlink" title="说一下使用spring的优势？"></a>说一下使用spring的优势？</h1><p>​        1、Spring通过DI、AOP和消除样板式代码来简化企业级Java开发</p><p>​        2、Spring框架之外还存在一个构建在核心框架之上的庞大生态圈，它将Spring扩展到不同的领域，如Web服务、REST、移动开发以及NoSQL</p><p>​        3、低侵入式设计，代码的污染极低</p><p>​        4、独立于各种应用服务器，基于Spring框架的应用，可以真正实现Write Once,Run Anywhere的承诺</p><p>​        5、Spring的IoC容器降低了业务对象替换的复杂性，提高了组件之间的解耦</p><p>​        6、Spring的AOP支持允许将一些通用任务如安全、事务、日志等进行集中式处理，从而提供了更好的复用</p><p>​        7、Spring的ORM和DAO提供了与第三方持久层框架的的良好整合，并简化了底层的数据库访问</p><p>​        8、Spring的高度开放性，并不强制应用完全依赖于Spring，开发者可自由选用Spring框架的部分或全部</p><h1 id="Spring是如何简化开发的？"><a href="#Spring是如何简化开发的？" class="headerlink" title="Spring是如何简化开发的？"></a>Spring是如何简化开发的？</h1><p>​        基于POJO的轻量级和最小侵入性编程</p><p>​        通过依赖注入和面向接口实现松耦合</p><p>​        基于切面和惯例进行声明式编程</p><p>​        通过切面和模板减少样板式代码</p><h1 id="说说你对Aop的理解？"><a href="#说说你对Aop的理解？" class="headerlink" title="说说你对Aop的理解？"></a>说说你对Aop的理解？</h1><p>​        AOP全称叫做 Aspect Oriented Programming  面向切面编程。它是为解耦而生的，解耦是程序员编码开发过程中一直追求的境界，AOP在业务类的隔离上，绝对是做到了解耦，在这里面有几个核心的概念：</p><ul><li><p>切面（Aspect）: 指关注点模块化，这个关注点可能会横切多个对象。事务管理是企业级Java应用中有关横切关注点的例子。 在Spring AOP中，切面可以使用通用类基于模式的方式（schema-based approach）或者在普通类中以<code>@Aspect</code>注解（@AspectJ 注解方式）来实现。</p></li><li><p>连接点（Join point）: 在程序执行过程中某个特定的点，例如某个方法调用的时间点或者处理异常的时间点。在Spring AOP中，一个连接点总是代表一个方法的执行。</p></li><li><p>通知（Advice）: 在切面的某个特定的连接点上执行的动作。通知有多种类型，包括“around”, “before” and “after”等等。通知的类型将在后面的章节进行讨论。 许多AOP框架，包括Spring在内，都是以拦截器做通知模型的，并维护着一个以连接点为中心的拦截器链。</p></li><li><p>切点（Pointcut）: 匹配连接点的断言。通知和切点表达式相关联，并在满足这个切点的连接点上运行（例如，当执行某个特定名称的方法时）。切点表达式如何和连接点匹配是AOP的核心：Spring默认使用AspectJ切点语义。</p></li><li><p>引入（Introduction）: 声明额外的方法或者某个类型的字段。Spring允许引入新的接口（以及一个对应的实现）到任何被通知的对象上。例如，可以使用引入来使bean实现 <code>IsModified</code>接口， 以便简化缓存机制（在AspectJ社区，引入也被称为内部类型声明（inter））。</p></li><li><p>目标对象（Target object）: 被一个或者多个切面所通知的对象。也被称作被通知（advised）对象。既然Spring AOP是通过运行时代理实现的，那么这个对象永远是一个被代理（proxied）的对象。</p></li><li><p>AOP代理（AOP proxy）:AOP框架创建的对象，用来实现切面契约（aspect contract）（包括通知方法执行等功能）。在Spring中，AOP代理可以是JDK动态代理或CGLIB代理。</p></li><li><p>织入（Weaving）: 把切面连接到其它的应用程序类型或者对象上，并创建一个被被通知的对象的过程。这个过程可以在编译时（例如使用AspectJ编译器）、类加载时或运行时中完成。 Spring和其他纯Java AOP框架一样，是在运行时完成织入的。</p><p>这些概念都太学术了，如果更简单的解释呢，其实非常简单：</p><p>任何一个系统都是由不同的组件组成的，每个组件负责一块特定的功能，当然会存在很多组件是跟业务无关的，例如日志、事务、权限等核心服务组件，这些核心服务组件经常融入到具体的业务逻辑中，如果我们为每一个具体业务逻辑操作都添加这样的代码，很明显代码冗余太多，因此我们需要将这些公共的代码逻辑抽象出来变成一个切面，然后注入到目标对象（具体业务）中去，AOP正是基于这样的一个思路实现的，通过动态代理的方式，将需要注入切面的对象进行代理，在进行调用的时候，将公共的逻辑直接添加进去，而不需要修改原有业务的逻辑代码，只需要在原来的业务逻辑基础之上做一些增强功能即可。</p></li></ul><h1 id="说说你对IOC的理解？"><a href="#说说你对IOC的理解？" class="headerlink" title="说说你对IOC的理解？"></a>说说你对IOC的理解？</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IoC is also known as dependency injection (DI). It is a process whereby objects define their dependencies (that is, the other objects they work with) only through constructor arguments, arguments to a factory method, or properties that are set on the object instance after it is constructed or returned from a factory method. The container then injects those dependencies when it creates the bean. This process is fundamentally the inverse (hence the name, Inversion of Control) of the bean itself controlling the instantiation or location of its dependencies by using direct construction of classes or a mechanism such as the Service Locator pattern.</span><br><span class="line">IOC与大家熟知的依赖注入同理，. 这是一个通过依赖注入对象的过程 也就是说，它们所使用的对象，是通过构造函数参数，工厂方法的参数或这是从工厂方法的构造函数或返回值的对象实例设置的属性，然后容器在创建bean时注入这些需要的依赖。 这个过程相对普通创建对象的过程是反向的（因此称之为IoC），bean本身通过直接构造类来控制依赖关系的实例化或位置，或提供诸如服务定位器模式之类的机制。</span><br></pre></td></tr></table></figure><p>​        如果这个过程比较难理解的话，那么可以想象自己找女朋友和婚介公司找女朋友的过程。如果这个过程能够想明白的话，那么我们现在回答上面的问题：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、谁控制谁：在之前的编码过程中，都是需要什么对象自己去创建什么对象，有程序员自己来控制对象，而有了IOC容器之后，就会变成由IOC容器来控制对象，</span><br><span class="line">2、控制什么：在实现过程中所需要的对象及需要依赖的对象</span><br><span class="line">3、什么是反转：在没有IOC容器之前我们都是在对象中主动去创建依赖的对象，这是正转的，而有了IOC之后，依赖的对象直接由IOC容器创建后注入到对象中，由主动创建变成了被动接受，这是反转</span><br><span class="line">4、哪些方面被反转：依赖的对象</span><br></pre></td></tr></table></figure><h1 id="BeanFactory和ApplicationContext有什么区别"><a href="#BeanFactory和ApplicationContext有什么区别" class="headerlink" title="BeanFactory和ApplicationContext有什么区别"></a>BeanFactory和ApplicationContext有什么区别</h1><p>相同：</p><ul><li>Spring提供了两种不同的IOC 容器，一个是BeanFactory，另外一个是ApplicationContext，它们都是Java  interface，ApplicationContext继承于BeanFactory(ApplicationContext继承ListableBeanFactory。</li><li>它们都可以用来配置XML属性，也支持属性的自动注入。</li><li>而ListableBeanFactory继承BeanFactory)，BeanFactory 和 ApplicationContext 都提供了一种方式，使用getBean(“bean name”)获取bean。</li></ul><p>不同：</p><ul><li>当你调用getBean()方法时，BeanFactory仅实例化bean，而ApplicationContext 在启动容器的时候实例化单例bean，不会等待调用getBean()方法时再实例化。</li><li>BeanFactory不支持国际化，即i18n，但ApplicationContext提供了对它的支持。</li><li>BeanFactory与ApplicationContext之间的另一个区别是能够将事件发布到注册为监听器的bean。</li><li>BeanFactory 的一个核心实现是XMLBeanFactory 而ApplicationContext  的一个核心实现是ClassPathXmlApplicationContext，Web容器的环境我们使用WebApplicationContext并且增加了getServletContext 方法。</li><li>如果使用自动注入并使用BeanFactory，则需要使用API注册AutoWiredBeanPostProcessor，如果使用ApplicationContext，则可以使用XML进行配置。</li><li>简而言之，BeanFactory提供基本的IOC和DI功能，而ApplicationContext提供高级功能，BeanFactory可用于测试和非生产使用，但ApplicationContext是功能更丰富的容器实现，应该优于BeanFactory</li></ul><h1 id="简述spring-bean的生命周期？"><a href="#简述spring-bean的生命周期？" class="headerlink" title="简述spring bean的生命周期？"></a>简述spring bean的生命周期？</h1><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png"></p><p>1、实例化bean对象</p><p>​    通过反射的方式进行对象的创建，此时的创建只是在堆空间中申请空间，属性都是默认值</p><p>2、设置对象属性</p><p>​    给对象中的属性进行值的设置工作</p><p>3、检查Aware相关接口并设置相关依赖</p><p>​    如果对象中需要引用容器内部的对象，那么需要调用aware接口的子类方法来进行统一的设置</p><p>4、BeanPostProcessor的前置处理</p><p>​    对生成的bean对象进行前置的处理工作</p><p>5、检查是否是InitializingBean的子类来决定是否调用afterPropertiesSet方法</p><p>​    判断当前bean对象是否设置了InitializingBean接口，然后进行属性的设置等基本工作</p><p>6、检查是否配置有自定义的init-method方法</p><p>​    如果当前bean对象定义了初始化方法，那么在此处调用初始化方法</p><p>7、BeanPostProcessor后置处理</p><p>​    对生成的bean对象进行后置的处理工作</p><p>8、注册必要的Destruction相关回调接口</p><p>​    为了方便对象的销毁，在此处调用注销的回调接口，方便对象进行销毁操作</p><p>9、获取并使用bean对象</p><p>​    通过容器来获取对象并进行使用</p><p>10、是否实现DisposableBean接口</p><p>​    判断是否实现了DisposableBean接口，并调用具体的方法来进行对象的销毁工作</p><p>11、是否配置有自定义的destory方法</p><p>​    如果当前bean对象定义了销毁方法，那么在此处调用销毁方法</p><h1 id="spring支持的bean作用域有哪些？"><a href="#spring支持的bean作用域有哪些？" class="headerlink" title="spring支持的bean作用域有哪些？"></a>spring支持的bean作用域有哪些？</h1><p>① singleton</p><p>使用该属性定义Bean时，IOC容器仅创建一个Bean实例，IOC容器每次返回的是同一个Bean实例。</p><p>② prototype</p><p>使用该属性定义Bean时，IOC容器可以创建多个Bean实例，每次返回的都是一个新的实例。</p><p>③ request</p><p>该属性仅对HTTP请求产生作用，使用该属性定义Bean时，每次HTTP请求都会创建一个新的Bean，适用于WebApplicationContext环境。</p><p>④ session</p><p>该属性仅用于HTTP Session，同一个Session共享一个Bean实例。不同Session使用不同的实例。</p><p>⑤ global-session</p><p>该属性仅用于HTTP Session，同session作用域不同的是，所有的Session共享一个Bean实例。</p><h1 id="Spring框架中的单例Bean是线程安全的么？"><a href="#Spring框架中的单例Bean是线程安全的么？" class="headerlink" title="Spring框架中的单例Bean是线程安全的么？"></a>Spring框架中的单例Bean是线程安全的么？</h1><p>​        Spring中的Bean对象默认是单例的，框架并没有对bean进行多线程的封装处理</p><p>​        如果Bean是有状态的，那么就需要开发人员自己来保证线程安全的保证，最简单的办法就是改变bean的作用域把singleton改成prototype，这样每次请求bean对象就相当于是创建新的对象来保证线程的安全</p><p>​        有状态就是由数据存储的功能</p><p>​        无状态就是不会存储数据，你想一下，我们的controller，service和dao本身并不是线程安全的，只是调用里面的方法，而且多线程调用一个实例的方法，会在内存中复制遍历，这是自己线程的工作内存，是最安全的。</p><p>​        因此在进行使用的时候，不要在bean中声明任何有状态的实例变量或者类变量，如果必须如此，也推荐大家使用ThreadLocal把变量变成线程私有，如果bean的实例变量或者类变量需要在多个线程之间共享，那么就只能使用synchronized，lock，cas等这些实现线程同步的方法了。</p><h1 id="spring框架中使用了哪些设计模式及应用场景"><a href="#spring框架中使用了哪些设计模式及应用场景" class="headerlink" title="spring框架中使用了哪些设计模式及应用场景"></a>spring框架中使用了哪些设计模式及应用场景</h1><p>​        1.工厂模式，在各种BeanFactory以及ApplicationContext创建中都用到了</p><p>​        2.模版模式，在各种BeanFactory以及ApplicationContext实现中也都用到了</p><p>​        3.代理模式，Spring AOP 利用了 AspectJ AOP实现的! AspectJ AOP 的底层用了动态代理</p><p>​        4.策略模式，加载资源文件的方式，使用了不同的方法，比如：ClassPathResourece，FileSystemResource，ServletContextResource，UrlResource但他们都有共同的借口Resource；在Aop的实现中，采用了两种不同的方式，JDK动态代理和CGLIB代理</p><p>​        5.单例模式，比如在创建bean的时候。</p><p>​        6.观察者模式，spring中的ApplicationEvent，ApplicationListener,ApplicationEventPublisher</p><p>​        7.适配器模式，MethodBeforeAdviceAdapter,ThrowsAdviceAdapter,AfterReturningAdapter</p><p>​        8.装饰者模式，源码中类型带Wrapper或者Decorator的都是</p><h1 id="spring事务的实现方式原理是什么？"><a href="#spring事务的实现方式原理是什么？" class="headerlink" title="spring事务的实现方式原理是什么？"></a>spring事务的实现方式原理是什么？</h1><p>​        在使用Spring框架的时候，可以有两种事务的实现方式，一种是编程式事务，有用户自己通过代码来控制事务的处理逻辑，还有一种是声明式事务，通过@Transactional注解来实现。</p><p>​        其实事务的操作本来应该是由数据库来进行控制，但是为了方便用户进行业务逻辑的操作，spring对事务功能进行了扩展实现，一般我们很少会用编程式事务，更多的是通过添加@Transactional注解来进行实现，当添加此注解之后事务的自动功能就会关闭，有spring框架来帮助进行控制。</p><p>​        其实事务操作是AOP的一个核心体现，当一个方法添加@Transactional注解之后，spring会基于这个类生成一个代理对象，会将这个代理对象作为bean，当使用这个代理对象的方法的时候，如果有事务处理，那么会先把事务的自动提交给关系，然后去执行具体的业务逻辑，如果执行逻辑没有出现异常，那么代理逻辑就会直接提交，如果出现任何异常情况，那么直接进行回滚操作，当然用户可以控制对哪些异常进行回滚操作。</p><p>TransactionInterceptor</p><h1 id="spring事务的隔离级别有哪些？"><a href="#spring事务的隔离级别有哪些？" class="headerlink" title="spring事务的隔离级别有哪些？"></a>spring事务的隔离级别有哪些？</h1><p>​    spring中的事务隔离级别就是数据库的隔离级别，有以下几种：</p><p>​    read uncommitted</p><p>​    read committed</p><p>​    repeatable read</p><p>​    serializable</p><p>​    在进行配置的时候，如果数据库和spring代码中的隔离级别不同，那么以spring的配置为主。</p><h1 id="spring的事务传播机制是什么？"><a href="#spring的事务传播机制是什么？" class="headerlink" title="spring的事务传播机制是什么？"></a>spring的事务传播机制是什么？</h1><p>​        多个事务方法相互调用时，事务如何在这些方法之间进行传播,spring中提供了7中不同的传播特性，来保证事务的正常执行：</p><p>​        REQUIRED：默认的传播特性，如果当前没有事务，则新建一个事务，如果当前存在事务，则加入这个事务</p><p>​        SUPPORTS：当前存在事务，则加入当前事务，如果当前没有事务，则以非事务的方式执行</p><p>​        MANDATORY：当前存在事务，则加入当前事务，如果当前事务不存在，则抛出异常</p><p>​        REQUIRED_NEW：创建一个新事务，如果存在当前事务，则挂起改事务</p><p>​        NOT_SUPPORTED：以非事务方式执行，如果存在当前事务，则挂起当前事务</p><p>​        NEVER：不使用事务，如果当前事务存在，则抛出异常</p><p>​        NESTED：如果当前事务存在，则在嵌套事务中执行，否则REQUIRED的操作一样</p><p>​        NESTED和REQUIRED_NEW的区别：</p><p>​        REQUIRED_NEW是新建一个事务并且新开始的这个事务与原有事务无关，而NESTED则是当前存在事务时会开启一个嵌套事务，在NESTED情况下，父事务回滚时，子事务也会回滚，而REQUIRED_NEW情况下，原有事务回滚，不会影响新开启的事务</p><p>​        NESTED和REQUIRED的区别：</p><p>​        REQUIRED情况下，调用方存在事务时，则被调用方和调用方使用同一个事务，那么被调用方出现异常时，由于共用一个事务，所以无论是否catch异常，事务都会回滚，而在NESTED情况下，被调用方发生异常时，调用方可以catch其异常，这样只有子事务回滚，父事务不会回滚。</p><h1 id="spring事务什么时候会失效？"><a href="#spring事务什么时候会失效？" class="headerlink" title="spring事务什么时候会失效？"></a>spring事务什么时候会失效？</h1><p>​        1、bean对象没有被spring容器管理</p><p>​        2、方法的访问修饰符不是public</p><p>​        3、自身调用问题</p><p>​        4、数据源没有配置事务管理器</p><p>​        5、数据库不支持事务</p><p>​        6、异常被捕获</p><p>​        7、异常类型错误或者配置错误</p><h1 id="什么的是bean的自动装配，它有哪些方式？"><a href="#什么的是bean的自动装配，它有哪些方式？" class="headerlink" title="什么的是bean的自动装配，它有哪些方式？"></a>什么的是bean的自动装配，它有哪些方式？</h1><p>​        bean的自动装配指的是bean的属性值在进行注入的时候通过某种特定的规则和方式去容器中查找，并设置到具体的对象属性中，主要有五种方式：</p><p>​        no – 缺省情况下，自动配置是通过“ref”属性手动设定，在项目中最常用<br>​        byName – 根据属性名称自动装配。如果一个bean的名称和其他bean属性的名称是一样的，将会自装配它。<br>​        byType – 按数据类型自动装配，如果bean的数据类型是用其它bean属性的数据类型，兼容并自动装配它。<br>​        constructor – 在构造函数参数的byType方式。<br>​        autodetect – 如果找到默认的构造函数，使用“自动装配用构造”; 否则，使用“按类型自动装配”。</p><h1 id="spring、springmvc、springboot的区别是什么？"><a href="#spring、springmvc、springboot的区别是什么？" class="headerlink" title="spring、springmvc、springboot的区别是什么？"></a>spring、springmvc、springboot的区别是什么？</h1><p>​    spring和springMvc：</p><ol><li><p>spring是一个一站式的轻量级的java开发框架，核心是控制反转（IOC）和面向切面（AOP），针对于开发的WEB层(springMvc)、业务层(Ioc)、持久层(jdbcTemplate)等都提供了多种配置解决方案；</p></li><li><p>springMvc是spring基础之上的一个MVC框架，主要处理web开发的路径映射和视图渲染，属于spring框架中WEB层开发的一部分；</p></li></ol><p>  springMvc和springBoot：</p><p>  1、springMvc属于一个企业WEB开发的MVC框架，涵盖面包括前端视图开发、文件配置、后台接口逻辑开发等，XML、config等配置相对比较繁琐复杂；</p><p>  2、springBoot框架相对于springMvc框架来说，更专注于开发微服务后台接口，不开发前端视图，同时遵循默认优于配置，简化了插件配置流程，不需要配置xml，相对springmvc，大大简化了配置流程；</p><p>  总结：</p><p>  1、Spring 框架就像一个家族，有众多衍生产品例如 boot、security、jpa等等。但他们的基础都是Spring的ioc、aop等. ioc 提供了依赖注入的容器， aop解决了面向横切面编程，然后在此两者的基础上实现了其他延伸产品的高级功能；</p><p>  2、springMvc主要解决WEB开发的问题，是基于Servlet 的一个MVC框架，通过XML配置，统一开发前端视图和后端逻辑；</p><p>  3、由于Spring的配置非常复杂，各种XML、JavaConfig、servlet处理起来比较繁琐，为了简化开发者的使用，从而创造性地推出了springBoot框架，默认优于配置，简化了springMvc的配置流程；但区别于springMvc的是，springBoot专注于单体微服务接口开发，和前端解耦，虽然springBoot也可以做成springMvc前后台一起开发，但是这就有点不符合springBoot框架的初衷了；</p><h1 id="springmvc工作流程是什么？"><a href="#springmvc工作流程是什么？" class="headerlink" title="springmvc工作流程是什么？"></a>springmvc工作流程是什么？</h1><p>​        当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/springmvc%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg" alt="img"></p><p>1、DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。<br>2、HandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。<br>3、返回处理器执行链，根据url查找控制器，并且将解析后的信息传递给DispatcherServlet<br>4、HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。<br>5、执行handler找到具体的处理器<br>6、Controller将具体的执行信息返回给HandlerAdapter,如ModelAndView。<br>7、HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。<br>8、DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。<br>9、视图解析器将解析的逻辑视图名传给DispatcherServlet。<br>10、DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图，进行试图渲染<br>11、将响应数据返回给客户端</p><h1 id="springmvc的九大组件有哪些？"><a href="#springmvc的九大组件有哪些？" class="headerlink" title="springmvc的九大组件有哪些？"></a>springmvc的九大组件有哪些？</h1><p>1.HandlerMapping<br>根据request找到相应的处理器。因为Handler（Controller）有两种形式，一种是基于类的Handler，另一种是基于Method的Handler（也就是我们常用的）</p><p>2.HandlerAdapter<br>调用Handler的适配器。如果把Handler（Controller）当做工具的话，那么HandlerAdapter就相当于干活的工人</p><p>3.HandlerExceptionResolver<br>对异常的处理</p><p>4.ViewResolver<br>用来将String类型的视图名和Locale解析为View类型的视图</p><p>5.RequestToViewNameTranslator<br>有的Handler（Controller）处理完后没有设置返回类型，比如是void方法，这是就需要从request中获取viewName</p><p>6.LocaleResolver<br>从request中解析出Locale。Locale表示一个区域，比如zh-cn，对不同的区域的用户，显示不同的结果，这就是i18n（SpringMVC中有具体的拦截器LocaleChangeInterceptor）</p><p>7.ThemeResolver<br>主题解析，这种类似于我们手机更换主题，不同的UI，css等</p><p>8.MultipartResolver<br>处理上传请求，将普通的request封装成MultipartHttpServletRequest</p><p>9.FlashMapManager<br>用于管理FlashMap，FlashMap用于在redirect重定向中传递参数</p><h1 id="springboot自动配置原理是什么？"><a href="#springboot自动配置原理是什么？" class="headerlink" title="springboot自动配置原理是什么？"></a>springboot自动配置原理是什么？</h1><p>在之前的课程中我们讲解了springboot的启动过程，其实在面试过程中问的最多的可能是自动装配的原理，而自动装配是在启动过程中完成，只不过在刚开始的时候我们选择性的跳过了，下面详细讲解自动装配的过程。</p><p>1、在springboot的启动过程中，有一个步骤是创建上下文，如果不记得可以看下面的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">stopWatch.start();</span><br><span class="line">ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">configureHeadlessProperty();</span><br><span class="line">SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">listeners.starting();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</span><br><span class="line">ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">configureIgnoreBeanInfo(environment);</span><br><span class="line">Banner printedBanner = printBanner(environment);</span><br><span class="line">context = createApplicationContext();</span><br><span class="line">exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,</span><br><span class="line"><span class="keyword">new</span> Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">            <span class="comment">//此处完成自动装配的过程</span></span><br><span class="line">prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">refreshContext(context);</span><br><span class="line">afterRefresh(context, applicationArguments);</span><br><span class="line">stopWatch.stop();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line"><span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">&#125;</span><br><span class="line">listeners.started(context);</span><br><span class="line">callRunners(context, applicationArguments);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">listeners.running(context);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">handleRunFailure(context, ex, exceptionReporters, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、在prepareContext方法中查找load方法，一层一层向内点击，找到最终的load方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//prepareContext方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareContext</span><span class="params">(ConfigurableApplicationContext context, ConfigurableEnvironment environment,</span></span></span><br><span class="line"><span class="params"><span class="function">SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner)</span> </span>&#123;</span><br><span class="line">context.setEnvironment(environment);</span><br><span class="line">postProcessApplicationContext(context);</span><br><span class="line">applyInitializers(context);</span><br><span class="line">listeners.contextPrepared(context);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">logStartupInfo(context.getParent() == <span class="keyword">null</span>);</span><br><span class="line">logStartupProfileInfo(context);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Add boot specific singleton beans</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();</span><br><span class="line">beanFactory.registerSingleton(<span class="string">&quot;springApplicationArguments&quot;</span>, applicationArguments);</span><br><span class="line"><span class="keyword">if</span> (printedBanner != <span class="keyword">null</span>) &#123;</span><br><span class="line">beanFactory.registerSingleton(<span class="string">&quot;springBootBanner&quot;</span>, printedBanner);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> DefaultListableBeanFactory) &#123;</span><br><span class="line">((DefaultListableBeanFactory) beanFactory)</span><br><span class="line">.setAllowBeanDefinitionOverriding(<span class="keyword">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.lazyInitialization) &#123;</span><br><span class="line">context.addBeanFactoryPostProcessor(<span class="keyword">new</span> LazyInitializationBeanFactoryPostProcessor());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Load the sources</span></span><br><span class="line">Set&lt;Object&gt; sources = getAllSources();</span><br><span class="line">Assert.notEmpty(sources, <span class="string">&quot;Sources must not be empty&quot;</span>);</span><br><span class="line">        <span class="comment">//load方法完成该功能</span></span><br><span class="line">load(context, sources.toArray(<span class="keyword">new</span> Object[<span class="number">0</span>]));</span><br><span class="line">listeners.contextLoaded(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load beans into the application context.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context the context to load beans into</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sources the sources to load</span></span><br><span class="line"><span class="comment"> * 加载bean对象到context中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(ApplicationContext context, Object[] sources)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Loading source &quot;</span> + StringUtils.arrayToCommaDelimitedString(sources));</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//获取bean对象定义的加载器</span></span><br><span class="line">BeanDefinitionLoader loader = createBeanDefinitionLoader(getBeanDefinitionRegistry(context), sources);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.beanNameGenerator != <span class="keyword">null</span>) &#123;</span><br><span class="line">loader.setBeanNameGenerator(<span class="keyword">this</span>.beanNameGenerator);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.resourceLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">loader.setResourceLoader(<span class="keyword">this</span>.resourceLoader);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.environment != <span class="keyword">null</span>) &#123;</span><br><span class="line">loader.setEnvironment(<span class="keyword">this</span>.environment);</span><br><span class="line">&#125;</span><br><span class="line">loader.load();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load the sources into the reader.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the number of loaded beans</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Object source : <span class="keyword">this</span>.sources) &#123;</span><br><span class="line">count += load(source);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、实际执行load的是BeanDefinitionLoader中的load方法，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实际记载bean的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">load</span><span class="params">(Object source)</span> </span>&#123;</span><br><span class="line">Assert.notNull(source, <span class="string">&quot;Source must not be null&quot;</span>);</span><br><span class="line">       <span class="comment">//如果是class类型，启用注解类型</span></span><br><span class="line"><span class="keyword">if</span> (source <span class="keyword">instanceof</span> Class&lt;?&gt;) &#123;</span><br><span class="line"><span class="keyword">return</span> load((Class&lt;?&gt;) source);</span><br><span class="line">&#125;</span><br><span class="line">       <span class="comment">//如果是resource类型，启动xml解析</span></span><br><span class="line"><span class="keyword">if</span> (source <span class="keyword">instanceof</span> Resource) &#123;</span><br><span class="line"><span class="keyword">return</span> load((Resource) source);</span><br><span class="line">&#125;</span><br><span class="line">       <span class="comment">//如果是package类型，启用扫描包，例如@ComponentScan</span></span><br><span class="line"><span class="keyword">if</span> (source <span class="keyword">instanceof</span> Package) &#123;</span><br><span class="line"><span class="keyword">return</span> load((Package) source);</span><br><span class="line">&#125;</span><br><span class="line">       <span class="comment">//如果是字符串类型，直接加载</span></span><br><span class="line"><span class="keyword">if</span> (source <span class="keyword">instanceof</span> CharSequence) &#123;</span><br><span class="line"><span class="keyword">return</span> load((CharSequence) source);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Invalid source type &quot;</span> + source.getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、下面方法将用来判断是否资源的类型，是使用groovy加载还是使用注解的方式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">load</span><span class="params">(Class&lt;?&gt; source)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//判断使用groovy脚本</span></span><br><span class="line"><span class="keyword">if</span> (isGroovyPresent() &amp;&amp; GroovyBeanDefinitionSource.class.isAssignableFrom(source)) &#123;</span><br><span class="line"><span class="comment">// Any GroovyLoaders added in beans&#123;&#125; DSL can contribute beans here</span></span><br><span class="line">GroovyBeanDefinitionSource loader = BeanUtils.instantiateClass(source, GroovyBeanDefinitionSource.class);</span><br><span class="line">load(loader);</span><br><span class="line">&#125;</span><br><span class="line">       <span class="comment">//使用注解加载</span></span><br><span class="line"><span class="keyword">if</span> (isComponent(source)) &#123;</span><br><span class="line"><span class="keyword">this</span>.annotatedReader.register(source);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、下面方法判断启动类中是否包含@Component注解，但是会神奇的发现我们的启动类中并没有该注解，继续更进发现MergedAnnotations类传入了一个参数SearchStrategy.TYPE_HIERARCHY，会查找继承关系中是否包含这个注解，@SpringBootApplication–&gt;@SpringBootConfiguration–&gt;@Configuration–&gt;@Component,当找到@Component注解之后，会把该对象注册到AnnotatedBeanDefinitionReader对象中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isComponent</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// This has to be a bit of a guess. The only way to be sure that this type is</span></span><br><span class="line">   <span class="comment">// eligible is to make a bean definition out of it and try to instantiate it.</span></span><br><span class="line">   <span class="keyword">if</span> (MergedAnnotations.from(type, SearchStrategy.TYPE_HIERARCHY).isPresent(Component.class)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// Nested anonymous classes are not eligible for registration, nor are groovy</span></span><br><span class="line">   <span class="comment">// closures</span></span><br><span class="line">   <span class="keyword">return</span> !type.getName().matches(<span class="string">&quot;.*\\$_.*closure.*&quot;</span>) &amp;&amp; !type.isAnonymousClass()</span><br><span class="line">         &amp;&amp; type.getConstructors() != <span class="keyword">null</span> &amp;&amp; type.getConstructors().length != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register a bean from the given bean class, deriving its metadata from</span></span><br><span class="line"><span class="comment"> * class-declared annotations.</span></span><br><span class="line"><span class="comment"> * 从给定的bean class中注册一个bean对象，从注解中找到相关的元数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">doRegisterBean</span><span class="params">(Class&lt;T&gt; beanClass, <span class="meta">@Nullable</span> String name,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="meta">@Nullable</span> Class&lt;? extends Annotation&gt;[] qualifiers, <span class="meta">@Nullable</span> Supplier&lt;T&gt; supplier,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="meta">@Nullable</span> BeanDefinitionCustomizer[] customizers)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">AnnotatedGenericBeanDefinition abd = <span class="keyword">new</span> AnnotatedGenericBeanDefinition(beanClass);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abd.setInstanceSupplier(supplier);</span><br><span class="line">ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(abd);</span><br><span class="line">abd.setScope(scopeMetadata.getScopeName());</span><br><span class="line">String beanName = (name != <span class="keyword">null</span> ? name : <span class="keyword">this</span>.beanNameGenerator.generateBeanName(abd, <span class="keyword">this</span>.registry));</span><br><span class="line"></span><br><span class="line">AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);</span><br><span class="line"><span class="keyword">if</span> (qualifiers != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (Class&lt;? extends Annotation&gt; qualifier : qualifiers) &#123;</span><br><span class="line"><span class="keyword">if</span> (Primary.class == qualifier) &#123;</span><br><span class="line">abd.setPrimary(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Lazy.class == qualifier) &#123;</span><br><span class="line">abd.setLazyInit(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">abd.addQualifier(<span class="keyword">new</span> AutowireCandidateQualifier(qualifier));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (customizers != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (BeanDefinitionCustomizer customizer : customizers) &#123;</span><br><span class="line">customizer.customize(abd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(abd, beanName);</span><br><span class="line">definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register the given bean definition with the given bean factory.</span></span><br><span class="line"><span class="comment"> * 注册主类，如果有别名可以设置别名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register bean definition under primary name.</span></span><br><span class="line">String beanName = definitionHolder.getBeanName();</span><br><span class="line">registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register aliases for bean name, if any.</span></span><br><span class="line">String[] aliases = definitionHolder.getAliases();</span><br><span class="line"><span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">registry.registerAlias(beanName, alias);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@SpringBootApplication</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@Configuration</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Configuration &#123;&#125;</span><br></pre></td></tr></table></figure><p>当看完上述代码之后，只是完成了启动对象的注入，自动装配还没有开始，下面开始进入到自动装配。</p><p>6、自动装配入口，从刷新容器开始</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"><span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">prepareRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">                <span class="comment">// 此处是自动装配的入口</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>7、在invokeBeanFactoryPostProcessors方法中完成bean的实例化和执行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Instantiate and invoke all registered BeanFactoryPostProcessor beans,</span></span><br><span class="line"><span class="comment"> * respecting explicit order if given.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Must be called before singleton instantiation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//开始执行beanFactoryPostProcessor对应实现类,需要知道的是beanFactoryPostProcessor是spring的扩展接口，在刷新容器之前，该接口可以用来修改bean元数据信息</span></span><br><span class="line">PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span></span><br><span class="line"><span class="comment">// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory.getTempClassLoader() == <span class="keyword">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8、查看invokeBeanFactoryPostProcessors的具体执行方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span></span><br><span class="line">Set&lt;String&gt; processedBeans = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line">BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//开始遍历三个内部类，如果属于BeanDefinitionRegistryPostProcessor子类，加入到bean注册的集合，否则加入到regularPostProcessors</span></span><br><span class="line"><span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line"><span class="keyword">if</span> (postProcessor <span class="keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">BeanDefinitionRegistryPostProcessor registryProcessor =</span><br><span class="line">(BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line">registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">registryProcessors.add(registryProcessor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">regularPostProcessors.add(postProcessor);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line"><span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line"><span class="comment">// Separate between BeanDefinitionRegistryPostProcessors that implement</span></span><br><span class="line"><span class="comment">// PriorityOrdered, Ordered, and the rest.</span></span><br><span class="line">List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">           <span class="comment">//通过BeanDefinitionRegistryPostProcessor获取到对应的处理类“org.springframework.context.annotation.internalConfigurationAnnotationProcessor”，但是需要注意的是这个类在springboot中搜索不到，这个类的完全限定名在AnnotationConfigEmbeddedWebApplicationContext中，在进行初始化的时候会装配几个类，在创建AnnotatedBeanDefinitionReader对象的时候会将该类注册到bean对象中，此处可以看到internalConfigurationAnnotationProcessor为bean名称，容器中真正的类是ConfigurationClassPostProcessor</span></span><br><span class="line">String[] postProcessorNames =</span><br><span class="line">beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">           <span class="comment">//首先执行类型为PriorityOrdered的BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">           <span class="comment">//PriorityOrdered类型表明为优先执行</span></span><br><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"><span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">                   <span class="comment">//获取对应的bean</span></span><br><span class="line">currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                   <span class="comment">//用来存储已经执行过的BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">processedBeans.add(ppName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">           <span class="comment">//开始执行装配逻辑</span></span><br><span class="line">invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.</span></span><br><span class="line">           <span class="comment">//其次执行类型为Ordered的BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">           <span class="comment">//Ordered表明按顺序执行</span></span><br><span class="line">postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"><span class="keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">processedBeans.add(ppName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.</span></span><br><span class="line">           <span class="comment">//循环中执行类型不为PriorityOrdered，Ordered类型的BeanDefinitionRegistryPostProcessor</span></span><br><span class="line"><span class="keyword">boolean</span> reiterate = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">while</span> (reiterate) &#123;</span><br><span class="line">reiterate = <span class="keyword">false</span>;</span><br><span class="line">postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"><span class="keyword">if</span> (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">processedBeans.add(ppName);</span><br><span class="line">reiterate = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">currentRegistryProcessors.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now, invoke the postProcessBeanFactory callback of all processors handled so far.</span></span><br><span class="line">           <span class="comment">//执行父类方法，优先执行注册处理类</span></span><br><span class="line">invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br><span class="line">           <span class="comment">//执行有规则处理类</span></span><br><span class="line">invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Invoke factory processors registered with the context instance.</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line"><span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line">String[] postProcessorNames =</span><br><span class="line">beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,</span></span><br><span class="line"><span class="comment">// Ordered, and the rest.</span></span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"><span class="keyword">if</span> (processedBeans.contains(ppName)) &#123;</span><br><span class="line"><span class="comment">// skip - already processed in first phase above</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">orderedPostProcessorNames.add(ppName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span></span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line"><span class="keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">&#125;</span><br><span class="line">sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Finally, invoke all other BeanFactoryPostProcessors.</span></span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line"><span class="keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">&#125;</span><br><span class="line">invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clear cached merged bean definitions since the post-processors might have</span></span><br><span class="line"><span class="comment">// modified the original metadata, e.g. replacing placeholders in values...</span></span><br><span class="line">beanFactory.clearMetadataCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>9、开始执行自动配置逻辑（启动类指定的配置，非默认配置），可以通过debug的方式一层层向里进行查找，会发现最终会在ConfigurationClassParser类中，此类是所有配置类的解析类，所有的解析逻辑在parser.parse(candidates)中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; configCandidates)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (BeanDefinitionHolder holder : configCandidates) &#123;</span><br><span class="line">BeanDefinition bd = holder.getBeanDefinition();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//是否是注解类</span></span><br><span class="line"><span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) &#123;</span><br><span class="line">parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">parse(bd.getBeanClassName(), holder.getBeanName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line"><span class="string">&quot;Failed to parse configuration class [&quot;</span> + bd.getBeanClassName() + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//执行配置类</span></span><br><span class="line"><span class="keyword">this</span>.deferredImportSelectorHandler.process();</span><br><span class="line">&#125;</span><br><span class="line">-------------------</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(AnnotationMetadata metadata, String beanName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">processConfigurationClass(<span class="keyword">new</span> ConfigurationClass(metadata, beanName));</span><br><span class="line">&#125;</span><br><span class="line">-------------------</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processConfigurationClass</span><span class="params">(ConfigurationClass configClass)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ConfigurationClass existingClass = <span class="keyword">this</span>.configurationClasses.get(configClass);</span><br><span class="line"><span class="keyword">if</span> (existingClass != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (configClass.isImported()) &#123;</span><br><span class="line"><span class="keyword">if</span> (existingClass.isImported()) &#123;</span><br><span class="line">existingClass.mergeImportedBy(configClass);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Otherwise ignore new imported config class; existing non-imported class overrides it.</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Explicit bean definition found, probably replacing an import.</span></span><br><span class="line"><span class="comment">// Let&#x27;s remove the old one and go with the new one.</span></span><br><span class="line"><span class="keyword">this</span>.configurationClasses.remove(configClass);</span><br><span class="line"><span class="keyword">this</span>.knownSuperclasses.values().removeIf(configClass::equals);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Recursively process the configuration class and its superclass hierarchy.</span></span><br><span class="line">SourceClass sourceClass = asSourceClass(configClass);</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//循环处理bean,如果有父类，则处理父类，直至结束</span></span><br><span class="line">sourceClass = doProcessConfigurationClass(configClass, sourceClass);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (sourceClass != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.configurationClasses.put(configClass, configClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>10、继续跟进doProcessConfigurationClass方法，此方式是支持注解配置的核心逻辑</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Apply processing and build a complete &#123;<span class="doctag">@link</span> ConfigurationClass&#125; by reading the</span></span><br><span class="line"><span class="comment"> * annotations, members and methods from the source class. This method can be called</span></span><br><span class="line"><span class="comment"> * multiple times as relevant sources are discovered.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> configClass the configuration class being build</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceClass a source class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the superclass, or &#123;<span class="doctag">@code</span> null&#125; if none found or previously processed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SourceClass <span class="title">doProcessConfigurationClass</span><span class="params">(ConfigurationClass configClass, SourceClass sourceClass)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理内部类逻辑，由于传来的参数是启动类，并不包含内部类，所以跳过</span></span><br><span class="line"><span class="keyword">if</span> (configClass.getMetadata().isAnnotated(Component.class.getName())) &#123;</span><br><span class="line"><span class="comment">// Recursively process any member (nested) classes first</span></span><br><span class="line">processMemberClasses(configClass, sourceClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process any @PropertySource annotations</span></span><br><span class="line">        <span class="comment">//针对属性配置的解析</span></span><br><span class="line"><span class="keyword">for</span> (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">sourceClass.getMetadata(), PropertySources.class,</span><br><span class="line">org.springframework.context.annotation.PropertySource.class)) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.environment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">processPropertySource(propertySource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">logger.info(<span class="string">&quot;Ignoring @PropertySource annotation on [&quot;</span> + sourceClass.getMetadata().getClassName() +</span><br><span class="line"><span class="string">&quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process any @ComponentScan annotations</span></span><br><span class="line">        <span class="comment">// 这里是根据启动类@ComponentScan注解来扫描项目中的bean</span></span><br><span class="line">Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);</span><br><span class="line"><span class="keyword">if</span> (!componentScans.isEmpty() &amp;&amp;</span><br><span class="line">!<span class="keyword">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line">            </span><br><span class="line"><span class="keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class="line"><span class="comment">// The config class is annotated with @ComponentScan -&gt; perform the scan immediately</span></span><br><span class="line">                <span class="comment">//遍历项目中的bean，如果是注解定义的bean，则进一步解析</span></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class="line"><span class="keyword">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line"><span class="comment">// Check the set of scanned definitions for any further config classes and parse recursively if needed</span></span><br><span class="line"><span class="keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class="line">BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();</span><br><span class="line"><span class="keyword">if</span> (bdCand == <span class="keyword">null</span>) &#123;</span><br><span class="line">bdCand = holder.getBeanDefinition();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">                        <span class="comment">//递归解析，所有的bean,如果有注解，会进一步解析注解中包含的bean</span></span><br><span class="line">parse(bdCand.getBeanClassName(), holder.getBeanName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process any @Import annotations</span></span><br><span class="line">        <span class="comment">//递归解析，获取导入的配置类，很多情况下，导入的配置类中会同样包含导入类注解</span></span><br><span class="line">processImports(configClass, sourceClass, getImports(sourceClass), <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process any @ImportResource annotations</span></span><br><span class="line">        <span class="comment">//解析@ImportResource配置类</span></span><br><span class="line">AnnotationAttributes importResource =</span><br><span class="line">AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);</span><br><span class="line"><span class="keyword">if</span> (importResource != <span class="keyword">null</span>) &#123;</span><br><span class="line">String[] resources = importResource.getStringArray(<span class="string">&quot;locations&quot;</span>);</span><br><span class="line">Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(<span class="string">&quot;reader&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String resource : resources) &#123;</span><br><span class="line">String resolvedResource = <span class="keyword">this</span>.environment.resolveRequiredPlaceholders(resource);</span><br><span class="line">configClass.addImportedResource(resolvedResource, readerClass);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process individual @Bean methods</span></span><br><span class="line">        <span class="comment">//处理@Bean注解修饰的类</span></span><br><span class="line">Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);</span><br><span class="line"><span class="keyword">for</span> (MethodMetadata methodMetadata : beanMethods) &#123;</span><br><span class="line">configClass.addBeanMethod(<span class="keyword">new</span> BeanMethod(methodMetadata, configClass));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process default methods on interfaces</span></span><br><span class="line">        <span class="comment">// 处理接口中的默认方法</span></span><br><span class="line">processInterfaces(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process superclass, if any</span></span><br><span class="line">        <span class="comment">//如果该类有父类，则继续返回，上层方法判断不为空，则继续递归执行</span></span><br><span class="line"><span class="keyword">if</span> (sourceClass.getMetadata().hasSuperClass()) &#123;</span><br><span class="line">String superclass = sourceClass.getMetadata().getSuperClassName();</span><br><span class="line"><span class="keyword">if</span> (superclass != <span class="keyword">null</span> &amp;&amp; !superclass.startsWith(<span class="string">&quot;java&quot;</span>) &amp;&amp;</span><br><span class="line">!<span class="keyword">this</span>.knownSuperclasses.containsKey(superclass)) &#123;</span><br><span class="line"><span class="keyword">this</span>.knownSuperclasses.put(superclass, configClass);</span><br><span class="line"><span class="comment">// Superclass found, return its annotation metadata and recurse</span></span><br><span class="line"><span class="keyword">return</span> sourceClass.getSuperClass();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// No superclass -&gt; processing is complete</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>11、查看获取配置类的逻辑</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">processImports(configClass, sourceClass, getImports(sourceClass), <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns &#123;<span class="doctag">@code</span> <span class="doctag">@Import</span>&#125; class, considering all meta-annotations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Set&lt;SourceClass&gt; <span class="title">getImports</span><span class="params">(SourceClass sourceClass)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">Set&lt;SourceClass&gt; imports = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">Set&lt;SourceClass&gt; visited = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">collectImports(sourceClass, imports, visited);</span><br><span class="line"><span class="keyword">return</span> imports;</span><br><span class="line">&#125;</span><br><span class="line">------------------</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursively collect all declared &#123;<span class="doctag">@code</span> <span class="doctag">@Import</span>&#125; values. Unlike most</span></span><br><span class="line"><span class="comment"> * meta-annotations it is valid to have several &#123;<span class="doctag">@code</span> <span class="doctag">@Import</span>&#125;s declared with</span></span><br><span class="line"><span class="comment"> * different values; the usual process of returning values from the first</span></span><br><span class="line"><span class="comment"> * meta-annotation on a class is not sufficient.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;For example, it is common for a &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125; class to declare direct</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@Import</span>&#125;s in addition to meta-imports originating from an &#123;<span class="doctag">@code</span> <span class="doctag">@Enable</span>&#125;</span></span><br><span class="line"><span class="comment"> * annotation.</span></span><br><span class="line"><span class="comment"> * 看到所有的bean都以导入的方式被加载进去</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">collectImports</span><span class="params">(SourceClass sourceClass, Set&lt;SourceClass&gt; imports, Set&lt;SourceClass&gt; visited)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (visited.add(sourceClass)) &#123;</span><br><span class="line"><span class="keyword">for</span> (SourceClass annotation : sourceClass.getAnnotations()) &#123;</span><br><span class="line">String annName = annotation.getMetadata().getClassName();</span><br><span class="line"><span class="keyword">if</span> (!annName.equals(Import.class.getName())) &#123;</span><br><span class="line">collectImports(annotation, imports, visited);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), <span class="string">&quot;value&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>12、继续回到ConfigurationClassParser中的parse方法中的最后一行,继续跟进该方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.deferredImportSelectorHandler.process()</span><br><span class="line">-------------</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">List&lt;DeferredImportSelectorHolder&gt; deferredImports = <span class="keyword">this</span>.deferredImportSelectors;</span><br><span class="line"><span class="keyword">this</span>.deferredImportSelectors = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (deferredImports != <span class="keyword">null</span>) &#123;</span><br><span class="line">DeferredImportSelectorGroupingHandler handler = <span class="keyword">new</span> DeferredImportSelectorGroupingHandler();</span><br><span class="line">deferredImports.sort(DEFERRED_IMPORT_COMPARATOR);</span><br><span class="line">deferredImports.forEach(handler::register);</span><br><span class="line">handler.processGroupImports();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.deferredImportSelectors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">---------------</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processGroupImports</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (DeferredImportSelectorGrouping grouping : <span class="keyword">this</span>.groupings.values()) &#123;</span><br><span class="line">grouping.getImports().forEach(entry -&gt; &#123;</span><br><span class="line">ConfigurationClass configurationClass = <span class="keyword">this</span>.configurationClasses.get(</span><br><span class="line">entry.getMetadata());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">processImports(configurationClass, asSourceClass(configurationClass),</span><br><span class="line">asSourceClasses(entry.getImportClassName()), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line"><span class="string">&quot;Failed to process import candidates for configuration class [&quot;</span> +</span><br><span class="line">configurationClass.getMetadata().getClassName() + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">------------</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the imports defined by the group.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> each import with its associated configuration class</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Iterable&lt;Group.Entry&gt; getImports() &#123;</span><br><span class="line"><span class="keyword">for</span> (DeferredImportSelectorHolder deferredImport : <span class="keyword">this</span>.deferredImports) &#123;</span><br><span class="line"><span class="keyword">this</span>.group.process(deferredImport.getConfigurationClass().getMetadata(),</span><br><span class="line">deferredImport.getImportSelector());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.group.selectImports();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">------------</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DeferredImportSelector <span class="title">getImportSelector</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.importSelector;</span><br><span class="line">&#125;</span><br><span class="line">------------</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(AnnotationMetadata annotationMetadata, DeferredImportSelector deferredImportSelector)</span> </span>&#123;</span><br><span class="line">Assert.state(deferredImportSelector <span class="keyword">instanceof</span> AutoConfigurationImportSelector,</span><br><span class="line">() -&gt; String.format(<span class="string">&quot;Only %s implementations are supported, got %s&quot;</span>,</span><br><span class="line">AutoConfigurationImportSelector.class.getSimpleName(),</span><br><span class="line">deferredImportSelector.getClass().getName()));</span><br><span class="line">AutoConfigurationEntry autoConfigurationEntry = ((AutoConfigurationImportSelector) deferredImportSelector)</span><br><span class="line">.getAutoConfigurationEntry(getAutoConfigurationMetadata(), annotationMetadata);</span><br><span class="line"><span class="keyword">this</span>.autoConfigurationEntries.add(autoConfigurationEntry);</span><br><span class="line"><span class="keyword">for</span> (String importClassName : autoConfigurationEntry.getConfigurations()) &#123;</span><br><span class="line"><span class="keyword">this</span>.entries.putIfAbsent(importClassName, annotationMetadata);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="如何理解springboot中的starter？"><a href="#如何理解springboot中的starter？" class="headerlink" title="如何理解springboot中的starter？"></a>如何理解springboot中的starter？</h1><p>​        使用spring+springmvc框架进行开发的时候，如果需要引入mybatis框架，那么需要在xml中定义需要的bean对象，这个过程很明显是很麻烦的，如果需要引入额外的其他组件，那么也需要进行复杂的配置，因此在springboot中引入了starter</p><p>​        starter就是一个jar包，写一个@Configuration的配置类，将这些bean定义在其中，然后再starter包的META-INF/spring.factories中写入配置类，那么springboot程序在启动的时候就会按照约定来加载该配置类</p><p>​        开发人员只需要将相应的starter包依赖进应用中，进行相关的属性配置，就可以进行代码开发，而不需要单独进行bean对象的配置</p><h1 id="什么是嵌入式服务器，为什么使用嵌入式服务器？"><a href="#什么是嵌入式服务器，为什么使用嵌入式服务器？" class="headerlink" title="什么是嵌入式服务器，为什么使用嵌入式服务器？"></a>什么是嵌入式服务器，为什么使用嵌入式服务器？</h1><p>​        在springboot框架中，大家应该发现了有一个内嵌的tomcat，在之前的开发流程中，每次写好代码之后必须要将项目部署到一个额外的web服务器中，只有这样才可以运行，这个明显要麻烦很多，而使用springboot的时候，你会发现在启动项目的时候可以直接按照java应用程序的方式来启动项目，不需要额外的环境支持，也不需要tomcat服务器，这是因为在springboot框架中内置了tomcat.jar，来通过main方法启动容器，达到一键开发部署的方式，不需要额外的任何其他操作。</p><h1 id="mybatis的优缺点有哪些？"><a href="#mybatis的优缺点有哪些？" class="headerlink" title="mybatis的优缺点有哪些？"></a>mybatis的优缺点有哪些？</h1><p>1、Mybait的优点：</p><p>（1）简单易学，容易上手（相比于Hibernate）  基于SQL编程；<br>（2）JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接；<br>（3）很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持，而JDBC提供了可扩展性，所以只要这个数据库有针对Java的jar包就可以就可以与MyBatis兼容），开发人员不需要考虑数据库的差异性。<br>（4）提供了很多第三方插件（分页插件 / 逆向工程）；<br>（5）能够与Spring很好的集成；<br>（6）MyBatis相当灵活，不会对应用程序或者数据库的现有设计强加任何影响，SQL写在XML里，从程序代码中彻底分离，解除sql与程序代码的耦合，便于统一管理和优化，并可重用。<br>（7）提供XML标签，支持编写动态SQL语句。<br>（8）提供映射标签，支持对象与数据库的ORM字段关系映射。<br>（9）提供对象关系映射标签，支持对象关系组建维护。<br>2、MyBatis框架的缺点：</p><p>（1）SQL语句的编写工作量较大，尤其是字段多、关联表多时，更是如此，对开发人员编写SQL语句的功底有一定要求。<br>（2）SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</p><h1 id="mybatis和hibernate有什么区别？"><a href="#mybatis和hibernate有什么区别？" class="headerlink" title="mybatis和hibernate有什么区别？"></a>mybatis和hibernate有什么区别？</h1><p>Hibernate的优点：</p><p>1、hibernate是全自动，hibernate完全可以通过对象关系模型实现对数据库的操作，拥有完整的JavaBean对象与数据库的映射结构来自动生成sql。</p><p>2、功能强大，数据库无关性好，O/R映射能力强，需要写的代码很少，开发速度很快。</p><p>3、有更好的二级缓存机制，可以使用第三方缓存。</p><p>4、数据库移植性良好。</p><p>5、hibernate拥有完整的日志系统，hibernate日志系统非常健全，涉及广泛，包括sql记录、关系异常、优化警告、缓存提示、脏数据警告等</p><p>Hibernate的缺点：</p><p>1、学习门槛高，精通门槛更高，程序员如何设计O/R映射，在性能和对象模型之间如何取得平衡，以及怎样用好Hibernate方面需要的经验和能力都很强才行</p><p>2、hibernate的sql很多都是自动生成的，无法直接维护sql；虽然有hql查询，但功能还是不及sql强大，见到报表等变态需求时，hql查询要虚，也就是说hql查询是有局限的；hibernate虽然也支持原生sql查询，但开发模式上却与orm不同，需要转换思维，因此使用上有些不方便。总之写sql的灵活度上hibernate不及mybatis。</p><p>Mybatis的优点：</p><p>1、易于上手和掌握，提供了数据库查询的自动对象绑定功能，而且延续了很好的SQL使用经验，对于没有那么高的对象模型要求的项目来说，相当完美。</p><p>2、sql写在xml里，便于统一管理和优化， 解除sql与程序代码的耦合。</p><p>3、提供映射标签，支持对象与数据库的orm字段关系映射</p><p>4、 提供对象关系映射标签，支持对象关系组建维护</p><p>5、提供xml标签，支持编写动态sql。</p><p>6、速度相对于Hibernate的速度较快</p><p>Mybatis的缺点：</p><p>1、关联表多时，字段多的时候，sql工作量很大。</p><p>2、sql依赖于数据库，导致数据库移植性差。</p><p>3、由于xml里标签id必须唯一，导致DAO中方法不支持方法重载。</p><p>4、对象关系映射标签和字段映射标签仅仅是对映射关系的描述，具体实现仍然依赖于sql。</p><p>5、DAO层过于简单，对象组装的工作量较大。</p><p>6、不支持级联更新、级联删除。</p><p>7、Mybatis的日志除了基本记录功能外，其它功能薄弱很多。</p><p>8、编写动态sql时,不方便调试，尤其逻辑复杂时。</p><p>9、提供的写动态sql的xml标签功能简单，编写动态sql仍然受限，且可读性低。</p><h1 id="mybatis中-和-的区别是什么？"><a href="#mybatis中-和-的区别是什么？" class="headerlink" title="mybatis中#{}和${}的区别是什么？"></a>mybatis中#{}和${}的区别是什么？</h1><p>a、#{}是预编译处理，${}是字符串替换。<br>b、Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 的 set 方法来赋值；<br>c、Mybatis 在处理${}时，就是把${}替换成变量的值。<br>d、使用#{}可以有效的防止 SQL 注入，提高系统安全性</p><h1 id="简述一下mybatis插件运行原理及开发流程？"><a href="#简述一下mybatis插件运行原理及开发流程？" class="headerlink" title="简述一下mybatis插件运行原理及开发流程？"></a>简述一下mybatis插件运行原理及开发流程？</h1><p>mybatis只支持针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这四种接口的插件，mybatis使用jdk的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这四种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke方法，拦截那些你指定需要拦截的方法。</p><p>编写插件：实现Mybatis的Interceptor接口并复写intercept方法啊，然后给插件编写注解，指定要拦截哪一个接口的哪些方法，在配置文件中配置编写的插件即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Intercepts(&#123;@Signature(type = StatementHandler.class,method = &quot;parameterize&quot;,args = Statement.class)&#125;)</span></span><br></pre></td></tr></table></figure><p>索引的基本原理</p><p>1、为什么要有索引?<br>一般的应用系统，读写比例在10:1左右，而且插入操作和一般的更新操作很少出现性能问题，在生产环境中，我们遇到最多的，也是最容易出问题的，还是一些复杂的查询操作，因此对查询语句的优化显然是重中之重。说起加速查询，就不得不提到索引了。<br>2、什么是索引？<br>索引在MySQL中也叫是一种“键”，是存储引擎用于快速找到记录的一种数据结构。索引对于良好的性能<br>非常关键，尤其是当表中的数据量越来越大时，索引对于性能的影响愈发重要。<br>索引优化应该是对查询性能优化最有效的手段了。索引能够轻易将查询性能提高好几个数量级。<br>索引相当于字典的音序表，如果要查某个字，如果不使用音序表，则需要从几百页中逐页去查。    </p><p>3、索引的原理</p><p>索引的目的在于提高查询效率，与我们查阅图书所用的目录是一个道理：先定位到章，然后定位到该章下的一个小节，然后找到页数。相似的例子还有：查字典，查火车车次，飞机航班等</p><p>本质都是：通过不断地缩小想要获取数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是说，有了这种索引机制，我们可以总是用同一种查找方式来锁定数据。</p><p>数据库也是一样，但显然要复杂的多，因为不仅面临着等值查询，还有范围查询(&gt;、&lt;、between、in)、模糊查询(like)、并集查询(or)等等。数据库应该选择怎么样的方式来应对所有的问题呢？我们回想字典的例子，能不能把数据分成段，然后分段查询呢？最简单的如果1000条数据，1到100分成第一段，101到200分成第二段，201到300分成第三段…这样查第250条数据，只要找第三段就可以了，一下子去除了90%的无效数据。但如果是1千万的记录呢，分成几段比较好？按照搜索树的模型，其平均复杂度是lgN，具有不错的查询性能。但这里我们忽略了一个关键的问题，复杂度模型是基于每次相同的操作成本来考虑的。而数据库实现比较复杂，一方面数据是保存在磁盘上的，另外一方面为了提高性能，每次又可以把部分数据读入内存来计算，因为我们知道访问磁盘的成本大概是访问内存的十万倍左右，所以简单的搜索树难以满足复杂的应用场景。</p><p>4、索引的数据结构</p><p>MySQL主要用到两种结构：B+ Tree索引和Hash索引<br>Inodb存储引擎 默认是 B+Tree索引<br>Memory 存储引擎 默认 Hash索引；<br>MySQL中，只有Memory(Memory表只存在内存中，断电会消失，适用于临时表)存储引擎显示支持Hash索引，是Memory表的默认索引类型，尽管Memory表也可以使用B+Tree索引。Hash索引把数据以hash形式组织起来，因此当查找某一条记录的时候，速度非常快。但是因为hash结构，每个键只对应一个值，而且是散列的方式分布。所以它并不支持范围查找和排序等功能。<br>B+Tree是mysql使用最频繁的一个索引数据结构，是InnoDB和MyISAM存储引擎模式的索引类型。相对Hash索引，B+Tree在查找单条记录的速度比不上Hash索引，但是因为更适合排序等操作，所以它更受欢迎。毕竟不可能只对数据库进行单条记录的操作。<br>对比：<br>hash类型的索引：查询单条快，范围查询慢<br>btree类型的索引：b+树，层数越多，数据量指数级增长（我们就用它，因为innodb默认支持它）</p><h1 id="mysql聚簇和非聚簇索引的区别是什么？"><a href="#mysql聚簇和非聚簇索引的区别是什么？" class="headerlink" title="mysql聚簇和非聚簇索引的区别是什么？"></a>mysql聚簇和非聚簇索引的区别是什么？</h1><p>​        mysql的索引类型跟存储引擎是相关的，innodb存储引擎数据文件跟索引文件全部放在ibd文件中，而myisam的数据文件放在myd文件中，索引放在myi文件中，其实区分聚簇索引和非聚簇索引非常简单，只要判断数据跟索引是否存储在一起就可以了。</p><p>​        innodb存储引擎在进行数据插入的时候，数据必须要跟索引放在一起，如果有主键就使用主键，没有主键就使用唯一键，没有唯一键就使用6字节的rowid，因此跟数据绑定在一起的就是聚簇索引，而为了避免数据冗余存储，其他的索引的叶子节点中存储的都是聚簇索引的key值，因此innodb中既有聚簇索引也有非聚簇索引，而myisam中只有非聚簇索引。</p><h1 id="mysql索引结构有哪些，各自的优劣是什么？"><a href="#mysql索引结构有哪些，各自的优劣是什么？" class="headerlink" title="mysql索引结构有哪些，各自的优劣是什么？"></a>mysql索引结构有哪些，各自的优劣是什么？</h1><p>索引的数据结构和具体存储引擎的实现有关，mysql中使用较多的索引有hash索引，B+树索引，innodb的索引实现为B+树，memory存储引擎为hash索引。</p><p>B+树是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过1，而且同层级的二节点间有指针相关连接，在B+树上的常规检索，从根节点到叶子节点的搜索效率基本相当，不会出现大幅波动，而且基于索引的顺序扫描时，也可以利用双向指针快速左右移动，效率非常高。因为，B+树索引被广泛应用于数据库、文件系统等场景。</p><p>哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快。</p><p>如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值，前提是键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，知道找到对应的数据</p><p>如果是范围查询检索，这时候哈徐索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索</p><p>哈希所有也没办法利用索引完成排序，以及like这样的部分模糊查询</p><p>哈希索引也不支持多列联合索引的最左匹配规则</p><p>B+树索引的关键字检索效率比较平均，不像B树那样波动大，在有大量重复键值情况下，哈希索引的效率也是极低的，因此存在哈希碰撞问题。</p><h1 id="索引的设计原则有哪些？"><a href="#索引的设计原则有哪些？" class="headerlink" title="索引的设计原则有哪些？"></a>索引的设计原则有哪些？</h1><p>​        在进行索引设计的时候，应该保证索引字段占用的空间越小越好，这只是一个大的方向，还有一些细节点需要注意下：</p><p>​        1、适合索引的列是出现在where字句中的列，或者连接子句中指定的列</p><p>​        2、基数较小的表，索引效果差，没必要创建索引</p><p>​        3、在选择索引列的时候，越短越好，可以指定某些列的一部分，没必要用全部字段的值</p><p>​        4、不要给表中的每一个字段都创建索引，并不是索引越多越好</p><p>​        5、定义有外键的数据列一定要创建索引</p><p>​        6、更新频繁的字段不要有索引</p><p>​        7、创建索引的列不要过多，可以创建组合索引，但是组合索引的列的个数不建议太多</p><p>​        8、大文本、大对象不要创建索引</p><h1 id="mysql锁的类型有哪些？"><a href="#mysql锁的类型有哪些？" class="headerlink" title="mysql锁的类型有哪些？"></a>mysql锁的类型有哪些？</h1><p>基于锁的属性分类：共享锁、排他锁。</p><p>基于锁的粒度分类：行级锁（innodb ）、表级锁（ innodb 、myisam）、页级锁（ innodb引擎）、记录锁、间隙锁、临键锁。</p><p>基于锁的状态分类：意向共享锁、意向排它锁。 </p><p> 共享锁（share lock）： 共享锁又称读锁，简称 S 锁；当一个事务为数据加上读锁之后，其他事务只能对该数据加读锁，而不能对数据加写锁，直到所有的读锁释放之后其他事务才能对其进行加持写锁。共享锁的特性主要是为了支持并发的读取数据，读取数据的时候不支持修改，避免出现重复读的问题。</p><p> 排他锁（exclusive lock）：排他锁又称写锁，简称 X 锁；当一个事务为数据加上写锁时，其他请求将不能再为数据加任何锁，直到该锁释放之后，其他事务才能对数据进行加锁。排他锁的目的是在数据修改时候，不允许其他人同时修改，也不允许其他人读取，避免了出现脏数据和脏读的问题。</p><p>表锁（table lock）：表锁是指上锁的时候锁住的是整个表，当下一个事务访问该表的时候，必须等前一个事务释放了锁才能进行对表进行访问；特点：粒度大，加锁简单，容易冲突；</p><p>行锁：行锁是指上锁的时候锁住的是表的某一行或多行记录，其他事务访问同一张表时，只有被锁住的记录不能访问，其他的记录可正常访问，特点：粒度小，加锁比表锁麻烦，不容易冲突，相比表锁支持的并发要高</p><p>记录锁（Record lock）:记录锁也属于行锁中的一种，只不过记录锁的范围只是表中的某一条记录，记录锁是说事务在加锁后锁住的只是表的某一条记录，加了记录锁之后数据可以避免数据在查询的时候被修改的重复读问题，也避免了在修改的事务未提交前被其他事务读取的脏读问题</p><p>页锁：页级锁是 MysQL 中锁定粒度介于行级锁和表级锁中间的一种锁．表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。特点：开销和加锁时间界于表锁和行锁之间，会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</p><p>间隙锁：是属于行锁的一种，间隙锁是在事务加锁后其锁住的是表记录的某一个区间，当表的相邻ID之间出现空隙则会形成一个区间，遵循左开右闭原则。范围查询并且查询未命中记录，查询条件必须命中索引、间隙锁只会出现在REPEATABLE_READ（重复读）的事务级别中。</p><p>临键锁（Next-Key lock)：也属于行锁的一种，并且它是INNODB的行锁默认算法，总结来说它就是记录锁和间隙锁的组合，临键锁会把查询出来的记录锁住，同时也会把该范围查询内的所有间隙空间也会锁住，再之它会把相邻的下一个区间也会锁住。</p><h1 id="mysql执行计划怎么看？"><a href="#mysql执行计划怎么看？" class="headerlink" title="mysql执行计划怎么看？"></a>mysql执行计划怎么看？</h1><p>​       在企业的应用场景中，为了知道优化SQL语句的执行，需要查看SQL语句的具体执行过程，以加快SQL语句的执行效率。</p><p>​       可以使用explain+SQL语句来模拟优化器执行SQL查询语句，从而知道mysql是如何处理sql语句的。</p><p>​       官网地址： <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html">https://dev.mysql.com/doc/refman/5.7/en/explain-output.html</a> </p><p>1、执行计划中包含的信息</p><table><thead><tr><th>Column</th><th>Meaning</th></tr></thead><tbody><tr><td>id</td><td>The <code>SELECT</code> identifier</td></tr><tr><td>select_type</td><td>The <code>SELECT</code> type</td></tr><tr><td>table</td><td>The table for the output row</td></tr><tr><td>partitions</td><td>The matching partitions</td></tr><tr><td>type</td><td>The join type</td></tr><tr><td>possible_keys</td><td>The possible indexes to choose</td></tr><tr><td>key</td><td>The index actually chosen</td></tr><tr><td>key_len</td><td>The length of the chosen key</td></tr><tr><td>ref</td><td>The columns compared to the index</td></tr><tr><td>rows</td><td>Estimate of rows to be examined</td></tr><tr><td>filtered</td><td>Percentage of rows filtered by table condition</td></tr><tr><td>extra</td><td>Additional information</td></tr></tbody></table><p><strong>id</strong></p><p>select查询的序列号，包含一组数字，表示查询中执行select子句或者操作表的顺序</p><p>id号分为三种情况：</p><p>​        1、如果id相同，那么执行顺序从上到下</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp e <span class="keyword">join</span> dept d <span class="keyword">on</span> e.deptno <span class="operator">=</span> d.deptno <span class="keyword">join</span> salgrade sg <span class="keyword">on</span> e.sal <span class="keyword">between</span> sg.losal <span class="keyword">and</span> sg.hisal;</span><br></pre></td></tr></table></figure><p>​        2、如果id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp e <span class="keyword">where</span> e.deptno <span class="keyword">in</span> (<span class="keyword">select</span> d.deptno <span class="keyword">from</span> dept d <span class="keyword">where</span> d.dname <span class="operator">=</span> <span class="string">&#x27;SALES&#x27;</span>);</span><br></pre></td></tr></table></figure><p>​        3、id相同和不同的，同时存在：相同的可以认为是一组，从上往下顺序执行，在所有组中，id值越大，优先级越高，越先执行</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp e <span class="keyword">join</span> dept d <span class="keyword">on</span> e.deptno <span class="operator">=</span> d.deptno <span class="keyword">join</span> salgrade sg <span class="keyword">on</span> e.sal <span class="keyword">between</span> sg.losal <span class="keyword">and</span> sg.hisal <span class="keyword">where</span> e.deptno <span class="keyword">in</span> (<span class="keyword">select</span> d.deptno <span class="keyword">from</span> dept d <span class="keyword">where</span> d.dname <span class="operator">=</span> <span class="string">&#x27;SALES&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>select_type</strong></p><p>主要用来分辨查询的类型，是普通查询还是联合查询还是子查询</p><table><thead><tr><th><code>select_type</code> Value</th><th>Meaning</th></tr></thead><tbody><tr><td>SIMPLE</td><td>Simple SELECT (not using UNION or subqueries)</td></tr><tr><td>PRIMARY</td><td>Outermost SELECT</td></tr><tr><td>UNION</td><td>Second or later SELECT statement in a UNION</td></tr><tr><td>DEPENDENT UNION</td><td>Second or later SELECT statement in a UNION, dependent on outer query</td></tr><tr><td>UNION RESULT</td><td>Result of a UNION.</td></tr><tr><td>SUBQUERY</td><td>First SELECT in subquery</td></tr><tr><td>DEPENDENT SUBQUERY</td><td>First SELECT in subquery, dependent on outer query</td></tr><tr><td>DERIVED</td><td>Derived table</td></tr><tr><td>UNCACHEABLE SUBQUERY</td><td>A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query</td></tr><tr><td>UNCACHEABLE UNION</td><td>The second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY)</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--sample:简单的查询，不包含子查询和union</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">--primary:查询中若包含任何复杂的子查询，最外层查询则被标记为Primary</span></span><br><span class="line">explain <span class="keyword">select</span> staname,ename supname <span class="keyword">from</span> (<span class="keyword">select</span> ename staname,mgr <span class="keyword">from</span> emp) t <span class="keyword">join</span> emp <span class="keyword">on</span> t.mgr<span class="operator">=</span>emp.empno ;</span><br><span class="line"></span><br><span class="line"><span class="comment">--union:若第二个select出现在union之后，则被标记为union</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> deptno <span class="operator">=</span> <span class="number">10</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> sal <span class="operator">&gt;</span><span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--dependent union:跟union类似，此处的depentent表示union或union all联合而成的结果会受外部表影响</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp e <span class="keyword">where</span> e.empno  <span class="keyword">in</span> ( <span class="keyword">select</span> empno <span class="keyword">from</span> emp <span class="keyword">where</span> deptno <span class="operator">=</span> <span class="number">10</span> <span class="keyword">union</span> <span class="keyword">select</span> empno <span class="keyword">from</span> emp <span class="keyword">where</span> sal <span class="operator">&gt;</span><span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">--union result:从union表获取结果的select</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> deptno <span class="operator">=</span> <span class="number">10</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> sal <span class="operator">&gt;</span><span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--subquery:在select或者where列表中包含子查询</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> sal <span class="operator">&gt;</span> (<span class="keyword">select</span> <span class="built_in">avg</span>(sal) <span class="keyword">from</span> emp) ;</span><br><span class="line"></span><br><span class="line"><span class="comment">--dependent subquery:subquery的子查询要受到外部表查询的影响</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp e <span class="keyword">where</span> e.deptno <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">distinct</span> deptno <span class="keyword">from</span> dept);</span><br><span class="line"></span><br><span class="line"><span class="comment">--DERIVED: from子句中出现的子查询，也叫做派生类，</span></span><br><span class="line">explain <span class="keyword">select</span> staname,ename supname <span class="keyword">from</span> (<span class="keyword">select</span> ename staname,mgr <span class="keyword">from</span> emp) t <span class="keyword">join</span> emp <span class="keyword">on</span> t.mgr<span class="operator">=</span>emp.empno ;</span><br><span class="line"></span><br><span class="line"><span class="comment">--UNCACHEABLE SUBQUERY：表示使用子查询的结果不能被缓存</span></span><br><span class="line"> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> empno <span class="operator">=</span> (<span class="keyword">select</span> empno <span class="keyword">from</span> emp <span class="keyword">where</span> deptno<span class="operator">=</span>@<span class="variable">@sort</span>_buffer_size);</span><br><span class="line"> </span><br><span class="line"><span class="comment">--uncacheable union:表示union的查询结果不能被缓存：sql语句未验证</span></span><br></pre></td></tr></table></figure><p><strong>table</strong></p><p>对应行正在访问哪一个表，表名或者别名，可能是临时表或者union合并结果集<br>        1、如果是具体的表名，则表明从实际的物理表中获取数据，当然也可以是表的别名</p><p>​        2、表名是derivedN的形式，表示使用了id为N的查询产生的衍生表</p><p>​        3、当有union result的时候，表名是union n1,n2等的形式，n1,n2表示参与union的id</p><p><strong>type</strong></p><p>type显示的是访问类型，访问类型表示我是以何种方式去访问我们的数据，最容易想的是全表扫描，直接暴力的遍历一张表去寻找需要的数据，效率非常低下，访问的类型有很多，效率从最好到最坏依次是：</p><p>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL </p><p>一般情况下，得保证查询至少达到range级别，最好能达到ref</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--all:全表扫描，一般情况下出现这样的sql语句而且数据量比较大的话那么就需要进行优化。</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">--index：全索引扫描这个比all的效率要好，主要有两种情况，一种是当前的查询时覆盖索引，即我们需要的数据在索引中就可以索取，或者是使用了索引进行排序，这样就避免数据的重排序</span></span><br><span class="line">explain  <span class="keyword">select</span> empno <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">--range：表示利用索引查询的时候限制了范围，在指定范围内进行查询，这样避免了index的全索引扫描，适用的操作符： =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, BETWEEN, LIKE, or IN() </span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> empno <span class="keyword">between</span> <span class="number">7000</span> <span class="keyword">and</span> <span class="number">7500</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--index_subquery：利用索引来关联子查询，不再扫描全表</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> emp.job <span class="keyword">in</span> (<span class="keyword">select</span> job <span class="keyword">from</span> t_job);</span><br><span class="line"></span><br><span class="line"><span class="comment">--unique_subquery:该连接类型类似与index_subquery,使用的是唯一索引</span></span><br><span class="line"> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp e <span class="keyword">where</span> e.deptno <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">distinct</span> deptno <span class="keyword">from</span> dept);</span><br><span class="line"> </span><br><span class="line"><span class="comment">--index_merge：在查询过程中需要多个索引组合使用，没有模拟出来</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> rental <span class="keyword">where</span> rental_date <span class="keyword">like</span> <span class="string">&#x27;2005-05-26 07:12:2%&#x27;</span> <span class="keyword">and</span> inventory_id<span class="operator">=</span><span class="number">3926</span> <span class="keyword">and</span> customer_id<span class="operator">=</span><span class="number">321</span>\G</span><br><span class="line"></span><br><span class="line"><span class="comment">--ref_or_null：对于某个字段即需要关联条件，也需要null值的情况下，查询优化器会选择这种访问方式</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp e <span class="keyword">where</span>  e.mgr <span class="keyword">is</span> <span class="keyword">null</span> <span class="keyword">or</span> e.mgr<span class="operator">=</span><span class="number">7369</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--ref：使用了非唯一性索引进行数据的查找</span></span><br><span class="line"> <span class="keyword">create</span> index idx_3 <span class="keyword">on</span> emp(deptno);</span><br><span class="line"> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp e,dept d <span class="keyword">where</span> e.deptno <span class="operator">=</span>d.deptno;</span><br><span class="line"></span><br><span class="line"><span class="comment">--eq_ref ：使用唯一性索引进行数据查找</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp,emp2 <span class="keyword">where</span> emp.empno <span class="operator">=</span> emp2.empno;</span><br><span class="line"></span><br><span class="line"><span class="comment">--const：这个表至多有一个匹配行，</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> empno <span class="operator">=</span> <span class="number">7369</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">--system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现</span></span><br></pre></td></tr></table></figure><p> <strong>possible_keys</strong> </p><p>​        显示可能应用在这张表中的索引，一个或多个，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp,dept <span class="keyword">where</span> emp.deptno <span class="operator">=</span> dept.deptno <span class="keyword">and</span> emp.deptno <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>key</strong></p><p>​        实际使用的索引，如果为null，则没有使用索引，查询中若使用了覆盖索引，则该索引和查询的select字段重叠。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp,dept <span class="keyword">where</span> emp.deptno <span class="operator">=</span> dept.deptno <span class="keyword">and</span> emp.deptno <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>key_len</strong></p><p>表示索引中使用的字节数，可以通过key_len计算查询中使用的索引长度，在不损失精度的情况下长度越短越好。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp,dept <span class="keyword">where</span> emp.deptno <span class="operator">=</span> dept.deptno <span class="keyword">and</span> emp.deptno <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>ref</strong></p><p>显示索引的哪一列被使用了，如果可能的话，是一个常数</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp,dept <span class="keyword">where</span> emp.deptno <span class="operator">=</span> dept.deptno <span class="keyword">and</span> emp.deptno <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>rows</strong></p><p>根据表的统计信息及索引使用情况，大致估算出找出所需记录需要读取的行数，此参数很重要，直接反应的sql找了多少数据，在完成目的的情况下越少越好</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure><p><strong>extra</strong></p><p>包含额外的信息。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--using filesort:说明mysql无法利用索引进行排序，只能利用排序算法进行排序，会消耗额外的位置</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> sal;</span><br><span class="line"></span><br><span class="line"><span class="comment">--using temporary:建立临时表来保存中间结果，查询完成之后把临时表删除</span></span><br><span class="line">explain <span class="keyword">select</span> ename,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> emp <span class="keyword">where</span> deptno <span class="operator">=</span> <span class="number">10</span> <span class="keyword">group</span> <span class="keyword">by</span> ename;</span><br><span class="line"></span><br><span class="line"><span class="comment">--using index:这个表示当前的查询时覆盖索引的，直接从索引中读取数据，而不用访问数据表。如果同时出现using where 表名索引被用来执行索引键值的查找，如果没有，表面索引被用来读取数据，而不是真的查找</span></span><br><span class="line">explain <span class="keyword">select</span> deptno,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> deptno limit <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--using where:使用where进行条件过滤</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--using join buffer:使用连接缓存，情况没有模拟出来</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--impossible where：where语句的结果总是false</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> empno <span class="operator">=</span> <span class="number">7469</span>;</span><br></pre></td></tr></table></figure><h1 id="事务的基本特性是什么？"><a href="#事务的基本特性是什么？" class="headerlink" title="事务的基本特性是什么？"></a>事务的基本特性是什么？</h1><p>事务四大特征：原子性，一致性，隔离性和持久性。</p><ol><li>原子性（Atomicity）<br>一个原子事务要么完整执行，要么干脆不执行。这意味着，工作单元中的每项任务都必须正确执行。如果有任一任务执行失败，则整个工作单元或事务就会被终止。即此前对数据所作的任何修改都将被撤销。如果所有任务都被成功执行，事务就会被提交，即对数据所作的修改将会是永久性的。</li><li>一致性（Consistency）<br>一致性代表了底层数据存储的完整性。它必须由事务系统和应用开发人员共同来保证。事务系统通过保证事务的原子性，隔离性和持久性来满足这一要求; 应用开发人员则需要保证数据库有适当的约束(主键，引用完整性等)，并且工作单元中所实现的业务逻辑不会导致数据的不一致(即，数据预期所表达的现实业务情况不相一致)。例如，在一次转账过程中，从某一账户中扣除的金额必须与另一账户中存入的金额相等。支付宝账号100 你读到余额要取，有人向你转100 但是事物没提交（这时候你读到的余额应该是100，而不是200） 这种就是一致性</li><li>隔离性（Isolation）<br>隔离性意味着事务必须在不干扰其他进程或事务的前提下独立执行。换言之，在事务或工作单元执行完毕之前，其所访问的数据不能受系统其他部分的影响。</li><li>持久性（Durability）<br>持久性表示在某个事务的执行过程中，对数据所作的所有改动都必须在事务成功结束前保存至某种物理存储设备。这样可以保证，所作的修改在任何系统瘫痪时不至于丢失。</li></ol><h1 id="MySQL的隔离级别有哪些？"><a href="#MySQL的隔离级别有哪些？" class="headerlink" title="MySQL的隔离级别有哪些？"></a>MySQL的隔离级别有哪些？</h1><p>MySQL定义了四种隔离级别，包括一些具体规则，用于限定事务内外哪些改变是可见的，哪些改变是不可见的。低级别的隔离一般支持更高的并发处理，并且拥有更低的系统开销。<br>REPEATABLE READ 可重复读<br>MySQL数据库默认的隔离级别。该级别解决了READ UNCOMMITTED隔离级别导致的问题。它保证同一事务的多个实例在并发读取事务时，会“看到同样的”数据行。不过，这会导致另外一个棘手问题“幻读”。InnoDB和Falcon存储引擎通过多版本并发控制机制解决了幻读问题。<br>READ COMMITTED 读取提交内容<br>大多数数据库系统的默认隔离级别（但是不是MySQL的默认隔离级别），满足了隔离的早先简单定义：一个事务开始时，只能“看见”已经提交事务所做的改变，一个事务从开始到提交前，所做的任何数据改变都是不可见的，除非已经提交。这种隔离级别也支持所谓的“不可重复读”。这意味着用户运行同一个语句两次，看到的结果是不同的。<br>READ UNCOMMITTED 读取未提交内容<br>在这个隔离级别，所有事务都可以“看到”未提交事务的执行结果。在这种级别上，可能会产生很多问题，除非用户真的知道自己在做什么，并有很好的理由选择这样做。本隔离级别很少用于实际应用，因为它的性能也不必其他性能好多少，而别的级别还有其他更多的优点。读取未提交数据，也被称为“脏读”<br>SERIALIZABLE 可串行化<br>该级别是最高级别的隔离级。它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简而言之，SERIALIZABLE是在每个读的数据行上加锁。在这个级别，可能导致大量的超时Timeout和锁竞争Lock Contention现象，实际应用中很少使用到这个级别，但如果用户的应用为了数据的稳定性，需要强制减少并发的话，也可以选择这种隔离级。</p><ol><li>脏读</li></ol><p>脏读是指一个事务读取了未提交事务执行过程中的数据。<br>当一个事务的操作正在多次修改数据，而在事务还未提交的时候，另外一个并发事务来读取了数据，就会导致读取到的数据并非是最终持久化之后的数据，这个数据就是脏读的数据。</p><ol start="2"><li>不可重复读</li></ol><p>不可重复读是指对于数据库中的某个数据，一个事务执行过程中多次查询返回不同查询结果，这就是在事务执行过程中，数据被其他事务提交修改了。<br>不可重复读同脏读的区别在于，脏读是一个事务读取了另一未完成的事务执行过程中的数据，而不可重复读是一个事务执行过程中，另一事务提交并修改了当前事务正在读取的数据。</p><ol start="3"><li>虚读(幻读)</li></ol><p>幻读是事务非独立执行时发生的一种现象，例如事务T1批量对一个表中某一列列值为1的数据修改为2的变更，但是在这时，事务T2对这张表插入了一条列值为1的数据，并完成提交。此时，如果事务T1查看刚刚完成操作的数据，发现还有一条列值为1的数据没有进行修改，而这条数据其实是T2刚刚提交插入的，这就是幻读。<br>幻读和不可重复读都是读取了另一条已经提交的事务（这点同脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。</p><h1 id="怎么处理MySQL的慢查询？"><a href="#怎么处理MySQL的慢查询？" class="headerlink" title="怎么处理MySQL的慢查询？"></a>怎么处理MySQL的慢查询？</h1><p>1、开启慢查询日志，准确定位到哪个sql语句出现了问题</p><p>2、分析sql语句，看看是否load了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写</p><p>3、分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引</p><p>4、如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。</p><h1 id="ACID是靠什么保证的？"><a href="#ACID是靠什么保证的？" class="headerlink" title="ACID是靠什么保证的？"></a>ACID是靠什么保证的？</h1><p>原子性由undolog日志来保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql</p><p>一致性是由其他三大特性保证，程序代码要保证业务上的一致性</p><p>隔离性是由MVCC来保证</p><p>持久性由redolog来保证，mysql修改数据的时候会在redolog中记录一份日志数据，就算数据没有保存成功，只要日志保存成功了，数据仍然不会丢失</p><h1 id="什么是MVCC？"><a href="#什么是MVCC？" class="headerlink" title="什么是MVCC？"></a>什么是MVCC？</h1><p>1、MVCC</p><p>​        MVCC，全称Multi-Version Concurrency Control，即多版本并发控制。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。</p><pre><code>     MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理读写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读。</code></pre><p>2、当前读</p><p>​        像select lock in share mode(共享锁), select for update ; update, insert ,delete(排他锁)这些操作都是一种当前读，为什么叫当前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。</p><p>3、快照读（提高数据库的并发查询能力）</p><p>​        像不加锁的select操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即MVCC,可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本</p><p>4、当前读、快照读、MVCC关系</p><p>​        MVCC多版本并发控制指的是维持一个数据的多个版本，使得读写操作没有冲突，快照读是MySQL为实现MVCC的一个非阻塞读功能。MVCC模块在MySQL中的具体实现是由三个隐式字段，undo日志、read view三个组件来实现的。</p><h1 id="MVCC解决的问题是什么？"><a href="#MVCC解决的问题是什么？" class="headerlink" title="MVCC解决的问题是什么？"></a>MVCC解决的问题是什么？</h1><p>​        数据库并发场景有三种，分别为：</p><p>​        1、读读：不存在任何问题，也不需要并发控制</p><p>​        2、读写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读、幻读、不可重复读</p><p>​        3、写写：有线程安全问题，可能存在更新丢失问题</p><p>​        MVCC是一种用来解决读写冲突的无锁并发控制，也就是为事务分配单项增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照，所以MVCC可以为数据库解决一下问题：</p><p>​        1、在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能</p><p>​        2、解决脏读、幻读、不可重复读等事务隔离问题，但是不能解决更新丢失问题</p><h1 id="MVCC实现原理是什么？"><a href="#MVCC实现原理是什么？" class="headerlink" title="MVCC实现原理是什么？"></a>MVCC实现原理是什么？</h1><p>​        mvcc的实现原理主要依赖于记录中的三个隐藏字段，undolog，read view来实现的。</p><p>​        <strong>隐藏字段</strong></p><p>​        每行记录除了我们自定义的字段外，还有数据库隐式定义的DB_TRX_ID,DB_ROLL_PTR,DB_ROW_ID等字段</p><p>​        DB_TRX_ID</p><p>​        6字节，最近修改事务id，记录创建这条记录或者最后一次修改该记录的事务id</p><p>​        DB_ROLL_PTR</p><p>​        7字节，回滚指针，指向这条记录的上一个版本,用于配合undolog，指向上一个旧版本</p><p>​        DB_ROW_JD</p><p>​        6字节，隐藏的主键，如果数据表没有主键，那么innodb会自动生成一个6字节的row_id</p><p>​        记录如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/%E6%95%B0%E6%8D%AE%E6%A1%88%E4%BE%8B.png" alt="image-20210225233929554"></p><p>​        在上图中，DB_ROW_ID是数据库默认为该行记录生成的唯一隐式主键，DB_TRX_ID是当前操作该记录的事务ID，DB_ROLL_PTR是一个回滚指针，用于配合undo日志，指向上一个旧版本</p><p>​        <strong>undo log</strong></p><p>​        undolog被称之为回滚日志，表示在进行insert，delete，update操作的时候产生的方便回滚的日志</p><p>​        当进行insert操作的时候，产生的undolog只在事务回滚的时候需要，并且在事务提交之后可以被立刻丢弃</p><p>​        当进行update和delete操作的时候，产生的undolog不仅仅在事务回滚的时候需要，在快照读的时候也需要，所以不能随便删除，只有在快照读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除（当数据发生更新和删除操作的时候都只是设置一下老记录的deleted_bit，并不是真正的将过时的记录删除，因为为了节省磁盘空间，innodb有专门的purge线程来清除deleted_bit为true的记录，如果某个记录的deleted_id为true，并且DB_TRX_ID相对于purge线程的read view 可见，那么这条记录一定时可以被清除的）</p><p>​        <strong>下面我们来看一下undolog生成的记录链</strong></p><p>​        1、假设有一个事务编号为1的事务向表中插入一条记录，那么此时行数据的状态为：</p><p><img src="../../../%E7%89%9B%E5%AE%A2%E7%BD%91%E6%9C%80%E6%96%B0java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87MD%E8%AF%BE%E4%BB%B6/%E6%9C%80%E5%85%A8MD%E8%AF%B7%E7%9C%8B-200%E9%A2%98%E7%9B%AE%E5%92%8C%E7%AD%94%E6%A1%88%EF%BC%88xin%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F+%E5%BE%AE%E6%9C%8D%E5%8A%A1+MYSQL+Redis+JVM+Spring%E7%AD%89%E7%AD%89/images/1.png" alt="image-20210225235444975"></p><p>​        2、假设有第二个事务编号为2对该记录的name做出修改，改为lisi</p><p>​        在事务2修改该行记录数据时，数据库会对该行加排他锁</p><p>​        然后把该行数据拷贝到undolog中，作为 旧记录，即在undolog中有当前行的拷贝副本</p><p>​        拷贝完毕后，修改该行name为lisi，并且修改隐藏字段的事务id为当前事务2的id，回滚指针指向拷贝到undolog的副本记录中</p><p>​        事务提交后，释放锁</p><p><img src="../../../%E7%89%9B%E5%AE%A2%E7%BD%91%E6%9C%80%E6%96%B0java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87MD%E8%AF%BE%E4%BB%B6/%E6%9C%80%E5%85%A8MD%E8%AF%B7%E7%9C%8B-200%E9%A2%98%E7%9B%AE%E5%92%8C%E7%AD%94%E6%A1%88%EF%BC%88xin%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F+%E5%BE%AE%E6%9C%8D%E5%8A%A1+MYSQL+Redis+JVM+Spring%E7%AD%89%E7%AD%89/images/2.png" alt="image-20210313220450629"></p><p>​        3、假设有第三个事务编号为3对该记录的age做了修改，改为32</p><p>​        在事务3修改该行数据的时，数据库会对该行加排他锁</p><p>​        然后把该行数据拷贝到undolog中，作为旧纪录，发现该行记录已经有undolog了，那么最新的旧数据作为链表的表头，插在该行记录的undolog最前面</p><p>​        修改该行age为32岁，并且修改隐藏字段的事务id为当前事务3的id，回滚指针指向刚刚拷贝的undolog的副本记录</p><p>​        事务提交，释放锁</p><p><img src="../../../%E7%89%9B%E5%AE%A2%E7%BD%91%E6%9C%80%E6%96%B0java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87MD%E8%AF%BE%E4%BB%B6/%E6%9C%80%E5%85%A8MD%E8%AF%B7%E7%9C%8B-200%E9%A2%98%E7%9B%AE%E5%92%8C%E7%AD%94%E6%A1%88%EF%BC%88xin%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F+%E5%BE%AE%E6%9C%8D%E5%8A%A1+MYSQL+Redis+JVM+Spring%E7%AD%89%E7%AD%89/images/3.png" alt="image-20210313220337624"></p><p>​        从上述的一系列图中，大家可以发现，不同事务或者相同事务的对同一记录的修改，会导致该记录的undolog生成一条记录版本线性表，即链表，undolog的链首就是最新的旧记录，链尾就是最早的旧记录。</p><p>​        <strong>Read View</strong></p><p>​        上面的流程如果看明白了，那么大家需要再深入理解下read view的概念了。</p><p>​        Read View是事务进行快照读操作的时候生产的读视图，在该事务执行快照读的那一刻，会生成一个数据系统当前的快照，记录并维护系统当前活跃事务的id，事务的id值是递增的。</p><p>​        其实Read View的最大作用是用来做可见性判断的，也就是说当某个事务在执行快照读的时候，对该记录创建一个Read View的视图，把它当作条件去判断当前事务能够看到哪个版本的数据，有可能读取到的是最新的数据，也有可能读取的是当前行记录的undolog中某个版本的数据</p><p>​        Read View遵循的可见性算法主要是将要被修改的数据的最新记录中的DB_TRX_ID（当前事务id）取出来，与系统当前其他活跃事务的id去对比，如果DB_TRX_ID跟Read View的属性做了比较，不符合可见性，那么就通过DB_ROLL_PTR回滚指针去取出undolog中的DB_TRX_ID做比较，即遍历链表中的DB_TRX_ID，直到找到满足条件的DB_TRX_ID,这个DB_TRX_ID所在的旧记录就是当前事务能看到的最新老版本数据。</p><p>​        Read View的可见性规则如下所示：</p><p>​        首先要知道Read View中的三个全局属性：</p><p>​        trx_list:一个数值列表，用来维护Read View生成时刻系统正活跃的事务ID（1,2,3）</p><p>​        up_limit_id:记录trx_list列表中事务ID最小的ID（1）</p><p>​        low_limit_id:Read View生成时刻系统尚未分配的下一个事务ID，（4）</p><p>​        具体的比较规则如下：</p><p>​        1、首先比较DB_TRX_ID &lt; up_limit_id,如果小于，则当前事务能看到DB_TRX_ID所在的记录，如果大于等于进入下一个判断</p><p>​        2、接下来判断DB_TRX_ID &gt;= low_limit_id,如果大于等于则代表DB_TRX_ID所在的记录在Read View生成后才出现的，那么对于当前事务肯定不可见，如果小于，则进入下一步判断</p><p>​        3、判断DB_TRX_ID是否在活跃事务中，如果在，则代表在Read View生成时刻，这个事务还是活跃状态，还没有commit，修改的数据，当前事务也是看不到，如果不在，则说明这个事务在Read View生成之前就已经开始commit，那么修改的结果是能够看见的。</p><p>7、MVCC的整体处理流程</p><p>假设有四个事务同时在执行，如下图所示：</p><table><thead><tr><th>事务1</th><th>事务2</th><th>事务3</th><th>事务4</th></tr></thead><tbody><tr><td>事务开始</td><td>事务开始</td><td>事务开始</td><td>事务开始</td></tr><tr><td>……</td><td>……</td><td>……</td><td>修改且已提交</td></tr><tr><td>进行中</td><td>快照读</td><td>进行中</td><td></td></tr><tr><td>……</td><td>……</td><td>……</td><td></td></tr></tbody></table><p>从上述表格中，我们可以看到，当事务2对某行数据执行了快照读，数据库为该行数据生成一个Read View视图，可以看到事务1和事务3还在活跃状态，事务4在事务2快照读的前一刻提交了更新，所以，在Read View中记录了系统当前活跃事务1，3，维护在一个列表中。同时可以看到up_limit_id的值为1，而low_limit_id为5，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20210520143604440.png" alt="image-20210520143604440"></p><p>在上述的例子中，只有事务4修改过该行记录，并在事务2进行快照读前，就提交了事务，所以该行当前数据的undolog如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20210520143717928.png" alt="image-20210520143717928"></p><p>​        当事务2在快照读该行记录的是，会拿着该行记录的DB_TRX_ID去跟up_limit_id,lower_limit_id和活跃事务列表进行比较，判读事务2能看到该行记录的版本是哪个。</p><p>​        具体流程如下：先拿该行记录的事务ID（4）去跟Read View中的up_limit_id相比较，判断是否小于，通过对比发现不小于，所以不符合条件，继续判断4是否大于等于low_limit_id,通过比较发现也不大于，所以不符合条件，判断事务4是否处理trx_list列表中，发现不再次列表中，那么符合可见性条件，所以事务4修改后提交的最新结果对事务2 的快照是可见的，因此，事务2读取到的最新数据记录是事务4所提交的版本，而事务4提交的版本也是全局角度的最新版本。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20210520143742317.png" alt="image-20210520143742317"></p><p>当上述的内容都看明白了的话，那么大家就应该能够搞清楚这几个核心概念之间的关系了，下面我们讲一个不同的隔离级别下的快照读的不同。</p><p>8、RC、RR级别下的InnoDB快照读有什么不同</p><p>​        因为Read View生成时机的不同，从而造成RC、RR级别下快照读的结果的不同</p><p>​        1、在RR级别下的某个事务的对某条记录的第一次快照读会创建一个快照即Read View,将当前系统活跃的其他事务记录起来，此后在调用快照读的时候，还是使用的是同一个Read View,所以只要当前事务在其他事务提交更新之前使用过快照读，那么之后的快照读使用的都是同一个Read View,所以对之后的修改不可见</p><p>​        2、在RR级别下，快照读生成Read View时，Read View会记录此时所有其他活动和事务的快照，这些事务的修改对于当前事务都是不可见的，而早于Read View创建的事务所做的修改均是可见</p><p>​        3、在RC级别下，事务中，每次快照读都会新生成一个快照和Read View,这就是我们在RC级别下的事务中可以看到别的事务提交的更新的原因。</p><p>​        <strong>总结：在RC隔离级别下，是每个快照读都会生成并获取最新的Read View,而在RR隔离级别下，则是同一个事务中的第一个快照读才会创建Read View，之后的快照读获取的都是同一个Read View.</strong></p><h1 id="什么是mysql的主从复制？"><a href="#什么是mysql的主从复制？" class="headerlink" title="什么是mysql的主从复制？"></a>什么是mysql的主从复制？</h1><p>​        MySQL 主从复制是指数据可以从一个MySQL数据库服务器主节点复制到一个或多个从节点。MySQL 默认采用异步复制方式，这样从节点不用一直访问主服务器来更新自己的数据，数据的更新可以在远程连接上进行，从节点可以复制主数据库中的所有数据库或者特定的数据库，或者特定的表。</p><h1 id="mysql为什么需要主从同步？"><a href="#mysql为什么需要主从同步？" class="headerlink" title="mysql为什么需要主从同步？"></a>mysql为什么需要主从同步？</h1><p>1、在业务复杂的系统中，有这么一个情景，有一句sql语句需要锁表，导致暂时不能使用读的服务，那么就很影响运行中的业务，使用主从复制，让主库负责写，从库负责读，这样，即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作。</p><p>2、做数据的热备</p><p>3、架构的扩展。业务量越来越大，I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的频率，提高单个机器的I/O性能。</p><h1 id="mysql复制原理是什么？"><a href="#mysql复制原理是什么？" class="headerlink" title="mysql复制原理是什么？"></a>mysql复制原理是什么？</h1><p>​        （1）master服务器将数据的改变记录二进制binlog日志，当master上的数据发生改变时，则将其改变写入二进制日志中；        </p><p>​        （2）slave服务器会在一定时间间隔内对master二进制日志进行探测其是否发生改变，如果发生改变，则开始一个I/OThread请求master二进制事件</p><p>​        （3）同时主节点为每个I/O线程启动一个dump线程，用于向其发送二进制事件，并保存至从节点本地的中继日志中，从节点将启动SQL线程从中继日志中读取二进制日志，在本地重放，使得其数据和主节点的保持一致，最后I/OThread和SQLThread将进入睡眠状态，等待下一次被唤醒。</p><p>也就是说：</p><ul><li>从库会生成两个线程,一个I/O线程,一个SQL线程;</li><li>I/O线程会去请求主库的binlog,并将得到的binlog写到本地的relay-log(中继日志)文件中;</li><li>主库会生成一个log dump线程,用来给从库I/O线程传binlog;</li><li>SQL线程,会读取relay log文件中的日志,并解析成sql语句逐一执行;</li></ul><p>注意：</p><p>1–master将操作语句记录到binlog日志中，然后授予slave远程连接的权限（master一定要开启binlog二进制日志功能；通常为了数据安全考虑，slave也开启binlog功能）。<br>2–slave开启两个线程：IO线程和SQL线程。其中：IO线程负责读取master的binlog内容到中继日志relay log里；SQL线程负责从relay log日志里读出binlog内容，并更新到slave的数据库里，这样就能保证slave数据和master数据保持一致了。<br>3–Mysql复制至少需要两个Mysql的服务，当然Mysql服务可以分布在不同的服务器上，也可以在一台服务器上启动多个服务。<br>4–Mysql复制最好确保master和slave服务器上的Mysql版本相同（如果不能满足版本一致，那么要保证master主节点的版本低于slave从节点的版本）<br>5–master和slave两节点间时间需同步</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/%E4%B8%BB%E4%BB%8E%E5%8E%9F%E7%90%86.png"></p><p>具体步骤：</p><p>1、从库通过手工执行change  master to 语句连接主库，提供了连接的用户一切条件（user 、password、port、ip），并且让从库知道，二进制日志的起点位置（file名 position 号）；    start  slave</p><p>2、从库的IO线程和主库的dump线程建立连接。</p><p>3、从库根据change  master  to 语句提供的file名和position号，IO线程向主库发起binlog的请求。</p><p>4、主库dump线程根据从库的请求，将本地binlog以events的方式发给从库IO线程。</p><p>5、从库IO线程接收binlog  events，并存放到本地relay-log中，传送过来的信息，会记录到master.info中</p><p>6、从库SQL线程应用relay-log，并且把应用过的记录到relay-log.info中，默认情况下，已经应用过的relay 会自动被清理purge</p><h1 id="简述Myisam和Innodb的区别？"><a href="#简述Myisam和Innodb的区别？" class="headerlink" title="简述Myisam和Innodb的区别？"></a>简述Myisam和Innodb的区别？</h1><p>InnoDB存储引擎: 主要面向OLTP(Online Transaction Processing，在线事务处理)方面的应用，是第一个完整支持ACID事务的存储引擎(BDB第一个支持事务的存储引擎，已经停止开发)。<br>特点：</p><p>1 支持行锁<br>2 支持外键<br>3 支持自动增加列AUTO_INCREMENT属性<br>4 支持事务<br>5 支持MVCC模式的读写<br>6 读的效率低于MYISAM<br>7.写的效率高优于MYISAM<br>8.适合频繁修改以及设计到安全性较高的应用<br>9.清空整个表的时候，Innodb是一行一行的删除，</p><p>MyISAM存储引擎: 是MySQL官方提供的存储引擎，主要面向OLAP(Online Analytical Processing,在线分析处理)方面的应用。</p><p>特点：</p><p>1 独立于操作系统，当建立一个MyISAM存储引擎的表时，就会在本地磁盘建立三个文件，例如我建立tb_demo表，那么会生成以下三个文件tb_demo.frm,tb_demo.MYD,tb_demo.MYI<br>2 不支持事务，<br>3 支持表锁和全文索引<br>4 MyISAM存储引擎表由MYD和MYI组成，MYD用来存放数据文件，MYI用来存放索引文件。MySQL数据库只缓存其索引文件，数据文件的缓存交给操作系统本身来完成；<br>5 MySQL5.0版本开始，MyISAM默认支持256T的单表数据；<br>6.选择密集型的表：MYISAM存储引擎在筛选大量数据时非常迅速，这是他最突出的优点<br>7.读的效率优于InnoDB<br>8.写的效率低于InnoDB<br>9.适合查询以及插入为主的应用<br>10.清空整个表的时候，MYISAM则会新建表</p><h1 id="简述mysql中索引类型有哪些，以及对数据库的性能的影响？"><a href="#简述mysql中索引类型有哪些，以及对数据库的性能的影响？" class="headerlink" title="简述mysql中索引类型有哪些，以及对数据库的性能的影响？"></a>简述mysql中索引类型有哪些，以及对数据库的性能的影响？</h1><p>普通索引：允许被索引的数据列包含重复的值</p><p>唯一索引：可以保证数据记录的唯一性</p><p>主键索引：是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字primary key来创建</p><p>联合索引：索引可以覆盖多个数据列</p><p>全文索引：通过建立倒排索引，可以极大的提升检索效率，解决判断字段是否包含的问题，是目前搜索引擎使用的一种关键技术</p><p>索引可以极大地提高数据的查询速度</p><p>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能</p><p>但是会降低插入、删除、更新表的速度，因为在执行这些写操作的时候，还要操作索引文件</p><p>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要简历聚簇索引，那么需要的空间就会更大，如果非聚簇索引很多，一旦聚簇索引改变，那么所有非聚簇索引都会跟着变</p><h1 id="什么是字节码？"><a href="#什么是字节码？" class="headerlink" title="什么是字节码？"></a>什么是字节码？</h1><p>因为JVM针对各种操作系统和平台都进行了定制，无论在什么平台，都可以通过javac命令将一个.java文件编译成固定格式的字节码（.class文件）供JVM使用。之所以被称为字节码，是因为**.class文件是由十六进制值组成的，JVM以两个十六进制值为一组，就是以字节为单位进行读取**<br>格式如下<br><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/bytecode.png"></p><h1 id="字节码的组成结构是什么？"><a href="#字节码的组成结构是什么？" class="headerlink" title="字节码的组成结构是什么？"></a>字节码的组成结构是什么？</h1><p>JVM对字节码的规范是有要求的，要求每一个字节码文件都要有十部分固定的顺序组成，如下图：<br><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/bytecode2.png"></p><ol><li>魔数</li></ol><p>所有的.class文件的前4个字节都是魔数，魔数以一个固定值：0xCAFEBABE，放在文件的开头，JVM就可以根据这个文件的开头来判断这个文件是否可能是一个.class文件，如果是以这个开头，才会往后执行下面的操作，这个魔数的固定值是Java之父James Gosling指定的，意为CafeBabe（咖啡宝贝）</p><ol start="2"><li>版本号</li></ol><p>版本号是魔术之后的4个字节，前两个字节表示次版本号（Minor Version），后两个字节表示主版本号（Major Version），上面的0000 0032，次版本号0000转为十进制是0，主版本号0032 转为十进制50，对应下图的版本映射关系，可以看到对应的java版本号是1.6</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/bytecodeversion.png" alt="image.png"></p><ol start="3"><li>常量池</li></ol><p>紧接着主版本号之后的字节为常量池入口，常量池中有两类常量：字面量和符号引用，字面量是代码中申明为Final的常量值，符号引用是如类和接口的全局限定名、字段的名称和描述符、方法的名称和描述符。常量池整体分为两个部分：常量池计数器以及常量池数据区<br><img src="../../../%E7%89%9B%E5%AE%A2%E7%BD%91%E6%9C%80%E6%96%B0java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87MD%E8%AF%BE%E4%BB%B6/%E6%9C%80%E5%85%A8MD%E8%AF%B7%E7%9C%8B-200%E9%A2%98%E7%9B%AE%E5%92%8C%E7%AD%94%E6%A1%88%EF%BC%88xin%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F+%E5%BE%AE%E6%9C%8D%E5%8A%A1+MYSQL+Redis+JVM+Spring%E7%AD%89%E7%AD%89/images/changlangchi.png"></p><ol start="4"><li>访问标志</li></ol><p>常量池结束后的两个字节，描述的是类还是接口，以及是否被Public、Abstract、Final等修饰符修饰，JVM规范规定了9种访问标示（Access_Flag）JVM是通过按位或操作来描述所有的访问标示的，比如类的修饰符是Public Final，则对应的访问修饰符的值为ACC_PUBLIC | ACC_FINAL，即0x0001 | 0x0010=0x0011<br><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/access_flag.png"></p><ol start="5"><li>当前类索引</li></ol><p>访问标志后的两个字节，描述的是当前类的全限定名，这两个字节保存的值是常量池中的索引值，根据索引值就能在常量池中找到这个类的全限定名<br>​</p><ol start="6"><li>父类索引</li></ol><p>当前类名后的两个字节，描述的父类的全限定名，也是保存的常量池中的索引值</p><ol start="7"><li>接口索引</li></ol><p>父类名称后的两个字节，是接口计数器，描述了该类或者父类实现的接口数量，紧接着的n个字节是所有接口名称的字符串常量的索引值</p><ol start="8"><li>字段表</li></ol><p>用于描述类和接口中声明的变量，包含类级别的变量和实例变量，但是不包含方法内部声明的局部变量，字段表也分为两个部分，第一部分是两个字节，描述字段个数，第二部分是每个字段的详细信息fields_info<br><img src="../../../%E7%89%9B%E5%AE%A2%E7%BD%91%E6%9C%80%E6%96%B0java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87MD%E8%AF%BE%E4%BB%B6/%E6%9C%80%E5%85%A8MD%E8%AF%B7%E7%9C%8B-200%E9%A2%98%E7%9B%AE%E5%92%8C%E7%AD%94%E6%A1%88%EF%BC%88xin%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F+%E5%BE%AE%E6%9C%8D%E5%8A%A1+MYSQL+Redis+JVM+Spring%E7%AD%89%E7%AD%89/images/field.png"></p><ol start="9"><li>方法表</li></ol><p>字段表结束后为方法表，方法表也分为两个部分，第一个部分是两个字节表述方法的个数，第二部分是每个方法的详细信息<br>方法的访问信息比较复杂，包括方法的访问标志、方法名、方法的描述符和方法的属性：<br><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/method.png"></p><ol start="10"><li>附加属性</li></ol><p>字节码的最后一部分，该项存放了在该文件中类或接口所定义属性的基本信息。</p><h1 id="class初始化过程是什么？"><a href="#class初始化过程是什么？" class="headerlink" title="class初始化过程是什么？"></a>class初始化过程是什么？</h1><p>首先类加载的机制过程分为5个部分：加载、验证、准备、解析、初始化<br><img src="../../../%E7%89%9B%E5%AE%A2%E7%BD%91%E6%9C%80%E6%96%B0java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87MD%E8%AF%BE%E4%BB%B6/%E6%9C%80%E5%85%A8MD%E8%AF%B7%E7%9C%8B-200%E9%A2%98%E7%9B%AE%E5%92%8C%E7%AD%94%E6%A1%88%EF%BC%88xin%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F+%E5%BE%AE%E6%9C%8D%E5%8A%A1+MYSQL+Redis+JVM+Spring%E7%AD%89%E7%AD%89/images/class-int.png"></p><p>我们现在主要分析类的初始化过程：</p><ol><li>类的初始化阶段，是真正开始执行类中定义的java程序代码(字节码)并按程序员的意图去初始化类变量的过程。更直接地说，初始化阶段就是执行类构造器<clinit>()方法的过程。<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态代码块static{}中的语句合并产生的，其中编译器收集的顺序是由语句在源文件中出现的顺序所决定。</li><li>关于类初始化的顺序<strong>（静态变量、静态初始化块：决于它们在类中出现的先后顺序）&gt;（变量、初始化块：决于它们在类中出现的先后顺序）&gt;构造器</strong></li><li>关于类初始化的详细过程，参见 Java虚拟机规范一书中，其中类初始化过程如下：<ol><li>每个类都有一个初始化锁LC，进程获取LC，这个操作会导致当前线程一直等待，直到获取到LC锁</li><li>如果C正在被其他线程初始化，当前线程会释放LC进去阻塞状态，并等待C初始化完成。此时当前线程需要重试这一过程。执行初始化过程时，线程的中断状态不受影响</li><li>如果C正在被本线程初始化，即递归初始化，释放LC并且正常返回</li><li>如果C已经被初始化完成，释放LC并且正常返回</li><li>如果C处于错误状态，表明不可能再完成初始化，释放LC并抛出异常NoClassDefFoundError异常</li><li>否则，将C标记为正在被本线程初始化，释放LC；然后，初始化那些final且为基础类型的类成员变量</li><li>如果C是类而不是接口，且C的父类Super Class（SC）和各个接口SI_n（按照implements子句中的顺序来）还没有初始化，那么就在SC上面递归地进行完整的初始化过程，如果有必要，需要先验证和准备SC ；如果SC或SIn初始化过程中抛出异常，则获取LC，将C标记为错误状态，并通知所有正在等待的线程，然后释放LC，然后再抛出同样的异常。</li><li>从C的classloader处获取assertion断言机制是否被打开</li><li>接下来，按照文本顺序执行类变量初始化和静态代码块，或接口的字段初始化，把它们当作是一个个单独的代码块。</li><li>如果执行正常，那就获取LC，标记C对象为已初始化，并通知所有正在等待的线程，然后释放LC，正常退出整个过程</li><li>否则，如果抛出了异常E那么会中断退出。若E不是Error，则以E为参数创建新的异常ExceptionInInitializerError作为E。如果因为OutOfMemoryError导致无法创建ExceptionInInitializerError，则将OutOfMemoryError作为E。</li><li>获取LC，将C标记为错误状态，通知所有等待的线程，释放LC，并抛出异常E。</li></ol></li></ol><p>可以看到 JLS确实规定了父类先初始化、static块和类变量赋值按照文本顺序来</p><h1 id="JVM内存模型如何分配的？"><a href="#JVM内存模型如何分配的？" class="headerlink" title="JVM内存模型如何分配的？"></a>JVM内存模型如何分配的？</h1><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/javammode.png"></h2><h1 id="JVM性能调优的原则有哪些？"><a href="#JVM性能调优的原则有哪些？" class="headerlink" title="JVM性能调优的原则有哪些？"></a>JVM性能调优的原则有哪些？</h1><ol><li>多数的Java应用不需要在服务器上进行GC优化，虚拟机内部已有很多优化来保证应用的稳定运行，所以不要为了调优而调优，不当的调优可能适得其反</li><li>在应用上线之前，先考虑将机器的JVM参数设置到最优（适合）</li><li>在进行GC优化之前，需要确认项目的架构和代码等已经没有优化空间。我们不能指望一个系统架构有缺陷或者代码层次优化没有穷尽的应用，通过GC优化令其性能达到一个质的飞跃</li><li>GC优化是一个系统而复杂的工作，没有万能的调优策略可以满足所有的性能指标。GC优化必须建立在我们深入理解各种垃圾回收器的基础上，才能有事半功倍的效果</li><li>处理吞吐量和延迟问题时，垃圾处理器能使用的内存越大，即java堆空间越大垃圾收集效果越好，应用运行也越流畅。这称之为GC内存最大化原则</li><li>在这三个属性（吞吐量、延迟、内存）中选择其中两个进行jvm调优，称之为GC调优3选2</li></ol><h1 id="什么情况下需要JVM调优？"><a href="#什么情况下需要JVM调优？" class="headerlink" title="什么情况下需要JVM调优？"></a>什么情况下需要JVM调优？</h1><ul><li>Heap内存（老年代）持续上涨达到设置的最大内存值</li><li>Full GC 次数频繁</li><li>GC 停顿（Stop World）时间过长（超过1秒，具体值按应用场景而定）</li><li>应用出现OutOfMemory 等内存异常</li><li>应用出现OutOfDirectMemoryError等内存异常（ failed to allocate 16777216 byte(s) of direct memory (used: 1056964615, max: 1073741824)）</li><li>应用中有使用本地缓存且占用大量内存空间</li><li>系统吞吐量与响应性能不高或下降</li><li>应用的CPU占用过高不下或内存占用过高不下</li></ul><h1 id="在JVM调优时，你关注哪些指标？"><a href="#在JVM调优时，你关注哪些指标？" class="headerlink" title="在JVM调优时，你关注哪些指标？"></a>在JVM调优时，你关注哪些指标？</h1><ol><li><strong>吞吐量：</strong>用户代码时间 / （用户代码执行时间 + 垃圾回收时间）。是评价垃圾收集器能力的重要指标之一，是不考虑垃圾收集引起的停顿时间或内存消耗，垃圾收集器能支撑应用程序达到的最高性能指标。吞吐量越高算法越好。</li><li><strong>低延迟：</strong>STW越短，响应时间越好。评价垃圾收集器能力的重要指标，度量标准是缩短由于垃圾收集引起的停顿时间或完全消除因垃圾收集所引起的停顿，避免应用程序运行时发生抖动。暂停时间越短算法越好</li><li>在设计（或使用）GC 算法时，我们必须确定我们的目标：一个 GC 算法只可能针对两个目标之一（即只专注于最大吞吐量或最小暂停时间），或尝试找到一个二者的折衷</li><li>MinorGC尽可能多的收集垃圾对象。我们把这个称作MinorGC原则，遵守这一原则可以降低应用程序FullGC 的发生频率。FullGC 较耗时，是应用程序无法达到延迟要求或吞吐量的罪魁祸首</li><li>堆大小调整的着手点、分析点：<ol><li>统计Minor GC 持续时间</li><li>统计Minor GC 的次数</li><li>统计Full GC的最长持续时间</li><li>统计最差情况下Full GC频率</li><li>统计GC持续时间和频率对优化堆的大小是主要着手点</li><li>我们按照业务系统对延迟和吞吐量的需求，在按照这些分析我们可以进行各个区大小的调整</li></ol></li><li>一般来说吞吐量优先的垃圾回收器：-XX:+UseParallelGC  -XX:+UseParallelOldGC，即常规的（PS/PO）</li><li>响应时间优先的垃圾回收器：CMS、G1</li></ol><h1 id="JVM常用参数有哪些？"><a href="#JVM常用参数有哪些？" class="headerlink" title="JVM常用参数有哪些？"></a>JVM常用参数有哪些？</h1><ol><li><strong>Xms</strong> 是指设定程序启动时占用内存大小。一般来讲，大点，程序会启动的快一点，但是也可能会导致机器暂时间变慢</li><li><strong>Xmx</strong> 是指设定程序运行期间最大可占用的内存大小。如果程序运行需要占用更多的内存，超出了这个设置值，就会抛出OutOfMemory异常</li><li><strong>Xss</strong> 是指设定每个线程的堆栈大小。这个就要依据你的程序，看一个线程大约需要占用多少内存，可能会有多少线程同时运行等</li><li>**-Xmn、-XX:NewSize/-XX:MaxNewSize、-XX:NewRatio **<ol><li>高优先级：-XX:NewSize/-XX:MaxNewSize </li><li>中优先级：-Xmn（默认等效 -Xmn=-XX:NewSize=-XX:MaxNewSize=?） </li><li>低优先级：-XX:NewRatio </li></ol></li><li>如果想在日志中追踪类加载与类卸载的情况，可以使用启动参数  **-XX:TraceClassLoading -XX:TraceClassUnloading **</li></ol><h1 id="JVM常用性能调优工具有哪些？"><a href="#JVM常用性能调优工具有哪些？" class="headerlink" title="JVM常用性能调优工具有哪些？"></a>JVM常用性能调优工具有哪些？</h1><ol><li><p>MAT</p><ol><li>提示可能的内存泄露的点</li><li></li></ol></li><li><p>jvisualvm</p></li><li><p>jconsole</p></li><li><p>Arthas</p></li><li><p>show-busy-java-threads</p><ol><li><a href="https://github.com/oldratlee/useful-scripts/blob/master/docs/java.md#-show-busy-java-threads">https://github.com/oldratlee/useful-scripts/blob/master/docs/java.md#-show-busy-java-threads</a>​<h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4></li></ol></li></ol><h1 id="线上排查问题的一般流程是怎么样的？"><a href="#线上排查问题的一般流程是怎么样的？" class="headerlink" title="线上排查问题的一般流程是怎么样的？"></a>线上排查问题的一般流程是怎么样的？</h1><ol><li>CPU占用过高排查流程<ol><li>利用 top 命令可以查出占 CPU 最高的的进程pid ，如果pid为 9876</li><li>然后查看该进程下占用最高的线程id【top -Hp 9876】</li><li>假设占用率最高的线程 ID 为 6900，将其转换为 16 进制形式 (因为 java native 线程以 16 进制形式输出) 【printf ‘%x\n’ 6900】</li><li>利用 jstack 打印出 java 线程调用栈信息【jstack 9876 | grep ‘0x1af4’ -A 50 –color】，这样就可以更好定位问题</li></ol></li><li>内存占用过高排查流程<ol><li>查找进程id: 【top -d 2 -c】</li><li>查看JVM堆内存分配情况：jmap -heap pid</li><li>查看占用内存比较多的对象 jmap -histo pid | head -n 100</li><li>查看占用内存比较多的存活对象 jmap -histo:live pid | head -n 100</li></ol></li></ol><h1 id="什么情况下，会抛出OOM呢？"><a href="#什么情况下，会抛出OOM呢？" class="headerlink" title="什么情况下，会抛出OOM呢？"></a><strong>什么情况下，会抛出OOM呢？</strong></h1><ul><li>JVM98%的时间都花费在内存回收</li><li>每次回收的内存小于2%</li></ul><p>满足这两个条件将触发OutOfMemoryException，这将会留给系统一个微小的间隙以做一些Down之前的操作，比如手动打印Heap Dump。并不是内存被耗空的时候才抛出<br><strong>​</strong></p><h1 id="系统OOM之前都有哪些现象？"><a href="#系统OOM之前都有哪些现象？" class="headerlink" title="系统OOM之前都有哪些现象？"></a><strong>系统OOM之前都有哪些现象？</strong></h1><ul><li>每次垃圾回收的时间越来越长，由之前的10ms延长到50ms左右，FullGC的时间也有之前的0.5s延长到4、5s</li><li>FullGC的次数越来越多，最频繁时隔不到1分钟就进行一次FullGC</li><li>老年代的内存越来越大并且每次FullGC后，老年代只有少量的内存被释放掉</li></ul><h1 id="如何进行堆Dump文件分析？"><a href="#如何进行堆Dump文件分析？" class="headerlink" title="如何进行堆Dump文件分析？"></a>如何进行堆Dump文件分析？</h1><p>可以通过指定启动参数 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/app/data/dump/heapdump.hpro 在发生OOM的时候自动导出Dump文件<br>​</p><h1 id="如何进行GC日志分析？"><a href="#如何进行GC日志分析？" class="headerlink" title="如何进行GC日志分析？"></a>如何进行GC日志分析？</h1><p>为了方便分析GC日志信息，可以指定启动参数 【-Xloggc: app-gc.log  -XX:+PrintGCDetails -XX:+PrintGCDateStamps】,方便详细地查看GC日志信息</p><ol><li>使用 【jinfo pid】查看当前JVM堆的相关参数</li><li>继续使用 【jstat -gcutil 2315 1s 10】查看10s内当前堆的占用情况</li><li>也可以使用【jmap -heap pid】查看当前JVM堆的情况</li><li>我们可以继续使用 【jmap -F -histo pid | head -n 20】，查看前20行打印，即查看当前top20的大对象，一般从这里可以发现一些异常的大对象，如果没有，那么可以继续排名前50的大对象，分析</li><li>最后使用【jmap -F -dump:file=a.bin pid】，如果dump文件很大，可以压缩一下【tar -czvf a.tar.gz a.bin】</li><li>再之后，就是对dump文件进行分析了，使用MAT分析内存泄露</li><li>参考案例： <a href="https://www.lagou.com/lgeduarticle/142372.html">https://www.lagou.com/lgeduarticle/142372.html</a></li></ol><h1 id="线上死锁是如何排查的？"><a href="#线上死锁是如何排查的？" class="headerlink" title="线上死锁是如何排查的？"></a>线上死锁是如何排查的？</h1><ol><li>jps 查找一个可能有问题的<strong>进程id</strong></li><li>然后执行 【jstack -F <strong>进程id</strong>】</li><li>如果环境允许远程连接JVM，可以使用jconsole或者jvisualvm，图形化界面检测是否存在死锁</li></ol><h1 id="线上YGC耗时过长优化方案有哪些？"><a href="#线上YGC耗时过长优化方案有哪些？" class="headerlink" title="线上YGC耗时过长优化方案有哪些？"></a>线上YGC耗时过长优化方案有哪些？</h1><ol><li>如果生命周期过长的对象越来越多（比如全局变量或者静态变量等），会导致标注和复制过程的耗时增加</li><li>对存活对象标注时间过长：比如重载了Object类的Finalize方法，导致标注Final Reference耗时过长；或者String.intern方法使用不当，导致YGC扫描StringTable时间过长。可以通过以下参数显示GC处理Reference的耗时-XX:+PrintReferenceGC</li><li>长周期对象积累过多：比如本地缓存使用不当，积累了太多存活对象；或者锁竞争严重导致线程阻塞，局部变量的生命周期变长</li><li>案例参考： <a href="https://my.oschina.net/lishangzhi/blog/4703942">https://my.oschina.net/lishangzhi/blog/4703942</a></li></ol><h1 id="线上频繁FullGC优化方案有哪些？"><a href="#线上频繁FullGC优化方案有哪些？" class="headerlink" title="线上频繁FullGC优化方案有哪些？"></a>线上频繁FullGC优化方案有哪些？</h1><ol><li>线上频繁FullGC一般会有这么几个特征：<ol><li>线上多个线程的CPU都超过了100%，通过jstack命令可以看到这些线程主要是垃圾回收线程</li><li>通过jstat命令监控GC情况，可以看到Full GC次数非常多，并且次数在不断增加</li></ol></li><li>排查流程：<ol><li>top找到cpu占用最高的一个 <strong>进程id</strong></li><li>然后 【top -Hp 进程id】，找到cpu占用最高的 <strong>线程id</strong></li><li>【printf “%x\n” <strong>线程id 】</strong>，假设16进制结果为 a</li><li>jstack 线程id | grep ‘0xa’ -A 50 –color</li><li>如果是正常的用户线程， 则通过该线程的堆栈信息查看其具体是在哪处用户代码处运行比较消耗CPU</li><li>如果该线程是 VMThread，则通过 jstat-gcutil命令监控当前系统的GC状况，然后通过 jmapdump:format=b,file=导出系统当前的内存数据。导出之后将内存情况放到eclipse的mat工具中进行分析即可得出内存中主要是什么对象比较消耗内存，进而可以处理相关代码；正常情况下会发现VM Thread指的就是垃圾回收的线程</li><li>再执行【jstat -gcutil  **进程id】, **看到结果，如果FGC的数量很高，且在不断增长，那么可以定位是由于内存溢出导致FullGC频繁，系统缓慢</li><li>然后就可以Dump出内存日志，然后使用MAT的工具分析哪些对象占用内存较大，然后找到对象的创建位置，处理即可</li></ol></li><li>参考案例：<a href="https://mp.weixin.qq.com/s/g8KJhOtiBHWb6wNFrCcLVg">https://mp.weixin.qq.com/s/g8KJhOtiBHWb6wNFrCcLVg</a><h4 id="-2"><a href="#-2" class="headerlink" title=""></a></h4></li></ol><h1 id="如何进行线上堆外内存泄漏的分析？（Netty尤其居多）"><a href="#如何进行线上堆外内存泄漏的分析？（Netty尤其居多）" class="headerlink" title="如何进行线上堆外内存泄漏的分析？（Netty尤其居多）"></a>如何进行线上堆外内存泄漏的分析？（Netty尤其居多）</h1><ol><li>JVM的堆外内存泄露的定位一直是个比较棘手的问题</li><li>对外内存的泄漏分析一般都是先从堆内内存分析的过程中衍生出来的。有可能我们分析堆内内存泄露过程中发现，我们计算出来的JVM堆内存竟然大于了整个JVM的<strong>Xmx</strong>的大小，那说明多出来的是堆外内存</li><li>如果使用了 Netty 堆外内存，那么可以自行监控堆外内存的使用情况，不需要借助第三方工具，我们是使用的“反射”拿到的堆外内存的情况</li><li>逐渐缩小范围，直到 Bug 被找到。当我们确认某个线程的执行带来 Bug 时，可单步执行，可二分执行，定位到某行代码之后，跟到这段代码，然后继续单步执行或者二分的方式来定位最终出 Bug 的代码。这个方法屡试不爽，最后总能找到想要的 Bug</li><li>熟练掌握 idea 的调试，让我们的“捉虫”速度快如闪电（“闪电侠”就是这么来的）。这里，最常见的调试方式是<strong>预执行表达式</strong>，以及通过<strong>线程调用栈</strong>，死盯某个对象，就能够掌握这个对象的定义、赋值之类</li><li>在使用直接内存的项目中，最好建议配置 -XX:MaxDirectMemorySize，设定一个系统实际可达的最大的直接内存的值，默认的最大直接内存大小等于 -Xmx的值</li><li>排查堆外泄露，建议指定启动参数： -XX:NativeMemoryTracking=summary - Dio.netty.leakDetection.targetRecords=100-Dio.netty.leakDetection.level=PARANOID，后面两个参数是Netty的相关内存泄露检测的级别与采样级别</li><li>参考案例： <a href="https://tech.meituan.com/2018/10/18/netty-direct-memory-screening.html">https://tech.meituan.com/2018/10/18/netty-direct-memory-screening.html</a></li></ol><h1 id="线上元空间内存泄露优化方案有哪些？"><a href="#线上元空间内存泄露优化方案有哪些？" class="headerlink" title="线上元空间内存泄露优化方案有哪些？"></a>线上元空间内存泄露优化方案有哪些？</h1><ol><li>需要注意的一点是 Java8以及Java8+的JVM已经将永久代废弃了，取而代之的是元空间，且元空间是不是在JVM堆中的，而属于堆外内存，受最大物理内存限制。最佳实践就是我们在启动参数中最好设置上 -XX:MetaspaceSize=1024m -XX:MaxMetaspaceSize=1024m。具体的值根据情况设置。为避免动态申请，可以直接都设置为最大值</li><li>元空间主要存放的是类元数据，而且metaspace判断类元数据是否可以回收，是根据加载这些类元数据的Classloader是否可以回收来判断的，只要Classloader不能回收，通过其加载的类元数据就不会被回收。所以线上有时候会出现一种问题，由于框架中，往往大量采用类似ASM、javassist等工具进行字节码增强，生成代理类。如果项目中由主线程频繁生成动态代理类，那么就会导致元空间迅速占满，无法回收</li><li>具体案例可以参见： <a href="https://zhuanlan.zhihu.com/p/200802910">https://zhuanlan.zhihu.com/p/200802910</a></li></ol><h1 id="java类加载器有哪些？"><a href="#java类加载器有哪些？" class="headerlink" title="java类加载器有哪些？"></a>java类加载器有哪些？</h1><p><strong>Bootstrap类加载器</strong></p><p>启动类加载器主要加载的是JVM自身需要的类，这个类加载使用C++语言实现的，没有父类，是虚拟机自身的一部分，它负责将 <strong><JAVA_HOME>/lib路径下的核心类库</strong>或**-Xbootclasspath参数指定的路径下的jar包**加载到内存中，注意必由于虚拟机是按照文件名识别加载jar包的，如rt.jar，如果文件名不被虚拟机识别，即使把jar包丢到lib目录下也是没有作用的(出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头</p><p><strong>Extention 类加载器</strong></p><p>扩展类加载器是指Sun公司实现的sun.misc.Launcher$ExtClassLoader类，<strong>由Java语言实现的</strong>，父类加载器为null，是Launcher的静态内部类，它负责加载**<JAVA_HOME>/lib/ext目录下<strong>或者由系统变量</strong>-Djava.ext.dir指定位路径中的类库**，开发者可以直接使用标准扩展类加载器<br>[</p><p>](<a href="https://blog.csdn.net/javazejian/article/details/73413292">https://blog.csdn.net/javazejian/article/details/73413292</a>)</p><p><strong>Application类加载器</strong></p><p>称应用程序加载器是指 Sun公司实现的sun.misc.Launcher$AppClassLoader。父类加载器为ExtClassLoader，它负责加载<strong>系统类路径java -classpath</strong>或**-D java.class.path 指定路径下的类库<strong>，也就是我们经常用到的</strong>classpath路径**，开发者可以直接使用系统类加载器，一般情况下该类加载是程序中默认的类加载器，通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器<br><strong>​</strong></p><p><strong>Custom自定义类加载器</strong></p><p>应用程序可以自定义类加载器，父类加载器为AppClassLoader</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/classloader.png" alt="image.png"></p><h1 id="双亲委派机制是什么？"><a href="#双亲委派机制是什么？" class="headerlink" title="双亲委派机制是什么？"></a>双亲委派机制是什么？</h1><h2 id="-3"><a href="#-3" class="headerlink" title=""></a><img src="../../../%E7%89%9B%E5%AE%A2%E7%BD%91%E6%9C%80%E6%96%B0java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87MD%E8%AF%BE%E4%BB%B6/%E6%9C%80%E5%85%A8MD%E8%AF%B7%E7%9C%8B-200%E9%A2%98%E7%9B%AE%E5%92%8C%E7%AD%94%E6%A1%88%EF%BC%88xin%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F+%E5%BE%AE%E6%9C%8D%E5%8A%A1+MYSQL+Redis+JVM+Spring%E7%AD%89%E7%AD%89/images/classloader2.png"></h2><p>双亲委派机制<br>双亲委派模式是在Java 1.2后引入的，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个<strong>请求委托给父类的加载器去执行</strong>，如果父类加载器还存在其父类加载器，则<strong>进一步向上委托，依次递归</strong>，<strong>请求最终将到达顶层的启动类加载器</strong>，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</p><p>双亲委派的好处</p><ul><li>每一个类都只会被加载一次，避免了重复加载</li><li>每一个类都会被尽可能的加载（从引导类加载器往下，每个加载器都可能会根据优先次序尝试加载它）</li><li>有效避免了某些恶意类的加载（比如自定义了Java.lang.Object类，一般而言在双亲委派模型下会加载系统的Object类而不是自定义的Object类）</li></ul><p>另外，可以多讲一下，如何破坏双亲委派模型</p><ol><li>双亲委派模型的第一次“被破坏”是重写自定义加载器的loadClass(),jdk不推荐。一般都只是重写findClass()，这样可以保持双亲委派机制.而loadClass方法加载规则由自己定义，就可以随心所欲的加载类</li><li>双亲委派模型的第二次“被破坏”是ServiceLoader和Thread.setContextClassLoader()。即线程上下文类加载器（contextClassLoader）。双亲委派模型很好地解决了各个类加载器的基础类统一问题(越基础的类由越上层的加载器进行加载)，基础类之所以被称为“基础”，是因为它们总是作为被调用代码调用的API。但是，如果基础类又要调用用户的代码，那该怎么办呢？线程上下文类加载器就出现了。<ol><li>SPI。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个；如果在应用程序的全局范围内都没有设置过，那么这个类加载器默认就是应用程序类加载器。了有线程上下文类加载器，JNDI服务使用这个线程上下文类加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型，但这也是无可奈何的事情。Java中所有涉及SPI的加载动作基本上都采用这种方式，例如JNDI,JDBC,JCE,JAXB和JBI等。</li><li>线程上下文类加载器默认情况下就是AppClassLoader，那为什么不直接通过getSystemClassLoader()获取类加载器来加载classpath路径下的类的呢？其实是可行的，但这种直接使用getSystemClassLoader()方法获取AppClassLoader加载类有一个缺点，那就是代码部署到不同服务时会出现问题，如把代码部署到Java Web应用服务或者EJB之类的服务将会出问题，因为这些服务使用的线程上下文类加载器并非AppClassLoader，而是Java Web应用服自家的类加载器，类加载器不同。，所以我们应用该少用getSystemClassLoader()。总之不同的服务使用的可能默认ClassLoader是不同的，但使用线程上下文类加载器总能获取到与当前程序执行相同的ClassLoader，从而避免不必要的问题</li></ol></li><li>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求导致的，这里所说的“动态性”指的是当前一些非常“热门”的名词：代码热替换、模块热部署等，简答的说就是机器不用重启，只要部署上就能用。</li></ol><h1 id="GC如何判断对象可以被回收？"><a href="#GC如何判断对象可以被回收？" class="headerlink" title="GC如何判断对象可以被回收？"></a>GC如何判断对象可以被回收？</h1><ol><li>引用计数法（已被淘汰的算法）<ol><li>每一个对象有一个引用属性，新增一个引用时加一，引用释放时减一，计数为0的时候可以回收。</li></ol></li></ol><p>但是这种计算方法，有一个致命的问题，无法解决循环引用的问题</p><ol start="2"><li>可达性分析算法（根引用）<ol><li>从GcRoot开始向下搜索，搜索所走过的路径被称为引用链，当一个对象到GcRoot没有任何引用链相连时，则证明此对象是不可用的，那么虚拟机就可以判定回收。</li><li>那么GcRoot有哪些？<ol><li>虚拟机栈中引用的对象</li><li>方法区中静态属性引用的对象。</li><li>方法区中常量引用的对象</li><li>本地方法栈中（即一般说的native方法）引用的对象</li></ol></li></ol></li><li>此外，不同的引用类型的回收机制是不一样的<ol><li>强引用：通过关键字new的对象就是强引用对象，强引用指向的对象任何时候都不会被回收，宁愿OOM也不会回收。</li><li>软引用：如果一个对象持有软引用，那么当JVM堆空间不足时，会被回收。一个类的软引用可以通过java.lang.ref.SoftReference持有。</li><li>弱引用：如果一个对象持有弱引用，那么在GC时，只要发现弱引用对象，就会被回收。一个类的弱引用可以通过java.lang.ref.WeakReference持有。</li><li>虚引用：几乎和没有一样，随时可以被回收。通过PhantomReference持有。</li></ol></li></ol><h1 id="如何回收内存对象，有哪些回收算法？"><a href="#如何回收内存对象，有哪些回收算法？" class="headerlink" title="如何回收内存对象，有哪些回收算法？"></a>如何回收内存对象，有哪些回收算法？</h1><p><strong>1.标记-清除（Mark-Sweep）算法</strong>  </p><p>分为标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。<img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/before.png"></p><p>它的主要不足有两个：</p><ul><li>效率问题，标记和清除两个过程的效率都不高。</li><li>空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li></ul><ol start="2"><li><strong>复制算法</strong></li></ol><p>为了解决效率问题，一种称为复制（Copying）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。<br><img src="../../../%E7%89%9B%E5%AE%A2%E7%BD%91%E6%9C%80%E6%96%B0java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87MD%E8%AF%BE%E4%BB%B6/%E6%9C%80%E5%85%A8MD%E8%AF%B7%E7%9C%8B-200%E9%A2%98%E7%9B%AE%E5%92%8C%E7%AD%94%E6%A1%88%EF%BC%88xin%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F+%E5%BE%AE%E6%9C%8D%E5%8A%A1+MYSQL+Redis+JVM+Spring%E7%AD%89%E7%AD%89/images/copy.png"><br><strong>复制算法的代价</strong>是将内存缩小为了原来的一半，减少了实际可用的内存。现在的商业虚拟机都采用这种收集算法来回收新生代，IBM公司的专门研究表明，新生代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion)。</p><ol start="3"><li><strong>标记-整理算法</strong></li></ol><p>复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。根据老年代的特点，有人提出了另外一种标记-整理（Mark-Compact）算法，标记过程仍然与标记-清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。<br><img src="../../../%E7%89%9B%E5%AE%A2%E7%BD%91%E6%9C%80%E6%96%B0java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87MD%E8%AF%BE%E4%BB%B6/%E6%9C%80%E5%85%A8MD%E8%AF%B7%E7%9C%8B-200%E9%A2%98%E7%9B%AE%E5%92%8C%E7%AD%94%E6%A1%88%EF%BC%88xin%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F+%E5%BE%AE%E6%9C%8D%E5%8A%A1+MYSQL+Redis+JVM+Spring%E7%AD%89%E7%AD%89/images/3-1621487892206.png"></p><ol start="4"><li><strong>分代收集算法</strong></li></ol><p>当前商业虚拟机的垃圾收集都采用分代收集（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记—清理或者标记—整理算法来进行回收。</p><h1 id="jvm有哪些垃圾回收器，实际中如何选择？"><a href="#jvm有哪些垃圾回收器，实际中如何选择？" class="headerlink" title="jvm有哪些垃圾回收器，实际中如何选择？"></a>jvm有哪些垃圾回收器，实际中如何选择？</h1><p><img src="../../../%E7%89%9B%E5%AE%A2%E7%BD%91%E6%9C%80%E6%96%B0java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87MD%E8%AF%BE%E4%BB%B6/%E6%9C%80%E5%85%A8MD%E8%AF%B7%E7%9C%8B-200%E9%A2%98%E7%9B%AE%E5%92%8C%E7%AD%94%E6%A1%88%EF%BC%88xin%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F+%E5%BE%AE%E6%9C%8D%E5%8A%A1+MYSQL+Redis+JVM+Spring%E7%AD%89%E7%AD%89/images/gcollector.png"><br>图中展示了7种作用于不同分代的收集器，如果两个收集器之间存在连线，则说明它们可以搭配使用。虚拟机所处的区域则表示它是属于新生代还是老年代收集器。<br>新生代收集器（全部的都是复制算法）：Serial、ParNew、Parallel Scavenge<br>老年代收集器：CMS（标记-清理）、Serial Old（标记-整理）、Parallel Old（标记整理）<br>整堆收集器： G1（一个Region中是标记-清除算法，2个Region之间是复制算法）<br>同时，先解释几个名词：<br>1，<strong>并行（Parallel）</strong>：多个垃圾收集线程并行工作，此时用户线程处于等待状态<br>2，<strong>并发（Concurrent）</strong>：用户线程和垃圾收集线程同时执行<br>3，<strong>吞吐量</strong>：运行用户代码时间／（运行用户代码时间＋垃圾回收时间）<br><strong>1.Serial收集器是最基本的、发展历史最悠久的收集器。</strong><br><strong>特点：</strong>单线程、简单高效（与其他收集器的单线程相比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程手机效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）。<br><strong>应用场景</strong>：适用于Client模式下的虚拟机。<br><strong>Serial / Serial Old收集器运行示意图</strong><br><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/serial.png"><br><strong>2.ParNew收集器其实就是Serial收集器的多线程版本。</strong><br>除了使用多线程外其余行为均和Serial收集器一模一样（参数控制、收集算法、Stop The World、对象分配规则、回收策略等）。<br><strong>特点</strong>：多线程、ParNew收集器默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境中，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。<br>　　　和Serial收集器一样存在Stop The World问题<br><strong>应用场景</strong>：ParNew收集器是许多运行在Server模式下的虚拟机中首选的新生代收集器，因为它是除了Serial收集器外，唯一一个能与CMS收集器配合工作的。<br><em>ParNew/Serial Old组合收集器运行示意图如下：</em><br><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/parnew.png"><br><strong>3.Parallel Scavenge 收集器与吞吐量关系密切，故也称为吞吐量优先收集器。</strong><br><strong>特点</strong>：属于新生代收集器也是采用复制算法的收集器，又是并行的多线程收集器（与ParNew收集器类似）。<br>该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是：GC自适应调节策略（与ParNew收集器最重要的一个区别）<br><strong>GC自适应调节策略</strong>：Parallel Scavenge收集器可设置-XX:+UseAdptiveSizePolicy参数。当开关打开时不需要手动指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRation）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold)等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为GC的自适应调节策略。<br>Parallel Scavenge收集器使用两个参数控制吞吐量：</p><ul><li>XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间</li><li>XX:GCRatio 直接设置吞吐量的大小。</li></ul><p><strong>4.Serial Old是Serial收集器的老年代版本。</strong><br><strong>特点</strong>：同样是单线程收集器，采用标记-整理算法。<br><strong>应用场景</strong>：主要也是使用在Client模式下的虚拟机中。也可在Server模式下使用。<br>Server模式下主要的两大用途（在后续中详细讲解···）：</p><ol><li>在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用。</li><li>作为CMS收集器的后备方案，在并发收集Concurent Mode Failure时使用。</li></ol><p>Serial / Serial Old收集器工作过程图（Serial收集器图示相同）：<br><img src="../../../%E7%89%9B%E5%AE%A2%E7%BD%91%E6%9C%80%E6%96%B0java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87MD%E8%AF%BE%E4%BB%B6/%E6%9C%80%E5%85%A8MD%E8%AF%B7%E7%9C%8B-200%E9%A2%98%E7%9B%AE%E5%92%8C%E7%AD%94%E6%A1%88%EF%BC%88xin%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F+%E5%BE%AE%E6%9C%8D%E5%8A%A1+MYSQL+Redis+JVM+Spring%E7%AD%89%E7%AD%89/images/serial-old.png"><br><strong>5.Parallel Old是Parallel Scavenge收集器的老年代版本。</strong><br><strong>特点</strong>：多线程，采用标记-整理算法。<br><strong>应用场景</strong>：注重高吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge+Parallel Old 收集器。<br><em>Parallel Scavenge/Parallel Old收集器工作过程图：</em><br><strong>6.CMS收集器是一种以获取最短回收停顿时间为目标的收集器。</strong><br><strong>特点</strong>：基于标记-清除算法实现。并发收集、低停顿。<br><strong>应用场景</strong>：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如web程序、b/s服务。<br><strong>CMS收集器的运行过程分为下列4步：</strong><br><strong>初始标记</strong>：标记GC Roots能直接到的对象。速度很快但是仍存在Stop The World问题。<br><strong>并发标记</strong>：进行GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行。<br><strong>重新标记</strong>：为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在Stop The World问题。<br><strong>并发清除</strong>：对标记的对象进行清除回收。<br>CMS收集器的内存回收过程是与用户线程一起并发执行的。<br> CMS收集器的工作过程图：<br><img src="../../../%E7%89%9B%E5%AE%A2%E7%BD%91%E6%9C%80%E6%96%B0java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87MD%E8%AF%BE%E4%BB%B6/%E6%9C%80%E5%85%A8MD%E8%AF%B7%E7%9C%8B-200%E9%A2%98%E7%9B%AE%E5%92%8C%E7%AD%94%E6%A1%88%EF%BC%88xin%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F+%E5%BE%AE%E6%9C%8D%E5%8A%A1+MYSQL+Redis+JVM+Spring%E7%AD%89%E7%AD%89/images/cms.png"><br>CMS收集器的缺点：</p><ul><li>对CPU资源非常敏感。</li><li>无法处理浮动垃圾，可能出现Concurrent Model Failure失败而导致另一次Full GC的产生。</li><li>因为采用标记-清除算法所以会存在空间碎片的问题，导致大对象无法分配空间，不得不提前触发一次Full GC。<img src="../../../%E7%89%9B%E5%AE%A2%E7%BD%91%E6%9C%80%E6%96%B0java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87MD%E8%AF%BE%E4%BB%B6/%E6%9C%80%E5%85%A8MD%E8%AF%B7%E7%9C%8B-200%E9%A2%98%E7%9B%AE%E5%92%8C%E7%AD%94%E6%A1%88%EF%BC%88xin%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F+%E5%BE%AE%E6%9C%8D%E5%8A%A1+MYSQL+Redis+JVM+Spring%E7%AD%89%E7%AD%89/images/cms2.png"></li></ul><p><strong>​</strong></p><p><strong>7.G1收集器一款面向服务端应用的垃圾收集器。</strong><br><strong>特点如下：</strong><br>并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短Stop-The-World停顿时间。部分收集器原本需要停顿Java线程来执行GC动作，G1收集器仍然可以通过并发的方式让Java程序继续运行。<br>分代收集：G1能够独自管理整个Java堆，并且采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。<br>空间整合：G1运作期间不会产生空间碎片，收集后能提供规整的可用内存。<br>可预测的停顿：G1除了追求低停顿外，还能建立可预测的停顿时间模型。能让使用者明确指定在一个长度为M毫秒的时间段内，消耗在垃圾收集上的时间不得超过N毫秒。<br><strong>G1收集器运行示意图：</strong><br><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/g1.png"><br><strong>​</strong></p><p>关于gc的选择<br>除非应用程序有非常严格的暂停时间要求，否则请先运行应用程序并允许VM选择收集器（如果没有特别要求。使用VM提供给的默认GC就好）。<br>如有必要，调整堆大小以提高性能。 如果性能仍然不能满足目标，请使用以下准则作为选择收集器的起点：</p><ul><li>如果应用程序的数据集较小（最大约100 MB），则选择带有选项-XX：+ UseSerialGC的串行收集器。</li><li>如果应用程序将在单个处理器上运行，并且没有暂停时间要求，则选择带有选项-XX：+ UseSerialGC的串行收集器。</li><li>如果（a）峰值应用程序性能是第一要务，并且（b）没有暂停时间要求或可接受一秒或更长时间的暂停，则让VM选择收集器或使用-XX：+ UseParallelGC选择并行收集器 。</li><li>如果响应时间比整体吞吐量更重要，并且垃圾收集暂停时间必须保持在大约一秒钟以内，则选择具有-XX：+ UseG1GC。（值得注意的是JDK9中CMS已经被Deprecated，不可使用！移除该选项）</li><li>如果使用的是jdk8，并且堆内存达到了16G，那么推荐使用G1收集器，来控制每次垃圾收集的时间。</li><li>如果响应时间是高优先级，或使用的堆非常大，请使用-XX：UseZGC选择完全并发的收集器。（值得注意的是JDK11开始可以启动ZGC，但是此时ZGC具有实验性质，在JDK15中[202009发布]才取消实验性质的标签，可以直接显示启用，但是JDK15默认GC仍然是G1）</li></ul><p>这些准则仅提供选择收集器的起点，因为性能取决于堆的大小，应用程序维护的实时数据量以及可用处理器的数量和速度。<br>如果推荐的收集器没有达到所需的性能，则首先尝试调整堆和新生代大小以达到所需的目标。 如果性能仍然不足，尝试使用其他收集器<br><strong>总体原则</strong>：减少STOP THE WORD时间，使用并发收集器（比如CMS+ParNew，G1）来减少暂停时间，加快响应时间，并使用并行收集器来增加多处理器硬件上的总体吞吐量。</p><h1 id="JVM8为什么要增加元空间？"><a href="#JVM8为什么要增加元空间？" class="headerlink" title="JVM8为什么要增加元空间？"></a>JVM8为什么要增加元空间？</h1><p>原因：<br>1、字符串存在永久代中，容易出现性能问题和内存溢出。<br>2、类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。<br>3、永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</p><h1 id="JVM8中元空间有哪些特点？"><a href="#JVM8中元空间有哪些特点？" class="headerlink" title="JVM8中元空间有哪些特点？"></a>JVM8中元空间有哪些特点？</h1><p>1，每个加载器有专门的存储空间。<br>2，不会单独回收某个类。<br>3，元空间里的对象的位置是固定的。<br>4，如果发现某个加载器不再存货了，会把相关的空间整个回收</p><h1 id="如何解决线上gc频繁的问题？"><a href="#如何解决线上gc频繁的问题？" class="headerlink" title="如何解决线上gc频繁的问题？"></a>如何解决线上gc频繁的问题？</h1><ol><li>查看监控，以了解出现问题的时间点以及当前FGC的频率（可对比正常情况看频率是否正常）</li><li>了解该时间点之前有没有程序上线、基础组件升级等情况。</li><li>了解JVM的参数设置，包括：堆空间各个区域的大小设置，新生代和老年代分别采用了哪些垃圾收集器，然后分析JVM参数设置是否合理。</li><li>再对步骤1中列出的可能原因做排除法，其中元空间被打满、内存泄漏、代码显式调用gc方法比较容易排查。</li><li>针对大对象或者长生命周期对象导致的FGC，可通过 jmap -histo 命令并结合dump堆内存文件作进一步分析，需要先定位到可疑对象。</li><li>通过可疑对象定位到具体代码再次分析，这时候要结合GC原理和JVM参数设置，弄清楚可疑对象是否满足了进入到老年代的条件才能下结论。</li></ol><h1 id="内存溢出的原因有哪些，如何排查线上问题？"><a href="#内存溢出的原因有哪些，如何排查线上问题？" class="headerlink" title="内存溢出的原因有哪些，如何排查线上问题？"></a>内存溢出的原因有哪些，如何排查线上问题？</h1><ol><li>java.lang.OutOfMemoryError: ……java heap space…..   堆栈溢出，代码问题的可能性极大</li><li>java.lang.OutOfMemoryError: GC over head limit exceeded 系统处于高频的GC状态，而且回收的效果依然不佳的情况，就会开始报这个错误，这种情况一般是产生了很多不可以被释放的对象，有可能是引用使用不当导致，或申请大对象导致，但是java heap space的内存溢出有可能提前不会报这个错误，也就是可能内存就直接不够导致，而不是高频GC.</li><li>java.lang.OutOfMemoryError: PermGen space jdk1.7之前才会出现的问题 ，原因是系统的代码非常多或引用的第三方包非常多、或代码中使用了大量的常量、或通过intern注入常量、或者通过动态代码加载等方法，导致常量池的膨胀</li><li>java.lang.OutOfMemoryError: Direct buffer memory    直接内存不足，因为jvm垃圾回收不会回收掉直接内存这部分的内存，所以可能原因是直接或间接使用了ByteBuffer中的allocateDirect方法的时候，而没有做clear</li><li>java.lang.StackOverflowError -     Xss设置的太小了</li><li>java.lang.OutOfMemoryError: unable to create new native thread 堆外内存不足，无法为线程分配内存区域</li><li>java.lang.OutOfMemoryError: request {} byte for {}out of swap 地址空间不够</li></ol><h1 id="Happens-Before规则是什么？"><a href="#Happens-Before规则是什么？" class="headerlink" title="Happens-Before规则是什么？"></a>Happens-Before规则是什么？</h1><ol><li>程序顺序规则：一个线程中的每一个操作，happens-before于该线程中的任意后续操作。</li><li>监视器规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。</li><li>volatile规则：对一个volatile变量的写，happens-before于任意后续对一个volatile变量的读。</li><li>传递性：若果A happens-before B，B happens-before C，那么A happens-before C。</li><li>线程启动规则：Thread对象的start()方法，happens-before于这个线程的任意后续操作。</li><li>线程终止规则：线程中的任意操作，happens-before于该线程的终止监测。我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。</li><li>线程中断操作：对线程interrupt()方法的调用，happens-before于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到线程是否有中断发生。</li><li>对象终结规则：一个对象的初始化完成，happens-before于这个对象的finalize()方法的开始。</li></ol><h1 id="介绍一下线程的生命周期及状态？"><a href="#介绍一下线程的生命周期及状态？" class="headerlink" title="介绍一下线程的生命周期及状态？"></a>介绍一下线程的生命周期及状态？</h1><p><img src="../../../%E7%89%9B%E5%AE%A2%E7%BD%91%E6%9C%80%E6%96%B0java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87MD%E8%AF%BE%E4%BB%B6/%E6%9C%80%E5%85%A8MD%E8%AF%B7%E7%9C%8B-200%E9%A2%98%E7%9B%AE%E5%92%8C%E7%AD%94%E6%A1%88%EF%BC%88xin%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F+%E5%BE%AE%E6%9C%8D%E5%8A%A1+MYSQL+Redis+JVM+Spring%E7%AD%89%E7%AD%89/images/life.jpg" alt="未命名文件.jpg"><br><strong>1.创建</strong><br>当程序使用new关键字创建了一个线程之后，该线程就处于一个新建状态（初始状态），此时它和其他Java对象一样，仅仅由Java虚拟机为其分配了内存，并初始化了其成员变量值。此时的线程对象没有表现出任何线程的动态特征，程序也不会执行线程的线程执行体。<br><strong>2.就绪</strong><br>当线程对象调用了Thread.start()方法之后，该线程处于就绪状态。Java虚拟机会为其创建方法调用栈和程序计数器，处于这个状态的线程并没有开始运行，它只是表示该线程可以运行了。从start()源码中看出，start后添加到了线程列表中，接着在native层添加到VM中，至于该线程何时开始运行，取决于JVM里线程调度器的调度(如果OS调度选中了，就会进入到运行状态)。<br><strong>3.运行</strong><br>当线程对象调用了Thread.start()方法之后，该线程处于就绪状态。添加到了线程列表中，如果OS调度选中了，就会进入到运行状态<br><strong>4.阻塞</strong><br>阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况大概三种：</p><ul><li>1、<strong>等待阻塞</strong>：运行的线程执行wait()方法，JVM会把该线程放入等待池中。(wait会释放持有的锁)</li><li>2、<strong>同步阻塞</strong>：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。</li><li>3、<strong>其他阻塞</strong>：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。（注意,sleep是不会释放持有的锁）。</li><li>线程睡眠：Thread.sleep(long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。</li><li>线程等待：Object类中的wait()方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait(0) 一样。唤醒线程后，就转为就绪（Runnable）状态。</li><li>线程让步：Thread.yield() 方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。</li><li>线程加入：join()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。</li><li>线程I/O：线程执行某些IO操作，因为等待相关的资源而进入了阻塞状态。比如说监听system.in，但是尚且没有收到键盘的输入，则进入阻塞状态。</li><li>线程唤醒：Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程，选择是任意性的，并在对实现做出决定时发生。类似的方法还有一个notifyAll()，唤醒在此对象监视器上等待的所有线程。</li></ul><p><strong>5.死亡</strong><br>线程会以以下三种方式之一结束，结束后就处于死亡状态:</p><ul><li>run()方法执行完成，线程正常结束。</li><li>线程抛出一个未捕获的Exception或Error。</li><li>直接调用该线程的stop()方法来结束该线程——该方法容易导致死锁，通常不推荐使用</li></ul><h1 id="线程的sleep、wait、join、yield如何使用？"><a href="#线程的sleep、wait、join、yield如何使用？" class="headerlink" title="线程的sleep、wait、join、yield如何使用？"></a>线程的sleep、wait、join、yield如何使用？</h1><p><strong>sleep</strong>:让线程睡眠，期间会出让cpu，在同步代码块中，不会释放锁<br><strong>wait</strong>(必须先获得对应的锁才能调用):让线程进入等待状态,释放当前线程持有的锁资源线程只有在notify 或者notifyAll方法调用后才会被唤醒,然后去争夺锁.<br><strong>join</strong>:线程之间协同方式,使用场景: 线程A必须等待线程B运行完毕后才可以执行,那么就可以在线程A的代码中加入ThreadB.join();<br><strong>yield</strong>:让当前正在运行的线程回到可运行状态，以允许具有相同优先级的其他线程获得运行的机会。因此，使用yield()的目的是让具有相同优先级的线程之间能够适当的轮换执行。但是，实际中无法保证yield()达到让步的目的，因为，让步的线程可能被线程调度程序再次选中。</p><h1 id="创建线程有哪些方式？"><a href="#创建线程有哪些方式？" class="headerlink" title="创建线程有哪些方式？"></a>创建线程有哪些方式？</h1><p>1）继承Thread类创建线程<br>2）实现Runnable接口创建线程<br>3）使用Callable和Future创建线程<br>4）使用线程池例如用Executor框架</p><h1 id="什么是守护线程？"><a href="#什么是守护线程？" class="headerlink" title="什么是守护线程？"></a>什么是守护线程？</h1><p>在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) <br>任何一个守护线程都是整个JVM中所有非守护线程的保姆：<br>只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。<br>User和Daemon两者几乎没有区别，唯一的不同之处就在于虚拟机的离开：如果 User Thread已经全部退出运行了，只剩下Daemon Thread存在了，虚拟机也就退出了。 因为没有了被守护者，Daemon也就没有工作可做了，也就没有继续运行程序的必要了。<br>注意事项:<br>(1) thread.setDaemon(true)必须在thread.start()之前设置，否则会出现一个IllegalThreadStateException异常。只能在线程未开始运行之前设置为守护线程。<br>(2) 在Daemon线程中产生的新线程也是Daemon的。<br>(3) 不要认为所有的应用都可以分配给Daemon来进行读写操作或者计算逻辑，因为这会可能回到数据不一致的状态。</p><h1 id="ThreadLocal的原理是什么，使用场景有哪些？"><a href="#ThreadLocal的原理是什么，使用场景有哪些？" class="headerlink" title="ThreadLocal的原理是什么，使用场景有哪些？"></a>ThreadLocal的原理是什么，使用场景有哪些？</h1><p>Thread类中有两个变量threadLocals和inheritableThreadLocals，二者都是ThreadLocal内部类ThreadLocalMap类型的变量，我们通过查看内部内ThreadLocalMap可以发现实际上它类似于一个HashMap。在默认情况下，每个线程中的这两个变量都为null:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>只有当线程第一次调用ThreadLocal的set或者get方法的时候才会创建他们。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                T result = (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，每个线程的本地变量不是存放在ThreadLocal实例中，而是放在调用线程的<strong>ThreadLocals</strong>变量里面。也就是说，<strong>ThreadLocal类型的本地变量是存放在具体的线程空间上</strong>，其本身相当于一个装载本地变量的载体，通过set方法将value添加到调用线程的threadLocals中，当调用线程调用get方法时候能够从它的threadLocals中取出变量。如果调用线程一直不终止，那么这个本地变量将会一直存放在他的threadLocals中，所以不使用本地变量的时候需要调用remove方法将threadLocals中删除不用的本地变量,防止出现内存泄漏。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">         <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">             m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ThreadLocal有哪些内存泄露问题，如何避免？"><a href="#ThreadLocal有哪些内存泄露问题，如何避免？" class="headerlink" title="ThreadLocal有哪些内存泄露问题，如何避免？"></a>ThreadLocal有哪些内存泄露问题，如何避免？</h1><p>每个Thread都有一个ThreadLocal.ThreadLocalMap的map，该map的key为ThreadLocal实例，它为一个弱引用，我们知道弱引用有利于GC回收。当ThreadLocal的key == null时，GC就会回收这部分空间，但是value却不一定能够被回收，因为他还与Current Thread存在一个强引用关系，如下</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/threadlocal.png">由于存在这个强引用关系，会导致value无法回收。如果这个线程对象不会销毁那么这个强引用关系则会一直存在，就会出现内存泄漏情况。所以说只要这个线程对象能够及时被GC回收，就不会出现内存泄漏。如果碰到线程池，那就更坑了。 那么要怎么避免这个问题呢？ 在前面提过，在ThreadLocalMap中的setEntry()、getEntry()，如果遇到key == null的情况，会对value设置为null。当然我们也可以显示调用ThreadLocal的remove()方法进行处理。 下面再对ThreadLocal进行简单的总结：</p><ul><li>ThreadLocal 不是用于解决共享变量的问题的，也不是为了协调线程同步而存在，而是为了方便每个线程处理自己的状态而引入的一个机制。这点至关重要。</li><li>每个Thread内部都有一个ThreadLocal.ThreadLocalMap类型的成员变量，该成员变量用来存储实际的ThreadLocal变量副本。</li><li>ThreadLocal并不是为线程保存对象的副本，它仅仅只起到一个索引的作用。它的主要木得视为每一个线程隔离一个类的实例，这个实例的作用范围仅限于线程内部。</li></ul><h1 id="为什么要使用线程池？"><a href="#为什么要使用线程池？" class="headerlink" title="为什么要使用线程池？"></a>为什么要使用线程池？</h1><p>为了减少创建和销毁线程的次数，让每个线程可以多次使用,可根据系统情况<strong>调整执行</strong>的线程数量，防止消耗过多内存,所以我们可以使用线程池.</p><h1 id="线程池线程复用的原理是什么？"><a href="#线程池线程复用的原理是什么？" class="headerlink" title="线程池线程复用的原理是什么？"></a>线程池线程复用的原理是什么？</h1><p>思考这么一个问题：任务结束后会不会回收线程？<br>答案是：allowCoreThreadTimeOut控制</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/java/util/concurrent/ThreadPoolExecutor.java:<span class="number">1127</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">        Thread wt = Thread.currentThread();</span><br><span class="line">        Runnable task = w.firstTask;</span><br><span class="line">        w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">        w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">        <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;...执行任务...&#125;</span><br><span class="line">            completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            processWorkerExit(w, completedAbruptly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">首先线程池内的线程都被包装成了一个个的java.util.concurrent.ThreadPoolExecutor.Worker,然后这个worker会马不停蹄的执行任务,执行完任务之后就会在<span class="keyword">while</span>循环中去取任务,取到任务就继续执行,取不到任务就跳出<span class="keyword">while</span>循环(这个时候worker就不能再执行任务了)执行 processWorkerExit方法,这个方法呢就是做清场处理,将当前woker线程从线程池中移除,并且判断是否是异常的进入processWorkerExit方法,如果是非异常情况,就对当前线程池状态(RUNNING,shutdown)和当前工作线程数和当前任务数做判断,是否要加入一个新的线程去完成最后的任务(防止没有线程去做剩下的任务).</span><br><span class="line">那么什么时候会退出<span class="keyword">while</span>循环呢?取不到任务的时候(getTask() == <span class="keyword">null</span>).下面看一下getTask方法</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">            <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//(rs == SHUTDOWN &amp;&amp; workQueue.isEmpty()) || rs &gt;=STOP</span></span><br><span class="line">            <span class="comment">//若线程池状态是SHUTDOWN 并且 任务队列为空,意味着已经不需要工作线程执行任务了,线程池即将关闭</span></span><br><span class="line">            <span class="comment">//若线程池的状态是 STOP TIDYING TERMINATED,则意味着线程池已经停止处理任何任务了,不在需要线程</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="comment">//把此工作线程从线程池中删除</span></span><br><span class="line">                decrementWorkerCount();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//allowCoreThreadTimeOut:当没有任务的时候,核心线程数也会被剔除,默认参数是false,官方推荐在创建线程池并且还未使用的时候,设置此值</span></span><br><span class="line">            <span class="comment">//如果当前工作线程数 大于 核心线程数,timed为true</span></span><br><span class="line">            <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//(wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)):当工作线程超过最大线程数,或者 允许超时并且超时过一次了</span></span><br><span class="line">            <span class="comment">//(wc &gt; 1 || workQueue.isEmpty()):工作线程数至少为1个 或者 没有任务了</span></span><br><span class="line">            <span class="comment">//总的来说判断当前工作线程还有没有必要等着拿任务去执行</span></span><br><span class="line">            <span class="comment">//wc &gt; maximumPoolSize &amp;&amp; wc&gt;1 : 就是判断当前工作线程是否超过最大值</span></span><br><span class="line">            <span class="comment">//或者 wc &gt; maximumPoolSize &amp;&amp; workQueue.isEmpty():工作线程超过最大,基本上不会走到这,</span></span><br><span class="line">            <span class="comment">//如果走到这,则意味着wc=1 ,只有1个工作线程了,如果此时任务队列是空的,则把最后的线程删除</span></span><br><span class="line">            <span class="comment">//或者(timed &amp;&amp; timedOut) &amp;&amp; wc&gt;1:如果允许超时并且超时过一次,并且至少有1个线程,则删除线程</span></span><br><span class="line">            <span class="comment">//或者 (timed &amp;&amp; timedOut) &amp;&amp; workQueue.isEmpty():如果允许超时并且超时过一次,并且此时工作队列为空，那么妥妥可以把最后一个线程（因为上面的wc&gt;1不满足，则可以得出来wc=1）删除</span></span><br><span class="line">            <span class="keyword">if</span> ((wc &gt; maximumPoolSize  || (timed &amp;&amp; timedOut))</span><br><span class="line">                &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="comment">//如果减去工作线程数成功,则返回null出去,也就是说 让工作线程停止while轮训,进行收尾</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断是否要阻塞获取任务</span></span><br><span class="line">                Runnable r = timed ?</span><br><span class="line">                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                    workQueue.take();</span><br><span class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                timedOut = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">                timedOut = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//综上所述,如果allowCoreThreadTimeOut为true,并且在第1次阻塞获取任务失败了,那么当前getTask会返回null,不管是不是核心线程;那么runWorker中将推出while循环,也就意味着当前工作线程被销毁</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过上面这个问题可以得出一个结论：当你的线程池参数配置合理的时候，执行完任务的线程是不会被销毁的，而是会从任务队列中取出任务继续执行！</p><h1 id="如何预防死锁？"><a href="#如何预防死锁？" class="headerlink" title="如何预防死锁？"></a>如何预防死锁？</h1><ol><li>首先需要将死锁发生的是个必要条件讲出来:<ol><li>互斥条件 同一时间只能有一个线程获取资源。</li><li>不可剥夺条件 一个线程已经占有的资源，在释放之前不会被其它线程抢占</li><li>请求和保持条件 线程等待过程中不会释放已占有的资源</li><li>循环等待条件 多个线程互相等待对方释放资源</li></ol></li><li>死锁预防，那么就是需要破坏这四个必要条件<ol><li>由于资源互斥是资源使用的固有特性，无法改变，我们不讨论</li><li>破坏不可剥夺条件<ol><li>一个进程不能获得所需要的全部资源时便处于等待状态，等待期间他占有的资源将被隐式的释放重新加入到系统的资源列表中，可以被其他的进程使用，而等待的进程只有重新获得自己原有的资源以及新申请的资源才可以重新启动，执行</li></ol></li></ol></li><li>破坏请求与保持条件<ol><li>第一种方法静态分配即每个进程在开始执行时就申请他所需要的全部资源</li><li>第二种是动态分配即每个进程在申请所需要的资源时他本身不占用系统资源</li></ol></li><li>破坏循环等待条件<ol><li>采用资源有序分配其基本思想是将系统中的所有资源顺序编号，将紧缺的，稀少的采用较大的编号，在申请资源时必须按照编号的顺序进行，一个进程只有获得较小编号的进程才能申请较大编号的进程。</li></ol></li></ol><h1 id="描述一下线程安全活跃态问题？"><a href="#描述一下线程安全活跃态问题？" class="headerlink" title="描述一下线程安全活跃态问题？"></a>描述一下线程安全活跃态问题？</h1><p>线程安全的活跃性问题可以分为 死锁、活锁、饥饿   </p><ol><li>活锁 就是有时线程虽然没有发生阻塞，但是仍然会存在执行不下去的情况，活锁不会阻塞线程，线程会一直重复执行某个相同的操作，并且一直失败重试<ol><li>我们开发中使用的异步消息队列就有可能造成活锁的问题，在消息队列的消费端如果没有正确的ack消息，并且执行过程中报错了，就会再次放回消息头，然后再拿出来执行，一直循环往复的失败。这个问题除了正确的ack之外，往往是通过将失败的消息放入到延时队列中，等到一定的延时再进行重试来解决。</li><li>解决活锁的方案很简单，尝试等待一个随机的时间就可以，会按时间轮去重试</li></ol></li><li>饥饿  就是 线程因无法访问所需资源而无法执行下去的情况<ol><li>饥饿 分为两种情况：<ol><li>一种是其他的线程在临界区做了无限循环或无限制等待资源的操作，让其他的线程一直不能拿到锁进入临界区，对其他线程来说，就进入了饥饿状态</li><li>另一种是因为线程优先级不合理的分配，导致部分线程始终无法获取到CPU资源而一直无法执行</li></ol></li><li>解决饥饿的问题有几种方案:<ol><li> 保证资源充足，很多场景下，资源的稀缺性无法解决</li><li> 公平分配资源，在并发编程里使用公平锁，例如FIFO策略，线程等待是有顺序的，排在等待队列前面的线程会优先获得资源</li><li> 避免持有锁的线程长时间执行，很多场景下，持有锁的线程的执行时间也很难缩短</li></ol></li></ol></li><li>死锁  线程在对同一把锁进行竞争的时候，未抢占到锁的线程会等待持有锁的线程释放锁后继续抢占，如果两个或两个以上的线程互相持有对方将要抢占的锁，互相等待对方先行释放锁就会进入到一个循环等待的过程，这个过程就叫做死锁</li></ol><h1 id="线程安全的竞态条件有哪些？"><a href="#线程安全的竞态条件有哪些？" class="headerlink" title="线程安全的竞态条件有哪些？"></a>线程安全的竞态条件有哪些？</h1><ol><li>同一个程序多线程访问同一个资源，如果对资源的访问顺序敏感，就称存在竞态条件，代码区成为临界区。 大多数并发错误一样，竞态条件不总是会产生问题，还需要不恰当的执行时序</li><li>最常见的竞态条件为<ol><li>先检测后执行执行依赖于检测的结果，而检测结果依赖于多个线程的执行时序，而多个线程的执行时序通常情况下是不固定不可判断的，从而导致执行结果出现各种问题，见一种可能 的解决办法就是：在一个线程修改访问一个状态时，要防止其他线程访问修改，也就是加锁机制，保证原子性</li><li>延迟初始化（典型为单例）</li></ol></li></ol><h1 id="程序开多少线程合适？"><a href="#程序开多少线程合适？" class="headerlink" title="程序开多少线程合适？"></a>程序开多少线程合适？</h1><ol><li>CPU 密集型程序，一个完整请求，I/O操作可以在很短时间内完成，CPU还有很多运算要处理，也就是说 CPU 计算的比例占很大一部分，线程等待时间接近0   <ol><li>单核CPU： 一个完整请求，I/O操作可以在很短时间内完成， CPU还有很多运算要处理，也就是说 CPU 计算的比例占很大一部分，线程等待时间接近0。单核CPU处理CPU密集型程序，这种情况并不太适合使用多线程。</li><li>多核 ： 如果是多核CPU 处理 CPU 密集型程序，我们完全可以最大化的利用 CPU 核心数，应用并发编程来提高效率。CPU 密集型程序的最佳线程数就是：理论上线程数量 = CPU 核数（逻辑），但是实际上，数量一般会设置为 CPU 核数（逻辑）+ 1（经验值）,计算(CPU)密集型的线程恰好在某时因为发生一个页错误或者因其他原因而暂停，刚好有一个“额外”的线程，可以确保在这种情况下CPU周期不会中断工作</li></ol></li><li>I/O 密集型程序，与 CPU 密集型程序相对，一个完整请求，CPU运算操作完成之后还有很多 I/O 操作要做，也就是说 I/O 操作占比很大部分，等待时间较长，线程等待时间所占比例越高，需要越多线程；线程CPU时间所占比例越高，需要越少线程<ol><li>I/O 密集型程序的最佳线程数就是： 最佳线程数 = CPU核心数 <em>(1/CPU利用率) = CPU核心数</em> (1 + (I/O耗时/CPU耗时))</li><li>如果几乎全是 I/O耗时，那么CPU耗时就无限趋近于0，所以纯理论你就可以说是 2N（N=CPU核数），当然也有说 2N + 1的，1应该是backup</li><li>一般我们说 2N + 1 就即可</li></ol></li></ol><h1 id="synchronized和lock有哪些区别？"><a href="#synchronized和lock有哪些区别？" class="headerlink" title="synchronized和lock有哪些区别？"></a>synchronized和lock有哪些区别？</h1><table><thead><tr><th>区别类型</th><th>synchronized</th><th>Lock</th></tr></thead><tbody><tr><td>存在层次</td><td>Java的关键字，在jvm层面上</td><td>是JVM的一个接口</td></tr><tr><td>锁的获取</td><td>假设A线程获得锁，B线程等待。如果A线程阻塞，B线程会一直等待</td><td>情况而定，Lock有多个锁获取的方式，大致就是可以尝试获得锁，线程可以不用一直等待(可以通过tryLock判断有没有锁)</td></tr><tr><td>锁的释放</td><td>1、以获取锁的线程执行完同步代码，释放锁2、线程执行发生异常，jvm会让线程释放</td><td>在finally中必须释放锁，不然容易造成线程死锁</td></tr><tr><td>锁类型</td><td>锁可重入、不可中断、非公平</td><td>可重入、可判断 可公平（两者皆可）</td></tr><tr><td>性能</td><td>少量同步</td><td>适用于大量同步</td></tr><tr><td>支持锁的场景</td><td>1.  独占锁</td><td>1.  公平锁与非公平锁</td></tr></tbody></table><h1 id="ABA问题遇到过吗，详细说一下？"><a href="#ABA问题遇到过吗，详细说一下？" class="headerlink" title="ABA问题遇到过吗，详细说一下？"></a>ABA问题遇到过吗，详细说一下？</h1><ol><li>有两个线程同时去修改一个变量的值，比如线程1、线程2，都更新变量值，将变量值从A更新成B。</li><li>首先线程1获取到CPU的时间片，线程2由于某些原因发生阻塞进行等待，此时线程1进行比较更新（CompareAndSwap），成功将变量的值从A更新成B。</li><li>更新完毕之后，恰好又有线程3进来想要把变量的值从B更新成A，线程3进行比较更新，成功将变量的值从B更新成A。</li><li>线程2获取到CPU的时间片，然后进行比较更新，发现值是预期的A，然后有更新成了B。但是线程1并不知道，该值已经有了A-&gt;B-&gt;A这个过程，这也就是我们常说的ABA问题。</li></ol><h1 id="volatile的可见性和禁止指令重排序怎么实现的？"><a href="#volatile的可见性和禁止指令重排序怎么实现的？" class="headerlink" title="volatile的可见性和禁止指令重排序怎么实现的？"></a>volatile的可见性和禁止指令重排序怎么实现的？</h1><ul><li>可见性：<br>volatile的功能就是被修饰的变量在被修改后可以立即同步到主内存，被修饰的变量在每次是用之前都从主内存刷新。本质也是通过内存屏障来实现可见性<br>写内存屏障（Store Memory Barrier）可以促使处理器将当前store buffer（存储缓存）的值写回主存。读内存屏障（Load Memory Barrier）可以促使处理器处理invalidate queue（失效队列）。进而避免由于Store Buffer和Invalidate Queue的非实时性带来的问题。</li><li>禁止指令重排序：<br>volatile是通过<strong>内存屏障</strong>来禁止指令重排序<br>JMM内存屏障的策略<ul><li>在每个 volatile 写操作的前面插入一个 StoreStore 屏障。</li><li>在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。</li><li>在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。</li><li>在每个 volatile 读操作的后面插入一个 LoadStore 屏障。</li></ul></li></ul><h1 id="ConcurrentHashMap底层原理是什么？"><a href="#ConcurrentHashMap底层原理是什么？" class="headerlink" title="ConcurrentHashMap底层原理是什么？"></a>ConcurrentHashMap底层原理是什么？</h1><p>1.7<br>数据结构：<br>内部主要是一个Segment数组，而数组的每一项又是一个HashEntry数组，元素都存在HashEntry数组里。因为每次锁定的是Segment对象，也就是整个HashEntry数组，所以又叫分段锁。<br><img src="../../../%E7%89%9B%E5%AE%A2%E7%BD%91%E6%9C%80%E6%96%B0java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87MD%E8%AF%BE%E4%BB%B6/%E6%9C%80%E5%85%A8MD%E8%AF%B7%E7%9C%8B-200%E9%A2%98%E7%9B%AE%E5%92%8C%E7%AD%94%E6%A1%88%EF%BC%88xin%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F+%E5%BE%AE%E6%9C%8D%E5%8A%A1+MYSQL+Redis+JVM+Spring%E7%AD%89%E7%AD%89/images/1.7ConcurrentHashMap.png" alt="1.7ConcurrentHashMap.png"><br>1.8<br>数据结构：<br>与HashMap一样采用：数组+链表+红黑树<br><img src="../../../%E7%89%9B%E5%AE%A2%E7%BD%91%E6%9C%80%E6%96%B0java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87MD%E8%AF%BE%E4%BB%B6/%E6%9C%80%E5%85%A8MD%E8%AF%B7%E7%9C%8B-200%E9%A2%98%E7%9B%AE%E5%92%8C%E7%AD%94%E6%A1%88%EF%BC%88xin%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F+%E5%BE%AE%E6%9C%8D%E5%8A%A1+MYSQL+Redis+JVM+Spring%E7%AD%89%E7%AD%89/images/ConCurrentHashMap.png" alt="ConCurrentHashMap.png"><br>底层原理则是采用锁链表或者红黑树头结点，相比于HashTable的方法锁，力度更细，是对数组（table）中的桶（链表或者红黑树）的头结点进行锁定，这样锁定，只会影响数组（table)当前下标的数据，不会影响其他下标节点的操作，可以提高读写效率。<br>putVal执行流程：</p><ol><li>判断存储的key、value是否为空，若为空，则抛出异常</li><li>计算key的hash值，随后死循环（该循环可以确保成功插入，当满足适当条件时，会主动终止），判断table表为空或者长度为0，则初始化table表</li><li>根据hash值获取table中该下标对应的节点，如果该节点为空，则根据参数生成新的节点，并以CAS的方式进行更新，并终止死循环。</li><li>如果该节点的hash值是MOVED(-1)，表示正在扩容，则辅助对该节点进行转移。</li><li>对数组（table）中的节点，即桶的头结点进行锁定，如果该节点的hash大于等于0，表示此桶是链表，然后对该桶进行遍历（死循环），寻找链表中与put的key的hash值相等，并且key相等的元素，然后进行值的替换，如果到链表尾部都没有符合条件的，就新建一个node，然后插入到该桶的尾部，并终止该循环遍历。</li><li>如果该节点的hash小于0，并且节点类型是TreeBin，则走红黑树的插入方式。</li><li>判断是否达到转化红黑树的阈值，如果达到阈值，则链表转化为红黑树。</li></ol><h1 id="分布式id生成方案有哪些？"><a href="#分布式id生成方案有哪些？" class="headerlink" title="分布式id生成方案有哪些？"></a>分布式id生成方案有哪些？</h1><p>UUID,数据库主键自增，Redis自增ID，雪花算法。</p><table><thead><tr><th></th><th>描述</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>UUID</td><td>UUID是通用唯一标识码的缩写，其目的是让分布式系统中的所有元素都有唯一的辨识信息，而不需要通过中央控制器来指定唯一标识。</td><td>1. 降低全局节点的压力，使得主键生成速度更快；<br/>2. 生成的主键全局唯一；<br/>3. 跨服务器合并数据方便。</td><td>1. UUID占用16个字符，空间占用较多；<br/>2. 不是递增有序的数字，数据写入IO随机性很大，且索引效率下降</td></tr><tr><td>数据库主键自增</td><td>MySQL数据库设置主键且主键自动增长</td><td>1. INT和BIGINT类型占用空间较小；<br/>2. 主键自动增长，IO写入连续性好；<br/>3. 数字类型查询速度优于字符串</td><td>1. 并发性能不高，受限于数据库性能；<br/>2. 分库分表，需要改造，复杂；<br/>3. 自增：数据和数据量泄露</td></tr><tr><td>Redis自增</td><td>Redis计数器，原子性自增</td><td>使用内存，并发性能好</td><td>1. 数据丢失；<br/>2. 自增：数据量泄露</td></tr><tr><td>雪花算法（snowflake）</td><td>大名鼎鼎的雪花算法，分布式ID的经典解决方案</td><td>1. 不依赖外部组件；<br/>2. 性能好</td><td>时钟回拨</td></tr></tbody></table><h1 id="雪花算法生成的ID由哪些部分组成"><a href="#雪花算法生成的ID由哪些部分组成" class="headerlink" title="雪花算法生成的ID由哪些部分组成?"></a>雪花算法生成的ID由哪些部分组成?</h1><ol><li>符号位，占用1位。</li><li>时间戳，占用41位，可以支持69年的时间跨度。</li><li>机器ID，占用10位。</li><li>序列号，占用12位。一毫秒可以生成4095个ID。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20210521124236027.png" alt="image-20210521124236027"></p><h1 id="分布式锁在项目中有哪些应用场景？"><a href="#分布式锁在项目中有哪些应用场景？" class="headerlink" title="分布式锁在项目中有哪些应用场景？"></a>分布式锁在项目中有哪些应用场景？</h1><p>使用分布式锁的场景一般需要满足以下场景：</p><ol><li>系统是一个分布式系统,集群集群，java的锁已经锁不住了。</li><li>操作共享资源，比如库里唯一的用户数据。</li><li>同步访问，即多个进程同时操作共享资源。</li></ol><h1 id="分布锁有哪些解决方案？"><a href="#分布锁有哪些解决方案？" class="headerlink" title="分布锁有哪些解决方案？"></a>分布锁有哪些解决方案？</h1><ol><li><p>Reids的分布式锁，很多大公司会基于Reidis做扩展开发。setnx key value ex 10s，Redisson。</p><p>watch dog.</p></li><li><p>基于Zookeeper。临时节点，顺序节点。</p></li><li><p>基于数据库，比如Mysql。主键或唯一索引的唯一性。</p></li></ol><h1 id="Redis做分布式锁用什么命令？"><a href="#Redis做分布式锁用什么命令？" class="headerlink" title="Redis做分布式锁用什么命令？"></a>Redis做分布式锁用什么命令？</h1><p>SETNX<br>格式：setnx key value 将 key 的值设为 value ，当且仅当 key 不存在。<br>若给定的 key 已经存在，则 SETNX 不做任何动作,操作失败。</p><p>SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。</p><p>加锁：set key value nx ex 10s</p><p>释放锁：delete key</p><h1 id="Redis做分布式锁死锁有哪些情况，如何解决？"><a href="#Redis做分布式锁死锁有哪些情况，如何解决？" class="headerlink" title="Redis做分布式锁死锁有哪些情况，如何解决？"></a>Redis做分布式锁死锁有哪些情况，如何解决？</h1><p>情况1：加锁，没有释放锁。需要加释放锁的操作。比如delete key。</p><p>情况2：加锁后，程序还没有执行释放锁，程序挂了。需要用的key的过期机制。</p><h1 id="Redis如何做分布式锁？"><a href="#Redis如何做分布式锁？" class="headerlink" title="Redis如何做分布式锁？"></a>Redis如何做分布式锁？</h1><p>假设有两个服务A、B都希望获得锁，执行过程大致如下:</p><p>Step1： 服务A为了获得锁，向Redis发起如下命令: SET productId:lock 0xx9p03001 NX EX 30000 其中，”productId”由自己定义，可以是与本次业务有关的id，”0xx9p03001”是一串随机值，必须保证全局唯一，“NX”指的是当且仅当key(也就是案例中的”productId:lock”)在Redis中不存在时，返回执行成功，否则执行失败。”EX 30000”指的是在30秒后，key将被自动删除。执行命令后返回成功，表明服务成功的获得了锁。</p><p>Step2: 服务B为了获得锁，向Redis发起同样的命令: SET productId:lock 0000111 NX  EX 30000<br>由于Redis内已经存在同名key，且并未过期，因此命令执行失败，服务B未能获得锁。服务B进入循环请求状态，比如每隔1秒钟(自行设置)向Redis发送请求，直到执行成功并获得锁。</p><p>Step3: 服务A的业务代码执行时长超过了30秒，导致key超时，因此Redis自动删除了key。此时服务B再次发送命令执行成功，假设本次请求中设置的value值为0000222。此时需要在服务A中对key进行续期，watch dog。</p><p>Step4: 服务A执行完毕，为了释放锁，服务A会主动向Redis发起删除key的请求。注意: 在删除key之前，一定要判断服务A持有的value与Redis内存储的value是否一致。比如当前场景下，Redis中的锁早就不是服务A持有的那一把了，而是由服务2创建，如果贸然使用服务A持有的key来删除锁，则会误将服务2的锁释放掉。此外，由于删除锁时涉及到一系列判断逻辑，因此一般使用lua脚本，具体如下:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">if redis.call(&quot;get&quot;, KEYS[<span class="number">1</span>])<span class="operator">=</span><span class="operator">=</span>ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line"><span class="keyword">return</span> redis.call(&quot;del&quot;, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="基于-ZooKeeper-的分布式锁实现原理是什么"><a href="#基于-ZooKeeper-的分布式锁实现原理是什么" class="headerlink" title="基于 ZooKeeper 的分布式锁实现原理是什么?"></a>基于 ZooKeeper 的分布式锁实现原理是什么?</h1><p>顺序节点特性：</p><p>使用 ZooKeeper 的顺序节点特性，假如我们在/lock/目录下创建3个节点，ZK集群会按照发起创建的顺序来创建节点，节点分别为/lock/0000000001、/lock/0000000002、/lock/0000000003，最后一位数是依次递增的，节点名由zk来完成。</p><p>临时节点特性：</p><p>ZK中还有一种名为临时节点的节点，临时节点由某个客户端创建，当客户端与ZK集群断开连接，则该节点自动被删除。EPHEMERAL_SEQUENTIAL为临时顺序节点。</p><p>根据ZK中节点是否存在，可以作为分布式锁的锁状态，以此来实现一个分布式锁，下面是分布式锁的基本逻辑：</p><ol><li>客户端1调用create()方法创建名为“/业务ID/lock-”的临时顺序节点。</li><li>客户端1调用getChildren(“业务ID”)方法来获取所有已经创建的子节点。</li><li>客户端获取到所有子节点path之后，如果发现自己在步骤1中创建的节点是所有节点中序号最小的，就是看自己创建的序列号是否排第一，如果是第一，那么就认为这个客户端1获得了锁，在它前面没有别的客户端拿到锁。</li><li>如果创建的节点不是所有节点中需要最小的，那么则监视比自己创建节点的序列号小的最大的节点，进入等待。直到下次监视的子节点变更的时候，再进行子节点的获取，判断是否获取锁。</li></ol><h1 id="ZooKeeper和Reids做分布式锁的区别？"><a href="#ZooKeeper和Reids做分布式锁的区别？" class="headerlink" title="ZooKeeper和Reids做分布式锁的区别？"></a>ZooKeeper和Reids做分布式锁的区别？</h1><p>Reids：</p><ol><li>Redis只保证最终一致性，副本间的数据复制是异步进行（Set是写，Get是读，Reids集群一般是读写分离架构，存在主从同步延迟情况），主从切换之后可能有部分数据没有复制过去可能会 <strong>「丢失锁」</strong> 情况，故强一致性要求的业务不推荐使用Reids，推荐使用zk。</li><li>Redis集群各方法的响应时间均为最低。随着并发量和业务数量的提升其响应时间会有明显上升（公网集群影响因素偏大），但是极限qps可以达到最大且基本无异常</li></ol><p>ZooKeeper：</p><ol><li>使用ZooKeeper集群，锁原理是使用ZooKeeper的临时顺序节点，临时顺序节点的生命周期在Client与集群的Session结束时结束。因此如果某个Client节点存在网络问题，与ZooKeeper集群断开连接，Session超时同样会导致锁被错误的释放（导致被其他线程错误地持有），因此ZooKeeper也无法保证完全一致。</li><li>ZK具有较好的稳定性；响应时间抖动很小，没有出现异常。但是随着并发量和业务数量的提升其响应时间和qps会明显下降。</li></ol><p>总结：</p><ol><li>Zookeeper每次进行锁操作前都要创建若干节点，完成后要释放节点，会浪费很多时间；</li><li>而Redis只是简单的数据操作，没有这个问题。</li></ol><h1 id="MySQL如何做分布式锁？"><a href="#MySQL如何做分布式锁？" class="headerlink" title="MySQL如何做分布式锁？"></a>MySQL如何做分布式锁？</h1><p>在Mysql中创建一张表，设置一个 主键或者UNIQUE KEY 这个 KEY 就是要锁的 KEY（商品ID），所以同一个 KEY 在mysql表里只能插入一次了，这样对锁的竞争就交给了数据库，处理同一个 KEY 数据库保证了只有一个节点能插入成功，其他节点都会插入失败。</p><p>DB分布式锁的实现：通过主键id 或者 唯一索性 的唯一性进行加锁，说白了就是加锁的形式是向一张表中插入一条数据，该条数据的id就是一把分布式锁，例如当一次请求插入了一条id为1的数据，其他想要进行插入数据的并发请求必须等第一次请求执行完成后删除这条id为1的数据才能继续插入，实现了分布式锁的功能。</p><p>这样 lock 和 unlock 的思路就很简单了，伪代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def lock ：</span><br><span class="line">    exec sql: insert into locked—table (xxx) values (xxx)</span><br><span class="line">    if result == true :</span><br><span class="line">        return true</span><br><span class="line">    else :</span><br><span class="line">        return false</span><br><span class="line"></span><br><span class="line">def unlock ：</span><br><span class="line">    exec sql: delete from lockedOrder where order_id=&#x27;order_id&#x27;</span><br></pre></td></tr></table></figure><h1 id="计数器算法是什么？"><a href="#计数器算法是什么？" class="headerlink" title="计数器算法是什么？"></a>计数器算法是什么？</h1><p>​        计数器算法，是指在指定的时间周期内累加访问次数，达到设定的阈值时，触发限流策略。下一个时间周期进行访问时，访问次数清零。此算法无论在单机还是分布式环境下实现都非常简单，使用redis的incr原子自增性，再结合key的过期时间，即可轻松实现。</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/4-6%20%E8%AE%A1%E6%95%B0%E5%99%A8%E7%AE%97%E6%B3%95-1621753094321.jpg" alt="4-6 计数器算法"></p><p>​        从上图我们来看，我们设置一分钟的阈值是100，在0:00到1:00内请求数是60，当到1:00时，请求数清零，从0开始计算，这时在1:00到2:00之间我们能处理的最大的请求为100，超过100个的请求，系统都拒绝。</p><p>​        这个算法有一个临界问题，比如在上图中，在0:00到1:00内，只在0:50有60个请求，而在1:00到2:00之间，只在1:10有60个请求，虽然在两个一分钟的时间内，都没有超过100个请求，但是在0:50到1:10这20秒内，确有120个请求，虽然在每个周期内，都没超过阈值，但是在这20秒内，已经远远超过了我们原来设置的1分钟内100个请求的阈值。</p><h1 id="滑动时间窗口算法是什么？"><a href="#滑动时间窗口算法是什么？" class="headerlink" title="滑动时间窗口算法是什么？"></a>滑动时间窗口算法是什么？</h1><p>​        为了解决计数器算法的临界值的问题，发明了滑动窗口算法。在TCP网络通信协议中，就采用滑动时间窗口算法来解决网络拥堵问题。</p><p>​        滑动时间窗口是将计数器算法中的实际周期切分成多个小的时间窗口，分别在每个小的时间窗口中记录访问次数，然后根据时间将窗口往前滑动并删除过期的小时间窗口。最终只需要统计滑动窗口范围内的小时间窗口的总的请求数即可。</p><p>![4-7 滑动窗口算法](../../../牛客网最新java面试八股文MD课件/最全MD请看-200题目和答案（xin）分布式+微服务+MYSQL+Redis+JVM+Spring等等/images/4-7 滑动窗口算法-1621753118270.jpg)</p><p>​        在上图中，假设我们设置一分钟的请求阈值是100，我们将一分钟拆分成4个小时间窗口，这样，每个小的时间窗口只能处理25个请求，我们用虚线方框表示滑动时间窗口，当前窗口的大小是2，也就是在窗口内最多能处理50个请求。随着时间的推移，滑动窗口也随着时间往前移动，比如上图开始时，窗口是0:00到0:30的这个范围，过了15秒后，窗口是0:15到0:45的这个范围，窗口中的请求重新清零，这样就很好的解决了计数器算法的临界值问题。</p><p>​        在滑动时间窗口算法中，我们的小窗口划分的越多，滑动窗口的滚动就越平滑，限流的统计就会越精确。</p><h1 id="漏桶限流算法是什么？"><a href="#漏桶限流算法是什么？" class="headerlink" title="漏桶限流算法是什么？"></a>漏桶限流算法是什么？</h1><p>​        漏桶算法的原理就像它的名字一样，我们维持一个漏斗，它有恒定的流出速度，不管水流流入的速度有多快，漏斗出水的速度始终保持不变，类似于消息中间件，不管消息的生产者请求量有多大，消息的处理能力取决于消费者。</p><p>​        漏桶的容量=漏桶的流出速度*可接受的等待时长。在这个容量范围内的请求可以排队等待系统的处理，超过这个容量的请求，才会被抛弃。</p><p>​        在漏桶限流算法中，存在下面几种情况：</p><ol><li><p>当请求速度大于漏桶的流出速度时，也就是请求量大于当前服务所能处理的最大极限值时，触发限流策略。</p></li><li><p>请求速度小于或等于漏桶的流出速度时，也就是服务的处理能力大于或等于请求量时，正常执行。</p><p>漏桶算法有一个缺点：当系统在短时间内有突发的大流量时，漏桶算法处理不了。</p></li></ol><h1 id="令牌桶限流算法是什么？"><a href="#令牌桶限流算法是什么？" class="headerlink" title="令牌桶限流算法是什么？"></a>令牌桶限流算法是什么？</h1><p>​        令牌桶算法，是增加一个大小固定的容器，也就是令牌桶，系统以恒定的速率向令牌桶中放入令牌，如果有客户端来请求，先需要从令牌桶中拿一个令牌，拿到令牌，才有资格访问系统，这时令牌桶中少一个令牌。当令牌桶满的时候，再向令牌桶生成令牌时，令牌会被抛弃。</p><p>​        在令牌桶算法中，存在以下几种情况：</p><ol><li><p>请求速度大于令牌的生成速度：那么令牌桶中的令牌会被取完，后续再进来的请求，由于拿不到令牌，会被限流。</p></li><li><p>请求速度等于令牌的生成速度：那么此时系统处于平稳状态。</p></li><li><p>请求速度小于令牌的生成速度：那么此时系统的访问量远远低于系统的并发能力，请求可以被正常处理。</p><p>令牌桶算法，由于有一个桶的存在，可以处理短时间大流量的场景。这是令牌桶和漏桶的一个区别。</p></li></ol><h1 id="你设计微服务时遵循什么原则？"><a href="#你设计微服务时遵循什么原则？" class="headerlink" title="你设计微服务时遵循什么原则？"></a>你设计微服务时遵循什么原则？</h1><ol><li>单一职责原则：让每个服务能独立，有界限的工作，每个服务只关注自己的业务。做到高内聚。</li><li>服务自治原则：每个服务要能做到独立开发、独立测试、独立构建、独立部署，独立运行。与其他服务进行解耦。</li><li>轻量级通信原则：让每个服务之间的调用是轻量级，并且能够跨平台、跨语言。比如采用RESTful风格，利用消息队列进行通信等。</li><li>粒度进化原则：对每个服务的粒度把控，其实没有统一的标准，这个得结合我们解决的具体业务问题。不要过度设计。服务的粒度随着业务和用户的发展而发展。</li></ol><p>​    总结一句话，软件是为业务服务的，好的系统不是设计出来的，而是进化出来的。</p><h1 id="CAP定理是什么？"><a href="#CAP定理是什么？" class="headerlink" title="CAP定理是什么？"></a>CAP定理是什么？</h1><p>​        CAP定理，又叫布鲁尔定理。指的是：在一个分布式系统中，最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。</p><ul><li><p>C：一致性（Consistency），数据在多个副本中保持一致，可以理解成两个用户访问两个系统A和B，当A系统数据有变化时，及时同步给B系统，让两个用户看到的数据是一致的。</p></li><li><p>A：可用性（Availability），系统对外提供服务必须一直处于可用状态，在任何故障下，客户端都能在合理时间内获得服务端非错误的响应。</p></li><li><p>P：分区容错性（Partition tolerance），在分布式系统中遇到任何网络分区故障，系统仍然能对外提供服务。网络分区，可以这样理解，在分布式系统中，不同的节点分布在不同的子网络中，有可能子网络中只有一个节点，在所有网络正常的情况下，由于某些原因导致这些子节点之间的网络出现故障，导致整个节点环境被切分成了不同的独立区域，这就是网络分区。</p><p>​    </p><p>我们来详细分析一下CAP，为什么只能满足两个。看下图所示：</p><p>![10-4 CAP演示](../../../牛客网最新java面试八股文MD课件/最全MD请看-200题目和答案（xin）分布式+微服务+MYSQL+Redis+JVM+Spring等等/images/10-4 CAP演示-1617721637028.jpg)</p><p>​        用户1和用户2分别访问系统A和系统B，系统A和系统B通过网络进行同步数据。理想情况是：用户1访问系统A对数据进行修改，将data1改成了data2，同时用户2访问系统B，拿到的是data2数据。</p><p>​        但是实际中，由于分布式系统具有八大谬论：</p><ul><li><p>网络相当可靠</p></li><li><p>延迟为零</p></li><li><p>传输带宽是无限的</p></li><li><p>网络相当安全</p></li><li><p>拓扑结构不会改变</p></li><li><p>必须要有一名管理员</p></li><li><p>传输成本为零</p></li><li><p>网络同质化</p></li></ul><p>我们知道，只要有网络调用，网络总是不可靠的。我们来一一分析。</p><ol><li>当网络发生故障时，系统A和系统B没法进行数据同步，也就是我们不满足P，同时两个系统依然可以访问，那么此时其实相当于是单机系统，就不是分布式系统了，所以既然我们是分布式系统，P必须满足。</li><li>当P满足时，如果用户1通过系统A对数据进行了修改将data1改成了data2，也要让用户2通过系统B正确的拿到data2，那么此时是满足C，就必须等待网络将系统A和系统B的数据同步好，并且在同步期间，任何人不能访问系统B（让系统不可用），否则数据就不是一致的。此时满足的是CP。</li><li>当P满足时，如果用户1通过系统A对数据进行了修改将data1改成了data2，也要让系统B能继续提供服务，那么此时，只能接受系统A没有将data2同步给系统B（牺牲了一致性）。此时满足的就是AP。</li></ol></li></ul><p>​        我们在前面学过的注册中心Eureka就是满足 的AP，它并不保证C。而Zookeeper是保证CP，它不保证A。在生产中，A和C的选择，没有正确的答案，是取决于自己的业务的。比如12306，是满足CP，因为买票必须满足数据的一致性，不然一个座位多卖了，对铁路运输都是不可以接受的。</p><h1 id="BASE理论是什么？"><a href="#BASE理论是什么？" class="headerlink" title="BASE理论是什么？"></a>BASE理论是什么？</h1><p>由于CAP中一致性C和可用性A无法兼得，eBay的架构师，提出了BASE理论，它是通过牺牲数据的强一致性，来获得可用性。它由于如下3种特征：</p><ul><li><p><strong>B</strong>asically <strong>A</strong>vailable（基本可用）：分布式系统在出现不可预知故障的时候，允许损失部分可用性，保证核心功能的可用。</p></li><li><p><strong>S</strong>oft state（软状态）：软状态也称为弱状态，和硬状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。、</p></li><li><p><strong>E</strong>ventually consistent（最终一致性）：最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p></li></ul><p>​        BASE理论并没有要求数据的强一致性，而是允许数据在一定的时间段内是不一致的，但在最终某个状态会达到一致。在生产环境中，很多公司，会采用BASE理论来实现数据的一致，因为产品的可用性相比强一致性来说，更加重要。比如在电商平台中，当用户对一个订单发起支付时，往往会调用第三方支付平台，比如支付宝支付或者微信支付，调用第三方成功后，第三方并不能及时通知我方系统，在第三方没有通知我方系统的这段时间内，我们给用户的订单状态显示支付中，等到第三方回调之后，我们再将状态改成已支付。虽然订单状态在短期内存在不一致，但是用户却获得了更好的产品体验。</p><h1 id="2PC提交协议是什么？"><a href="#2PC提交协议是什么？" class="headerlink" title="2PC提交协议是什么？"></a>2PC提交协议是什么？</h1><p>二阶段提交(Two-phaseCommit)是指，在计算机网络以及数据库领域内，为了使基于分布式系统架构下的所有节点在进行事务提交时保持一致性而设计的一种算法(Algorithm)。通常，二阶段提交也被称为是一种协议(Protocol))。在分布式系统中，每个节点虽然可以知晓自己的操作时成功或者失败，却无法知道其他节点的操作的成功或失败。当一个事务跨越多个节点时，为了保持事务的ACID特性，需要引入一个作为协调者的组件来统一掌控所有节点(称作参与者)的操作结果并最终指示这些节点是否要把操作结果进行真正的提交(比如将更新后的数据写入磁盘等等)。因此，<strong>二阶段提交的算法思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。</strong></p><p>所谓的两个阶段是指：第一阶段：<strong>准备阶段(投票阶段)<strong>和第二阶段：</strong>提交阶段（执行阶段）</strong>。</p><p>准备阶段</p><p>事务协调者(事务管理器)给每个参与者(资源管理器)发送Prepare消息，每个参与者要么直接返回失败(如权限验证失败)，要么在本地执行事务，写本地的redo和undo日志，但不提交，到达一种“万事俱备，只欠东风”的状态。</p><p>可以进一步将准备阶段分为以下三个步骤：</p><blockquote><p>1）协调者节点向所有参与者节点询问是否可以执行提交操作(vote)，并开始等待各参与者节点的响应。</p><p>2）参与者节点执行询问发起为止的所有事务操作，并将Undo信息和Redo信息写入日志。（注意：若成功这里其实每个参与者已经执行了事务操作）</p><p>3）各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个”同意”消息；如果参与者节点的事务操作实际执行失败，则它返回一个”中止”消息。</p></blockquote><p>提交阶段</p><blockquote><p>如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源)</p><p>接下来分两种情况分别讨论提交阶段的过程。</p><p>当协调者节点从所有参与者节点获得的相应消息都为”同意”时:</p><p><a href="http://www.hollischuang.com/wp-content/uploads/2015/12/success.png"><img src="../../../%E7%89%9B%E5%AE%A2%E7%BD%91%E6%9C%80%E6%96%B0java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87MD%E8%AF%BE%E4%BB%B6/%E6%9C%80%E5%85%A8MD%E8%AF%B7%E7%9C%8B-200%E9%A2%98%E7%9B%AE%E5%92%8C%E7%AD%94%E6%A1%88%EF%BC%88xin%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F+%E5%BE%AE%E6%9C%8D%E5%8A%A1+MYSQL+Redis+JVM+Spring%E7%AD%89%E7%AD%89/images/success.png" alt="success"></a></p><blockquote><p>1）协调者节点向所有参与者节点发出”正式提交(commit)”的请求。</p><p>2）参与者节点正式完成操作，并释放在整个事务期间内占用的资源。</p><p>3）参与者节点向协调者节点发送”完成”消息。</p><p>4）协调者节点受到所有参与者节点反馈的”完成”消息后，完成事务。</p></blockquote></blockquote><p>如果任一参与者节点在第一阶段返回的响应消息为”中止”，或者 协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时：</p><p><a href="http://www.hollischuang.com/wp-content/uploads/2015/12/fail.png"><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/fail.png" alt="fail"></a></p><blockquote><p>1）协调者节点向所有参与者节点发出”回滚操作(rollback)”的请求。</p><p>2）参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间内占用的资源。</p><p>3）参与者节点向协调者节点发送”回滚完成”消息。</p><p>4）协调者节点受到所有参与者节点反馈的”回滚完成”消息后，取消事务。</p></blockquote><p>　　不管最后结果如何，第二阶段都会结束当前事务。</p><h1 id="2PC提交协议有什么缺点？"><a href="#2PC提交协议有什么缺点？" class="headerlink" title="2PC提交协议有什么缺点？"></a>2PC提交协议有什么缺点？</h1><ol><li><p><strong>同步阻塞问题</strong>。执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。</p></li><li><p><strong>单点故障</strong>。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）</p></li><li><p><strong>数据不一致</strong>。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。</p></li><li><p>二阶段无法解决的问题：协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</p></li></ol><h1 id="3PC提交协议是什么？"><a href="#3PC提交协议是什么？" class="headerlink" title="3PC提交协议是什么？"></a>3PC提交协议是什么？</h1><p>CanCommit阶段</p><p>3PC的CanCommit阶段其实和2PC的准备阶段很像。协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应。</p><blockquote><p><strong>1.事务询问</strong> 协调者向参与者发送CanCommit请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。</p><p><strong>2.响应反馈</strong> 参与者接到CanCommit请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回Yes响应，并进入预备状态。否则反馈No</p></blockquote><p>PreCommit阶段</p><p>协调者根据参与者的反应情况来决定是否可以进行事务的PreCommit操作。根据响应情况，有以下两种可能。</p><p><strong>假如协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务的预执行。</strong></p><blockquote><p><strong>1.发送预提交请求</strong> 协调者向参与者发送PreCommit请求，并进入Prepared阶段。</p><p><strong>2.事务预提交</strong> 参与者接收到PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中。</p><p><strong>3.响应反馈</strong> 如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。</p></blockquote><p><strong>假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。</strong></p><blockquote><p><strong>1.发送中断请求</strong> 协调者向所有参与者发送abort请求。</p><p><strong>2.中断事务</strong> 参与者收到来自协调者的abort请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。</p></blockquote><p>pre阶段参与者没收到请求，rollback。</p><p>doCommit阶段</p><p>该阶段进行真正的事务提交，也可以分为以下两种情况。</p><p><strong>执行提交</strong></p><blockquote><p><strong>1.发送提交请求</strong> 协调接收到参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送doCommit请求。</p><p><strong>2.事务提交</strong> 参与者接收到doCommit请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。</p><p><strong>3.响应反馈</strong> 事务提交完之后，向协调者发送Ack响应。</p><p><strong>4.完成事务</strong> 协调者接收到所有参与者的ack响应之后，完成事务。</p></blockquote><p><strong>中断事务</strong> 协调者没有接收到参与者发送的ACK响应（可能是接受者发送的不是ACK响应，也可能响应超时），那么就会执行中断事务。</p><blockquote><p><strong>1.发送中断请求</strong> 协调者向所有参与者发送abort请求</p><p><strong>2.事务回滚</strong> 参与者接收到abort请求之后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。</p><p><strong>3.反馈结果</strong> 参与者完成事务回滚之后，向协调者发送ACK消息</p><p><strong>4.中断事务</strong> 协调者接收到参与者反馈的ACK消息之后，执行事务的中断。</p></blockquote><h1 id="2PC和3PC的区别是什么？"><a href="#2PC和3PC的区别是什么？" class="headerlink" title="2PC和3PC的区别是什么？"></a>2PC和3PC的区别是什么？</h1><p>1.3pc比2pc多了一个can commit阶段，减少了不必要的资源浪费。因为2pc在第一阶段会占用资源，而3pc在这个阶段不占用资源，只是校验一下sql，如果不能执行，就直接返回，减少了资源占用。</p><p>2.引入超时机制。同时在协调者和参与者中都引入超时机制。</p><p>2pc:只有协调者有超时机制，超时后，发送回滚指令。</p><p>3pc:协调者和参与者都有超时机制。</p><p>协调者超时: can commit，pre commit中，如果收不到参与者的反馈，则协调者向参与者发送中断指令。<br>参与者超时: pre commit阶段，参与者进行中断; do commit阶段，参与者进行提交。</p><ul><li><h1 id="TCC解决方案是什么"><a href="#TCC解决方案是什么" class="headerlink" title="TCC解决方案是什么?"></a>TCC解决方案是什么?</h1><p>​        TCC（Try-Confirm-Cancel）是一种常用的分布式事务解决方案，它将一个事务拆分成三个步骤：</p><ul><li><p>T（Try）：业务检查阶段，这阶段主要进行业务校验和检查或者资源预留；也可能是直接进行业务操作。</p></li><li><p>C（Confirm）：业务确认阶段，这阶段对Try阶段校验过的业务或者预留的资源进行确认。</p></li><li><p>C（Cancel）：业务回滚阶段，这阶段和上面的C（Confirm）是互斥的，用于释放Try阶段预留的资源或者业务。</p></li></ul><p><img src="../../../%E7%89%9B%E5%AE%A2%E7%BD%91%E6%9C%80%E6%96%B0java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87MD%E8%AF%BE%E4%BB%B6/%E6%9C%80%E5%85%A8MD%E8%AF%B7%E7%9C%8B-200%E9%A2%98%E7%9B%AE%E5%92%8C%E7%AD%94%E6%A1%88%EF%BC%88xin%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F+%E5%BE%AE%E6%9C%8D%E5%8A%A1+MYSQL+Redis+JVM+Spring%E7%AD%89%E7%AD%89/images/image-20210521230854476-1621753201509.png" alt="image-20210521230854476"></p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20210521230904203-1621753201509.png" alt="image-20210521230904203"></p><p><img src="../../../%E7%89%9B%E5%AE%A2%E7%BD%91%E6%9C%80%E6%96%B0java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87MD%E8%AF%BE%E4%BB%B6/%E6%9C%80%E5%85%A8MD%E8%AF%B7%E7%9C%8B-200%E9%A2%98%E7%9B%AE%E5%92%8C%E7%AD%94%E6%A1%88%EF%BC%88xin%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F+%E5%BE%AE%E6%9C%8D%E5%8A%A1+MYSQL+Redis+JVM+Spring%E7%AD%89%E7%AD%89/images/image-20210521230912365-1621753201509.png" alt="image-20210521230912365"></p><p><img src="../../../%E7%89%9B%E5%AE%A2%E7%BD%91%E6%9C%80%E6%96%B0java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87MD%E8%AF%BE%E4%BB%B6/%E6%9C%80%E5%85%A8MD%E8%AF%B7%E7%9C%8B-200%E9%A2%98%E7%9B%AE%E5%92%8C%E7%AD%94%E6%A1%88%EF%BC%88xin%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F+%E5%BE%AE%E6%9C%8D%E5%8A%A1+MYSQL+Redis+JVM+Spring%E7%AD%89%E7%AD%89/images/image-20210521230919795-1621753201509.png" alt="image-20210521230919795"></p></li></ul><h1 id="TCC空回滚是解决什么问题的？"><a href="#TCC空回滚是解决什么问题的？" class="headerlink" title="TCC空回滚是解决什么问题的？"></a>TCC空回滚是解决什么问题的？</h1><p>​        在没有调用TCC资源Try方法的情况下，调用了二阶段的Cancel方法。比如当Try请求由于网络延迟或故障等原因，没有执行，结果返回了异常，那么此时Cancel就不能正常执行，因为Try没有对数据进行修改，如果Cancel进行了对数据的修改，那就会导致数据不一致。<br>​        解决思路是关键就是要识别出这个空回滚。思路很简单就是需要知道Try阶段是否执行，如果执行了，那就是正常回滚；如果没执行，那就是空回滚。建议TM在发起全局事务时生成全局事务记录，全局事务ID贯穿整个分布式事务调用链条。再额外增加一张<strong>分支事务记录表</strong>，其中有全局事务ID和分支事务ID，第一阶段Try方法里会插入一条记录，表示Try阶段执行了。Cancel接口里读取该记录，如果该记录存在，则正常回滚；如果该记录不存在，则是空回滚。</p><h1 id="如何解决TCC幂等问题？"><a href="#如何解决TCC幂等问题？" class="headerlink" title="如何解决TCC幂等问题？"></a>如何解决TCC幂等问题？</h1><p>为了保证TCC二阶段提交重试机制不会引发数据不一致，要求TCC的二阶段Confirm和Cancel接口保证幂等，这样不会重复使用或者释放资源。如果幂等控制没有做好，很有可能导致数据不一致等严重问题。<br>解决思路在上述 <strong>分支事务记录</strong>中增加执行状态，每次执行前都查询该状态。</p><p>分布式锁。</p><h1 id="如何解决TCC中悬挂问题？"><a href="#如何解决TCC中悬挂问题？" class="headerlink" title="如何解决TCC中悬挂问题？"></a>如何解决TCC中悬挂问题？</h1><p>悬挂就是对于一个分布式事务，其二阶段Cancel接口比Try接口先执行。<br>        出现原因是在调用分支事务Try时，由于网络发生拥堵，造成了超时，TM就会通知RM回滚该分布式事务，可能回滚完成后，Try请求才到达参与者真正执行，而一个Try方法预留的业务资源，只有该分布式事务才能使用，该分布式事务第一阶段预留的业务资源就再也没有人能够处理了，对于这种情况，我们就称为悬挂，即业务资源预留后无法继续处理。<br>        解决思路是如果二阶段执行完成，那一阶段就不能再继续执行。在执行一阶段事务时判断在该全局事务下，判断<strong>分支事务记录表</strong>中是否已经有二阶段事务记录，如果有则不执行Try。</p><h1 id="可靠消息服务方案是什么？"><a href="#可靠消息服务方案是什么？" class="headerlink" title="可靠消息服务方案是什么？"></a>可靠消息服务方案是什么？</h1><p>​        可靠消息最终一致性方案指的是：当事务的发起方（事务参与者，消息发送者）执行完本地事务后，同时发出一条消息，事务参与方（事务参与者，消息的消费者）一定能够接受消息并可以成功处理自己的事务。</p><p>​        这里面强调两点：</p><ol><li>可靠消息：发起方一定得把消息传递到消费者。</li><li>最终一致性：最终发起方的业务处理和消费方的业务处理得完成，达成最终一致。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20210522125830646.png" alt="image-20210522125830646"></p><h1 id="最大努力通知方案的关键是什么？"><a href="#最大努力通知方案的关键是什么？" class="headerlink" title="最大努力通知方案的关键是什么？"></a>最大努力通知方案的关键是什么？</h1><ol><li> 有一定的消息重复通知机制。因为接收通知方（上图中的我方支付系统）可能没有接收到通知，此时要有一定的机制对消息重复通知。</li><li> 消息校对机制。如果尽最大努力也没有通知到接收方，或者接收方消费消息后要再次消费，此时可由接收方主动向通知方查询消息信息来满足需求。</li></ol><h1 id="什么是分布式系统中的幂等？"><a href="#什么是分布式系统中的幂等？" class="headerlink" title="什么是分布式系统中的幂等？"></a>什么是分布式系统中的幂等？</h1><p>幂等（idempotent、idempotence）是一个数学与计算机学概念，常见于抽象代数中。</p><p>在编程中，一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。</p><p>例如，“getUsername()和 setTrue()”函数就是一个幂等函数. 更复杂的操作幂等保证是利用唯一交易号(流水号)实现. 我的理解：幂等就是一个操作，不论执行多少次，产生的效果和返回的结果都是一样的。</p><p>操作：查询，set固定值。逻辑删除。set 固定值。</p><p>流程：分布式系统中，网络调用，重试机制。</p><h1 id="幂等有哪些技术解决方案？"><a href="#幂等有哪些技术解决方案？" class="headerlink" title="幂等有哪些技术解决方案？"></a>幂等有哪些技术解决方案？</h1><p>1.查询操作</p><p>查询一次和查询多次，在数据不变的情况下，查询结果是一样的。select 是天然的幂等操作；</p><p>2.删除操作</p><p>删除操作也是幂等的，删除一次和多次删除都是把数据删除。(注意可能返回结果不一样，删除的数据不存在，返回 0，删除的数据多条，返回结果多个。</p><p>3.唯一索引</p><p>防止新增脏数据。比如：支付宝的资金账户，支付宝也有用户账户，每个用户只能有一个资金账户，怎么防止给用户创建多个资金账户，那么给资金账户表中的用户 ID 加唯一索引，所以一个用户新增成功一个资金账户记录。要点：唯一索引或唯一组合索引来防止新增数据存在脏数据（当表存在唯一索引，并发时新增报错时，再查询一次就可以了，数据应该已经存在了，返回结果即可。</p><p>4.token 机制</p><p>防止页面重复提交。</p><p><strong>业务要求：</strong>页面的数据只能被点击提交一次；</p><p><strong>发生原因：</strong>由于重复点击或者网络重发，或者 nginx 重发等情况会导致数据被重复提交；</p><p><strong>解决办法：</strong>集群环境采用 token 加 redis(redis 单线程的，处理需要排队)；单 JVM 环境：采用 token 加 redis 或 token 加 jvm 锁。</p><p><strong>处理流程：</strong></p><ol><li>数据提交前要向服务的申请 token，token 放到 redis 或 jvm 内存，token 有效时间；</li><li>提交后后台校验 token，同时删除 token，生成新的 token 返回。</li></ol><p><strong>token 特点：</strong>要申请，一次有效性，可以限流。</p><p>注意：redis 要用删除操作来判断 token，删除成功代表 token 校验通过。</p><ol start="5"><li><p>traceId</p><p>操作时唯一的。</p></li></ol><h1 id="对外提供的API如何保证幂等？"><a href="#对外提供的API如何保证幂等？" class="headerlink" title="对外提供的API如何保证幂等？"></a>对外提供的API如何保证幂等？</h1><p>举例说明： 银联提供的付款接口：需要接入商户提交付款请求时附带：source 来源，seq 序列号。</p><p>source+seq 在数据库里面做唯一索引，防止多次付款(并发时，只能处理一个请求) 。重点：对外提供接口为了支持幂等调用，接口有两个字段必须传，一个是来源 source，一个是来源方序列号 seq，这个两个字段在提供方系统里面做联合唯一索引，这样当第三方调用时，先在本方系统里面查询一下，是否已经处理过，返回相应处理结果；没有处理过，进行相应处理，返回结果。</p><p>注意，为了幂等友好，一定要先查询一下，是否处理过该笔业务，不查询直接插入业务系统，会报错，但实际已经处理。</p><h1 id="双写一致性问题如何解决？"><a href="#双写一致性问题如何解决？" class="headerlink" title="双写一致性问题如何解决？"></a>双写一致性问题如何解决？</h1><p>先做一个说明，从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。这种方案下，我们可以对存入缓存的数据设置过期时间，所有的写操作以数据库为准，对缓存操作只是尽最大努力更新即可。也就是说如果数据库写成功，缓存更新失败，那么只要到达过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。因此，接下来讨论的思路不依赖于给缓存设置过期时间这个方案。<br>在这里，我们讨论<strong>三种</strong>更新策略：</p><ol><li>先更新缓存，再更新数据库。（不可取）</li><li>先更新数据库，再更新缓存。（不可取）</li><li>先删除缓存，再更新数据库。（不可取）</li><li>先更新数据库，再删除缓存。（可取，有问题待解决）</li></ol><h3 id="大前提："><a href="#大前提：" class="headerlink" title="大前提："></a>大前提：</h3><p>先读缓存，如果缓存没有，才从数据库读取。</p><h3 id="1-先更新数据库，再更新缓存"><a href="#1-先更新数据库，再更新缓存" class="headerlink" title="(1)先更新数据库，再更新缓存"></a>(1)先更新数据库，再更新缓存</h3><p>这套方案，大家是普遍反对的。为什么呢？有如下两点原因。<br><strong>原因一（线程安全角度）</strong><br>同时有请求A和请求B进行更新操作，那么会出现<br>（1）线程A更新了数据库<br>（2）线程B更新了数据库<br>（3）线程B更新了缓存<br>（4）线程A更新了缓存<br>这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑。<br><strong>原因二（业务场景角度）</strong><br>有如下两点：<br>（1）如果你是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能。<br>（2）如果你写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是浪费性能的。显然，删除缓存更为适合。</p><p>接下来讨论的就是争议最大的，先删缓存，再更新数据库。还是先更新数据库，再删缓存的问题。</p><h3 id="2-先删缓存，再更新数据库"><a href="#2-先删缓存，再更新数据库" class="headerlink" title="(2)先删缓存，再更新数据库"></a>(2)先删缓存，再更新数据库</h3><p>该方案会导致不一致的原因是。同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:<br>（1）请求A进行写操作，删除缓存<br>（2）请求B查询发现缓存不存在<br>（3）请求B去数据库查询得到旧值<br>（4）请求B将旧值写入缓存<br>（5）请求A将新值写入数据库<br>上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。<br>那么，<strong>如何解决呢？采用延时双删策略</strong></p><p>（1）先淘汰缓存<br>（2）再写数据库（这两步和原来一样）<br>（3）休眠1秒，再次淘汰缓存<br>这么做，可以将1秒内所造成的缓存脏数据，再次删除。<br><strong>那么，这个1秒怎么确定的，具体该休眠多久呢？</strong><br>针对上面的情形，读者应该自行评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。<br><strong>如果你用了mysql的读写分离架构怎么办？</strong><br>ok，在这种情况下，造成数据不一致的原因如下，还是两个请求，一个请求A进行更新操作，另一个请求B进行查询操作。<br>（1）请求A进行写操作，删除缓存<br>（2）请求A将数据写入数据库了，<br>（3）请求B查询缓存发现，缓存没有值<br>（4）请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值<br>（5）请求B将旧值写入缓存<br>（6）数据库完成主从同步，从库变为新值<br>上述情形，就是数据不一致的原因。还是使用双删延时策略。只是，睡眠时间修改为在主从同步的延时时间基础上，加几百ms。<br><strong>采用这种同步淘汰策略，吞吐量降低怎么办？</strong><br>ok，那就将第二次删除作为异步的。自己起一个线程，异步删除。这样，写的请求就不用沉睡一段时间后了，再返回。这么做，加大吞吐量。<br><strong>第二次删除,如果删除失败怎么办？</strong><br>这是个非常好的问题，因为第二次删除失败，就会出现如下情形。还是有两个请求，一个请求A进行更新操作，另一个请求B进行查询操作，为了方便，假设是单库：<br>（1）请求A进行写操作，删除缓存<br>（2）请求B查询发现缓存不存在<br>（3）请求B去数据库查询得到旧值<br>（4）请求B将旧值写入缓存<br>（5）请求A将新值写入数据库<br>（6）请求A试图去删除，请求B写入对的缓存值，结果失败了。<br>ok,这也就是说。如果第二次删除缓存失败，会再次出现缓存和数据库不一致的问题。<br><strong>如何解决呢？</strong></p><h3 id="3-先更新数据库，再删缓存"><a href="#3-先更新数据库，再删缓存" class="headerlink" title="(3)先更新数据库，再删缓存"></a>(3)先更新数据库，再删缓存</h3><p>首先，先说一下。老外提出了一个缓存更新套路，名为<a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside">《Cache-Aside pattern》</a>。其中就指出</p><ul><li><strong>失效</strong>：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</li><li><strong>命中</strong>：应用程序从cache中取数据，取到后返回。</li><li><strong>更新</strong>：先把数据存到数据库中，成功后，再让缓存失效。</li></ul><p>另外，知名社交网站facebook也在论文<a href="https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final170_update.pdf">《Scaling Memcache at Facebook》</a>中提出，他们用的也是先更新数据库，再删缓存的策略。<br><strong>这种情况不存在并发问题么？</strong><br>不是的。假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生<br>（1）缓存刚好失效<br>（2）请求A查询数据库，得一个旧值<br>（3）请求B将新值写入数据库<br>（4）请求B删除缓存<br>（5）请求A将查到的旧值写入缓存<br>ok，如果发生上述情况，确实是会发生脏数据。<br><strong>然而，发生这种情况的概率又有多少呢？</strong><br>发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。可是，大家想想，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。<br>假设，有人非要抬杠，有强迫症，一定要解决怎么办？<br><strong>如何解决上述并发问题？</strong><br>首先，给缓存设有效时间是一种方案。其次，采用策略（2）里给出的异步延时删除策略，保证读请求完成以后，再进行删除操作。<br><strong>还有其他造成不一致的原因么？</strong><br>有的，这也是缓存更新策略（2）和缓存更新策略（3）都存在的一个问题，如果删缓存失败了怎么办，那不是会有不一致的情况出现么。比如一个写数据请求，然后写入数据库了，删缓存失败了，这会就出现不一致的情况了。这也是缓存更新策略（2）里留下的最后一个疑问。<br><strong>如何解决？</strong><br>提供一个保障的重试机制即可，这里给出两套方案。<br><strong>方案一</strong>：<br>如下图所示<br><img src="../../../%E7%89%9B%E5%AE%A2%E7%BD%91%E6%9C%80%E6%96%B0java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87MD%E8%AF%BE%E4%BB%B6/%E6%9C%80%E5%85%A8MD%E8%AF%B7%E7%9C%8B-200%E9%A2%98%E7%9B%AE%E5%92%8C%E7%AD%94%E6%A1%88%EF%BC%88xin%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F+%E5%BE%AE%E6%9C%8D%E5%8A%A1+MYSQL+Redis+JVM+Spring%E7%AD%89%E7%AD%89/images/o_update1.png" alt="image"><br>流程如下所示<br>（1）更新数据库数据；<br>（2）缓存因为种种问题删除失败<br>（3）将需要删除的key发送至消息队列<br>（4）自己消费消息，获得需要删除的key<br>（5）继续重试删除操作，直到成功<br>然而，该方案有一个缺点，对业务线代码造成大量的侵入。于是有了方案二，在方案二中，启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作。<br><strong>方案二</strong>：<br><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/o_update2.png" alt="image"><br>流程如下图所示：<br>（1）更新数据库数据<br>（2）数据库会将操作信息写入binlog日志当中<br>（3）订阅程序提取出所需要的数据以及key<br>（4）另起一段非业务代码，获得该信息<br>（5）尝试删除缓存操作，发现删除失败<br>（6）将这些信息发送至消息队列<br>（7)重新从消息队列中获得该数据，重试操作。</p><p><strong>备注说明：</strong>上述的订阅binlog程序在mysql中有现成的中间件叫canal，可以完成订阅binlog日志的功能。至于oracle中，博主目前不知道有没有现成中间件可以使用。另外，重试机制，博主是采用的是消息队列的方式。如果对一致性要求不是很高，直接在程序中另起一个线程，每隔一段时间去重试即可，这些大家可以灵活自由发挥，只是提供一个思路。</p><h1 id="分布式微服务项目你是如何设计的？"><a href="#分布式微服务项目你是如何设计的？" class="headerlink" title="分布式微服务项目你是如何设计的？"></a>分布式微服务项目你是如何设计的？</h1><p>我一般设计成两层：业务层和能力层（中台），业务层接受用户请求，然后通过调用能力层来完成业务逻辑。</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20210522172654370.png" alt="image-20210522172654370"></p><h1 id="认证-Authentication-和授权-Authorization-的区别是什么？"><a href="#认证-Authentication-和授权-Authorization-的区别是什么？" class="headerlink" title="认证 (Authentication) 和授权 (Authorization)的区别是什么？"></a>认证 (Authentication) 和授权 (Authorization)的区别是什么？</h1><p>Authentication（认证） 是验证您的身份的凭据（例如用户名/用户ID和密码），通过这个凭据，系统得以知道你就是你，也就是说系统存在你这个用户。所以，Authentication 被称为身份/用户验证。<br>Authorization（授权） 发生在 Authentication（认证） 之后。授权，它主要掌管我们访问系统的权限。比如有些特定资源只能具有特定权限的人才能访问比如admin，有些对系统资源操作比如删除、添加、更新只能特定人才具有。<br>这两个一般在我们的系统中被结合在一起使用，目的就是为了保护我们系统的安全性。</p><h1 id="Cookie-和-Session-有什么区别？如何使用Session进行身份验证？"><a href="#Cookie-和-Session-有什么区别？如何使用Session进行身份验证？" class="headerlink" title="Cookie 和 Session 有什么区别？如何使用Session进行身份验证？"></a>Cookie 和 Session 有什么区别？如何使用Session进行身份验证？</h1><p>Session 的主要作用就是通过服务端记录用户的状态。 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p><p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。相对来说 Session 安全性更高。如果使用 Cookie 的一些敏感信息不要写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p><p>那么，如何使用Session进行身份验证？</p><p>很多时候我们都是通过 SessionID 来实现特定的用户，SessionID 一般会选择存放在 Redis 中。举个例子：用户成功登陆系统，然后返回给客户端具有 SessionID 的 Cookie，当用户向后端发起请求的时候会把 SessionID 带上，这样后端就知道你的身份状态了。关于这种认证方式更详细的过程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20210520130119426.png" alt="image-20210520130119426"></p><p>用户向服务器发送用户名和密码用于登陆系统。<br>服务器验证通过后，服务器为用户创建一个 Session，并将 Session信息存储 起来。<br>服务器向用户返回一个 SessionID，写入用户的 Cookie。<br>当用户保持登录状态时，Cookie 将与每个后续请求一起被发送出去。<br>服务器可以将存储在 Cookie 上的 Session ID 与存储在内存中或者数据库中的 Session 信息进行比较，以验证用户的身份，返回给用户客户端响应信息的时候会附带用户当前的状态。<br>使用 Session 的时候需要注意下面几个点：</p><p>依赖Session的关键业务一定要确保客户端开启了Cookie。<br>注意Session的过期时间</p><h1 id="为什么Cookie-无法防止CSRF攻击，而token可以？"><a href="#为什么Cookie-无法防止CSRF攻击，而token可以？" class="headerlink" title="为什么Cookie 无法防止CSRF攻击，而token可以？"></a>为什么Cookie 无法防止CSRF攻击，而token可以？</h1><p><strong>CSRF（Cross Site Request Forgery）</strong>一般被翻译为 跨站请求伪造 。那么什么是 跨站请求伪造 呢？说简单用你的身份去发送一些对你不友好的请求。举个简单的例子：</p><p>小壮登录了某网上银行，他来到了网上银行的帖子区，看到一个帖子下面有一个链接写着“科学理财，年盈利率过万”，小壮好奇的点开了这个链接，结果发现自己的账户少了10000元。这是这么回事呢？原来黑客在链接中藏了一个请求，这个请求直接利用小壮的身份给银行发送了一个转账请求,也就是通过你的 Cookie 向银行发出请求。</p><p>&lt;a src=<a href="http://www.mybank.com/Transfer?bankId=11&amp;money=10000&gt;%E7%A7%91%E5%AD%A6%E7%90%86%E8%B4%A2%EF%BC%8C%E5%B9%B4%E7%9B%88%E5%88%A9%E7%8E%87%E8%BF%87%E4%B8%87">http://www.mybank.com/Transfer?bankId=11&amp;money=10000&gt;科学理财，年盈利率过万</a>&lt;/&gt;<br>进行Session 认证的时候，我们一般使用 Cookie 来存储 SessionId,当我们登陆后后端生成一个SessionId放在Cookie中返回给客户端，服务端通过Redis或者其他存储工具记录保存着这个Sessionid，客户端登录以后每次请求都会带上这个SessionId，服务端通过这个SessionId来标示你这个人。如果别人通过 cookie拿到了 SessionId 后就可以代替你的身份访问系统了。</p><p>Session 认证中 Cookie 中的 SessionId是由浏览器发送到服务端的，借助这个特性，攻击者就可以通过让用户误点攻击链接，达到攻击效果。</p><p>但是，我们使用 token 的话就不会存在这个问题，在我们登录成功获得 token 之后，一般会选择存放在 local storage 中。然后我们在前端通过某些方式会给每个发到后端的请求加上这个 token,这样就不会出现 CSRF 漏洞的问题。因为，即使有个你点击了非法链接发送了请求到服务端，这个非法请求是不会携带 token 的，所以这个请求将是非法的。</p><h1 id="什么是-Token-什么是-JWT-如何基于Token进行身份验证？"><a href="#什么是-Token-什么是-JWT-如何基于Token进行身份验证？" class="headerlink" title="什么是 Token?什么是 JWT?如何基于Token进行身份验证？"></a>什么是 Token?什么是 JWT?如何基于Token进行身份验证？</h1><p>我们知道 Session 信息需要保存一份在服务器端。这种方式会带来一些麻烦，比如需要我们保证保存 Session 信息服务器的可用性、不适合移动端（依赖Cookie）等等。</p><p>有没有一种不需要自己存放 Session 信息就能实现身份验证的方式呢？使用 Token 即可！JWT （JSON Web Token） 就是这种方式的实现，通过这种方式服务器端就不需要保存 Session 数据了，只用在客户端保存服务端返回给客户的 Token 就可以了，扩展性得到提升。</p><p>JWT 本质上就一段签名的 JSON 格式的数据。由于它是带有签名的，因此接收者便可以验证它的真实性。</p><p>下面是 RFC 7519 对 JWT 做的较为正式的定义。</p><p>JSON Web Token (JWT) is a compact, URL-safe means of representing claims to be transferred between two parties. The claims in a JWT are encoded as a JSON object that is used as the payload of a JSON Web Signature (JWS) structure or as the plaintext of a JSON Web Encryption (JWE) structure, enabling the claims to be digitally signed or integrity protected with a Message Authentication Code (MAC) and/or encrypted. ——JSON Web Token (JWT)</p><p>JWT 由 3 部分构成:</p><p>Header :描述 JWT 的元数据。定义了生成签名的算法以及 Token 的类型。<br>Payload（负载）:用来存放实际需要传递的数据<br>Signature（签名）：服务器通过Payload、Header和一个密钥(secret)使用 Header 里面指定的签名算法（默认是 HMAC SHA256）生成。<br>在基于 Token 进行身份验证的的应用程序中，服务器通过Payload、Header和一个密钥(secret)创建令牌（Token）并将 Token 发送给客户端，客户端将 Token 保存在 Cookie 或者 localStorage 里面，以后客户端发出的所有请求都会携带这个令牌。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP Header 的 Authorization字段中：Authorization: Bearer Token。</p><p><img src="../../../%E7%89%9B%E5%AE%A2%E7%BD%91%E6%9C%80%E6%96%B0java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87MD%E8%AF%BE%E4%BB%B6/%E6%9C%80%E5%85%A8MD%E8%AF%B7%E7%9C%8B-200%E9%A2%98%E7%9B%AE%E5%92%8C%E7%AD%94%E6%A1%88%EF%BC%88xin%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F+%E5%BE%AE%E6%9C%8D%E5%8A%A1+MYSQL+Redis+JVM+Spring%E7%AD%89%E7%AD%89/images/image-20210520130410868.png" alt="image-20210520130410868"></p><p>用户向服务器发送用户名和密码用于登陆系统。<br>身份验证服务响应并返回了签名的 JWT，上面包含了用户是谁的内容。<br>用户以后每次向后端发请求都在Header中带上 JWT。<br>服务端检查 JWT 并从中获取用户相关信息。</p><h1 id="分布式架构下，Session-共享有什么方案"><a href="#分布式架构下，Session-共享有什么方案" class="headerlink" title="分布式架构下，Session 共享有什么方案?"></a>分布式架构下，Session 共享有什么方案?</h1><ol><li>不要有session：但是确实在某些场景下，是可以没有session的，其实在很多接口类系统当中，都提倡【API无状态服务】；也就是每一次的接口访问，都不依赖于session、不依赖于前一次的接口访问；</li><li>存入cookie中：将session存储到cookie中，但是缺点也很明显，例如每次请求都得带着session，数据存储在客户端本地，是有风险的；</li><li>session同步：对个服务器之间同步session，这样可以保证每个服务器上都有全部的session信息，不过当服务器数量比较多的时候，同步是会有延迟甚至同步失败；</li><li>使用Nginx（或其他复杂均衡软硬件）中的ip绑定策略，同一个ip只能在指定的同一个机器访问，但是这样做风险也比较大，而且也是去了负载均衡的意义；</li><li>我们现在的系统会把session放到Redis中存储，虽然架构上变得复杂，并且需要多访问一次Redis，但是这种方案带来的好处也是很大的：实现session共享，可以水平扩展（增加Redis服务器），服务器重启session不丢失（不过也要注意session在Redis中的刷新/失效机制），不仅可以跨服务器session共享，甚至可以跨平台（例如网页端和APP端）。</li></ol><h1 id="springcloud核心组件有哪些？"><a href="#springcloud核心组件有哪些？" class="headerlink" title="springcloud核心组件有哪些？"></a>springcloud核心组件有哪些？</h1><p>服务注册与发现——Netflix Eureka、Nacos、Zookeeper</p><p>客户端负载均衡——Netflix Ribbon、SpringCloud LoadBalancer</p><p>服务熔断器——Netflix Hystrix、Alibaba Sentinel、Resilience4J</p><p>服务网关——Netflix Zuul、SpringCloud Gateway</p><p>服务接口调用——Netflix Feign、 Resttemplate、Openfeign</p><p>链路追踪——Netflix Sleuth、Skywalking、Pinpoint</p><p>聚合Hystrix监控数据——Netflix Turbine</p><p>监控中心—- SpringBoot Admin</p><p>配置中心——Spring Cloud Config 、Apollo、nacos</p><h1 id="微服务架构原理是什么？"><a href="#微服务架构原理是什么？" class="headerlink" title="微服务架构原理是什么？"></a>微服务架构原理是什么？</h1><p>主要是面向SOA理念，更细小粒度服务的拆分，将功能分解到各个服务当中，从而降低系统的耦合性，并提供更加灵活的服务支持。</p><h1 id="注册中心的原理是什么？"><a href="#注册中心的原理是什么？" class="headerlink" title="注册中心的原理是什么？"></a>注册中心的原理是什么？</h1><p>服务启动后向Eureka注册，Eureka Server会将注册信息向其他Eureka Server进行同步，当服务消费者要调用服务提供者，则向服务注册中心获取服务提供者地址，然后会将服务提供者地址缓存在本地，下次再调用时，则直接从本地缓存中取，完成一次调用</p><h1 id="配置中心的原理是什么？"><a href="#配置中心的原理是什么？" class="headerlink" title="配置中心的原理是什么？"></a>配置中心的原理是什么？</h1><p>在服务运行之前，将所需的配置信息从配置仓库拉取到本地服务，达到统一化配置管理的目的</p><h1 id="配置中心是如何实现自动刷新的？"><a href="#配置中心是如何实现自动刷新的？" class="headerlink" title="配置中心是如何实现自动刷新的？"></a>配置中心是如何实现自动刷新的？</h1><ol><li><p>配置中心Server端承担起配置刷新的职责</p></li><li><p>提交配置触发post请求给server端的bus/refresh接口</p></li><li><p>server端接收到请求并发送给Spring Cloud Bus总线</p></li><li><p>Spring Cloud bus接到消息并通知给其它连接到总线的客户端</p></li><li><p>其它客户端接收到通知，请求Server端获取最新配置</p></li><li><p>全部客户端均获取到最新的配置</p></li></ol><h1 id="配置中心是如何保证数据安全的"><a href="#配置中心是如何保证数据安全的" class="headerlink" title="配置中心是如何保证数据安全的?"></a>配置中心是如何保证数据安全的?</h1><p>1.保证容器文件访问的安全性，即保证所有的网络资源请求都需要登录</p><p>2.将配置中心里所有配置文件中的密码进行加密，保证其密文性</p><p>3.开发环境禁止拉取生产环境的配置文件</p><h1 id="用zookeeper和eureka做注册中心有什么区别"><a href="#用zookeeper和eureka做注册中心有什么区别" class="headerlink" title="用zookeeper和eureka做注册中心有什么区别?"></a>用zookeeper和eureka做注册中心有什么区别?</h1><p>Zookeeper保证的是CP（一致性，容错性）, 而Eureka则是AP（可用性，容错性）。</p><h1 id="Spring-Cloud和Dubbo有哪些区别"><a href="#Spring-Cloud和Dubbo有哪些区别" class="headerlink" title="Spring Cloud和Dubbo有哪些区别?"></a>Spring Cloud和Dubbo有哪些区别?</h1><ol><li>dubbo 是二进制传输，对象直接转成二进制，使用RPC通信。</li></ol><p>SpringCloud是http 传输，同时使用http协议一般会使用JSON报文，json再转二进制，消耗会更大。</p><ol start="2"><li>Dubbo只是实现了服务治理，而Spring Cloud下面有几十个子项目分别覆盖了微服务架构下的方方面面，服务治理只是其中的一个方面，一定程度来说，Dubbo只是Spring Cloud Netflix中的一个子集。</li></ol><h1 id="Ribbon负载均衡原理是什么"><a href="#Ribbon负载均衡原理是什么" class="headerlink" title="Ribbon负载均衡原理是什么?"></a>Ribbon负载均衡原理是什么?</h1><ol><li><p>Ribbon通过ILoadBalancer接口对外提供统一的选择服务器(Server)的功能，此接口会根据不同的负载均衡策略(IRule)选择合适的Server返回给使用者。</p></li><li><p>IRule是负载均衡策略的抽象，ILoadBalancer通过调用IRule的choose()方法返回Server</p></li><li><p>IPing用来检测Server是否可用，ILoadBalancer的实现类维护一个Timer每隔10s检测一次Server的可用状态</p></li><li><p>IClientConfig主要定义了用于初始化各种客户端和负载均衡器的配置信息，器实现类为DefaultClientConfigImpl</p></li></ol><h1 id="微服务熔断降级机制是什么"><a href="#微服务熔断降级机制是什么" class="headerlink" title="微服务熔断降级机制是什么?"></a>微服务熔断降级机制是什么?</h1><p>微服务框架是许多服务互相调用的，要是不做任何保护的话，某一个服务挂了，就会引起连锁反应，导致别的服务也挂。Hystrix 是隔离、熔断以及降级的一个框架。如果调用某服务报错（或者挂了），就对该服务熔断，在 5 分钟内请求此服务直接就返回一个默认值，不需要每次都卡几秒，这个过程，就是所谓的熔断。但是熔断了之后就会少调用一个服务，此时需要做下标记，标记本来需要做什么业务，但是因为服务挂了，暂时没有做，等该服务恢复了，就可以手工处理这些业务。这个过程，就是所谓的降级。</p><h1 id="什么是Hystrix？实现原理是什么"><a href="#什么是Hystrix？实现原理是什么" class="headerlink" title="什么是Hystrix？实现原理是什么?"></a>什么是Hystrix？实现原理是什么?</h1><p>Hystrix是一个延迟和容错库，旨在隔离对远程系统、服务和第三方库的访问点，停止级联故障，并在 不可避免发生故障的复杂分布式系统中实现快速恢复。主要靠Spring的AOP实现</p><p> 实现原理</p><p>正常情况下，断路器关闭，服务消费者正常请求微服务</p><p>一段事件内，失败率达到一定阈值，断路器将断开，此时不再请求服务提供者，而是只是快速失败的方法（断路方法）</p><p> 断路器打开一段时间，自动进入“半开”状态，此时，断路器可允许一个请求方法服务提供者，如果请求调用成功，则关闭断路器，否则继续保持断路器打开状态。</p><p> 断路器hystrix是保证了局部发生的错误，不会扩展到整个系统，从而保证系统的即使出现局部问题也不会造成系统雪崩</p><h1 id="注册中心挂了，或者服务挂了，应该如何处理"><a href="#注册中心挂了，或者服务挂了，应该如何处理" class="headerlink" title="注册中心挂了，或者服务挂了，应该如何处理?"></a>注册中心挂了，或者服务挂了，应该如何处理?</h1><p>注册中心挂了，可以读取本地持久化里的配置</p><p>服务挂了 应该配有服务监控中心 感知到服务下线后可以通过配置的邮件通知相关人员排查问题。</p><h1 id="说说你对RPC、RMI如何理解"><a href="#说说你对RPC、RMI如何理解" class="headerlink" title="说说你对RPC、RMI如何理解?"></a>说说你对RPC、RMI如何理解?</h1><p>RPC 远程过程调用协议，通过网络从远程计算机上请求调用某种服务。</p><p>RMI:远程方法调用 能够让在客户端Java虚拟机上的对象像调用本地对象一样调用服务端java 虚拟机中的对象上的方法。</p><h1 id="redis持久化机制：RDB和AOF"><a href="#redis持久化机制：RDB和AOF" class="headerlink" title="redis持久化机制：RDB和AOF"></a>redis持久化机制：RDB和AOF</h1><h2 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h2><p>Redis 提供了不同级别的持久化方式:</p><ul><li><p>RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储.</p></li><li><p>AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾.Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大.</p></li><li><p>如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.</p></li><li><p>你也可以同时开启两种持久化方式, 在这种情况下, 当redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.</p></li><li><p>最重要的事情是了解RDB和AOF持久化方式的不同,让我们以RDB持久化方式开始:</p><h2 id="RDB的优点"><a href="#RDB的优点" class="headerlink" title="RDB的优点"></a><strong>RDB的优点</strong></h2></li><li><p>RDB是一个非常紧凑的文件,它保存了某个时间点得数据集,非常适用于数据集的备份,比如你可以在每个小时报保存一下过去24小时内的数据,同时每天保存过去30天的数据,这样即使出了问题你也可以根据需求恢复到不同版本的数据集.</p></li><li><p>RDB是一个紧凑的单一文件,很方便传送到另一个远端数据中心或者亚马逊的S3（可能加密），非常适用于灾难恢复.</p></li><li><p>RDB在保存RDB文件时父进程唯一需要做的就是fork出一个子进程,接下来的工作全部由子进程来做，父进程不需要再做其他IO操作，所以RDB持久化方式可以最大化redis的性能.</p></li><li><p>与AOF相比,在恢复大的数据集的时候，RDB方式会更快一些.</p><h2 id="RDB的缺点"><a href="#RDB的缺点" class="headerlink" title="RDB的缺点"></a><strong>RDB的缺点</strong></h2></li><li><p>如果你希望在redis意外停止工作（例如电源中断）的情况下丢失的数据最少的话，那么RDB不适合你.虽然你可以配置不同的save时间点(例如每隔5分钟并且对数据集有100个写的操作),是Redis要完整的保存整个数据集是一个比较繁重的工作,你通常会每隔5分钟或者更久做一次完整的保存,万一在Redis意外宕机,你可能会丢失几分钟的数据.</p></li><li><p>RDB 需要经常fork子进程来保存数据集到硬盘上,当数据集比较大的时候,fork的过程是非常耗时的,可能会导致Redis在一些毫秒级内不能响应客户端的请求.如果数据集巨大并且CPU性能不是很好的情况下,这种情况会持续1秒,AOF也需要fork,但是你可以调节重写日志文件的频率来提高数据集的耐久度.</p><h2 id="AOF-优点"><a href="#AOF-优点" class="headerlink" title="AOF 优点"></a><strong>AOF 优点</strong></h2></li><li><p>使用AOF 会让你的Redis更加耐久: 你可以使用不同的fsync策略：无fsync,每秒fsync,每次写的时候fsync.使用默认的每秒fsync策略,Redis的性能依然很好(fsync是由后台线程进行处理的,主线程会尽力处理客户端请求),一旦出现故障，你最多丢失1秒的数据.</p></li><li><p>AOF文件是一个只进行追加的日志文件,所以不需要写入seek,即使由于某些原因(磁盘空间已满，写的过程中宕机等等)未执行完整的写入命令,你也也可使用redis-check-aof工具修复这些问题.</p></li><li><p>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。</p></li><li><p>AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单： 举个例子， 如果你不小心执行了 FLUSHALL 命令， 但只要 AOF 文件未被重写， 那么只要停止服务器， 移除 AOF 文件末尾的 FLUSHALL 命令， 并重启 Redis ， 就可以将数据集恢复到 FLUSHALL 执行之前的状态。</p><h2 id="AOF-缺点"><a href="#AOF-缺点" class="headerlink" title="AOF 缺点"></a><strong>AOF 缺点</strong></h2></li><li><p>对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。</p></li><li><p>根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）。</p><h2 id="4-X版本的整合策略"><a href="#4-X版本的整合策略" class="headerlink" title="4.X版本的整合策略"></a>4.X版本的整合策略</h2><p>在AOF重写策略上做了优化</p><p>在重写AOF文件时，4.x版本以前是把内存数据集的操作指令落地，而新版本是把内存的数据集以rdb的形式落地</p><p>这样重写后的AOF依然追加的是日志，但是，在恢复的时候是先rdb再增量的日志，性能更优秀</p></li></ul><h2 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h2><p>异步线程知识点</p><p>计算机组成原理</p><p>fork</p><p>copy on write</p><p>系统IO</p><p>pagecache</p><p>fsync</p><hr><h1 id="redis的过期键有哪些删除策略"><a href="#redis的过期键有哪些删除策略" class="headerlink" title="redis的过期键有哪些删除策略"></a>redis的过期键有哪些删除策略</h1><h2 id="过期精度"><a href="#过期精度" class="headerlink" title="过期精度"></a>过期精度</h2><p>在 Redis 2.4 及以前版本，过期期时间可能不是十分准确，有0-1秒的误差。</p><p>从 Redis 2.6 起，过期时间误差缩小到0-1毫秒。</p><h2 id="过期和持久"><a href="#过期和持久" class="headerlink" title="过期和持久"></a>过期和持久</h2><p>Keys的过期时间使用Unix时间戳存储(从Redis 2.6开始以毫秒为单位)。这意味着即使Redis实例不可用，时间也是一直在流逝的。</p><p>要想过期的工作处理好，计算机必须采用稳定的时间。 如果你将RDB文件在两台时钟不同步的电脑间同步，有趣的事会发生（所有的 keys装载时就会过期）。</p><p>即使正在运行的实例也会检查计算机的时钟，例如如果你设置了一个key的有效期是1000秒，然后设置你的计算机时间为未来2000秒，这时key会立即失效，而不是等1000秒之后。</p><h2 id="Redis如何淘汰过期的keys"><a href="#Redis如何淘汰过期的keys" class="headerlink" title="Redis如何淘汰过期的keys"></a>Redis如何淘汰过期的keys</h2><p>Redis keys过期有两种方式：被动和主动方式。</p><p>当一些客户端尝试访问它时，key会被发现并主动的过期。</p><p>当然，这样是不够的，因为有些过期的keys，永远不会访问他们。 无论如何，这些keys应该过期，所以定时随机测试设置keys的过期时间。所有这些过期的keys将会从密钥空间删除。</p><p>具体就是Redis每秒10次做的事情：</p><ol><li>测试随机的20个keys进行相关过期检测。</li><li>删除所有已经过期的keys。</li><li>如果有多于25%的keys过期，重复步奏1.</li></ol><p>这是一个平凡的概率算法，基本上的假设是，我们的样本是这个密钥控件，并且我们不断重复过期检测，直到过期的keys的百分百低于25%,这意味着，在任何给定的时刻，最多会清除1/4的过期keys。</p><h2 id="在复制AOF文件时如何处理过期"><a href="#在复制AOF文件时如何处理过期" class="headerlink" title="在复制AOF文件时如何处理过期"></a>在复制AOF文件时如何处理过期</h2><p>为了获得正确的行为而不牺牲一致性，当一个key过期，<code>DEL</code>将会随着AOF文字一起合成到所有附加的slaves。在master实例中，这种方法是集中的，并且不存在一致性错误的机会。</p><p>然而，当slaves连接到master时，不会独立过期keys（会等到master执行DEL命令），他们任然会在数据集里面存在，所以当slave当选为master时淘汰keys会独立执行，然后成为master。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>绝对时间点过期</p><p>相对时间点过期</p><p>时钟轮算法</p><hr><h1 id="redis线程模型有哪些，单线程为什么快"><a href="#redis线程模型有哪些，单线程为什么快" class="headerlink" title="redis线程模型有哪些，单线程为什么快"></a>redis线程模型有哪些，单线程为什么快</h1><h2 id="IO模型维度的特征"><a href="#IO模型维度的特征" class="headerlink" title="IO模型维度的特征"></a>IO模型维度的特征</h2><p>IO模型使用了多路复用器，在linux系统中使用的是EPOLL</p><p>类似netty的BOSS,WORKER使用一个EventLoopGroup(threads=1)</p><p>单线程的Reactor模型，每次循环取socket中的命令然后逐一操作，可以保证socket中的指令是按顺序的，不保证不同的socket也就是客户端的命令的顺序性</p><p>命令操作在单线程中顺序操作，没有多线程的困扰不需要锁的复杂度，在操作数据上相对来说是原子性质的</p><h2 id="架构设计模型"><a href="#架构设计模型" class="headerlink" title="架构设计模型"></a>架构设计模型</h2><p>自身的内存存储数据，读写操作不设计磁盘IO</p><p>redis除了提供了Value具备类型还为每种类型实现了一些操作命令</p><p>实现了计算向数据移动，而非数据想计算移动，这样在IO的成本上有一定的优势</p><p>且在数据结构类型上，丰富了一些统计类属性，读写操作中，写操作会O(1)负载度更新length类属性，使得读操作也是O(1)的</p><hr><h1 id="缓存雪崩、缓存穿透、缓存击穿在实际中如何处理"><a href="#缓存雪崩、缓存穿透、缓存击穿在实际中如何处理" class="headerlink" title="缓存雪崩、缓存穿透、缓存击穿在实际中如何处理"></a>缓存雪崩、缓存穿透、缓存击穿在实际中如何处理</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</p><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题，这个和缓存雪崩的区别在于这里针对某一key缓存，前者则是很多key。</p><p>缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>缓存失效时的雪崩效应对底层系统的冲击非常可怕。大多数系统设计者考虑用加锁或者队列的方式保证缓存的单线 程（进程）写，从而避免失效时大量的并发请求落到底层存储系统上。这里分享一个简单方案就时讲缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。</p><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>1.使用互斥锁(mutex key)<br>业界比较常用的做法，是使用mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。<br>SETNX，是「SET if Not eXists」的缩写，也就是只有不存在的时候才设置，可以利用它来实现锁的效果。在redis2.6.1之前版本未实现setnx的过期时间</p><p>2.”提前”使用互斥锁(mutex key)：<br>在value内部设置1个超时值(timeout1), timeout1比实际的memcache timeout(timeout2)小。当从cache读取到timeout1发现它已经过期时候，马上延长timeout1并重新设置到cache。然后再从数据库加载数据并设置到cache中。</p><p>3.”永远不过期”：<br>这里的“永远不过期”包含两层意思：</p><p>(1) 从redis上看，确实没有设置过期时间，这就保证了，不会出现热点key过期问题，也就是“物理”不过期。</p><p>(2) 从功能上看，如果不过期，那不就成静态的了吗？所以我们把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建，也就是“逻辑”过期</p><p>从实战看，这种方法对于性能非常友好，唯一不足的就是构建缓存时候，其余线程(非构建缓存的线程)可能访问的是老数据，但是对于一般的互联网功能来说这个还是可以忍受。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>穿透：缓存不存在，数据库不存在，高并发，少量key</p><p>击穿：缓存不存在，数据库存在，高并发，少量key</p><p>雪崩：缓存不存在，数据库存在，高并发，大量key</p><h2 id="语义有些许差异，但是，都可以使用限流的互斥锁，保障数据库的稳定"><a href="#语义有些许差异，但是，都可以使用限流的互斥锁，保障数据库的稳定" class="headerlink" title="语义有些许差异，但是，都可以使用限流的互斥锁，保障数据库的稳定"></a>语义有些许差异，但是，都可以使用限流的互斥锁，保障数据库的稳定</h2><hr><h1 id="redis事务是怎么实现的"><a href="#redis事务是怎么实现的" class="headerlink" title="redis事务是怎么实现的"></a>redis事务是怎么实现的</h1><p>MULTI 、 EXEC 、 DISCARD 和 WATCH 是 Redis 事务相关的命令。事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</span><br><span class="line"></span><br><span class="line">事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</span><br></pre></td></tr></table></figure><p>EXEC 命令负责触发并执行事务中的所有命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果客户端在使用 MULTI 开启了一个事务之后，却因为断线而没有成功执行 EXEC ，那么事务中的所有命令都不会被执行。</span><br><span class="line">另一方面，如果客户端成功在开启事务之后执行 EXEC ，那么事务中的所有命令都会被执行。</span><br></pre></td></tr></table></figure><p>当使用 AOF 方式做持久化的时候， Redis 会使用单个 write(2) 命令将事务写入到磁盘中。</p><p>然而，如果 Redis 服务器因为某些原因被管理员杀死，或者遇上某种硬件故障，那么可能只有部分事务命令会被成功写入到磁盘中。</p><p>如果 Redis 在重新启动时发现 AOF 文件出了这样的问题，那么它会退出，并汇报一个错误。</p><p>使用redis-check-aof程序可以修复这一问题：它会移除 AOF 文件中不完整事务的信息，确保服务器可以顺利启动。</p><p>从 2.2 版本开始，Redis 还可以通过乐观锁（optimistic lock）实现 CAS （check-and-set）操作，具体信息请参考文档的后半部分。</p><h2 id="事务中的错误"><a href="#事务中的错误" class="headerlink" title="事务中的错误"></a>事务中的错误</h2><p>使用事务时可能会遇上以下两种错误：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">事务在执行 EXEC 之前，入队的命令可能会出错。比如说，命令可能会产生语法错误（参数数量错误，参数名错误，等等），或者其他更严重的错误，比如内存不足（如果服务器使用 maxmemory 设置了最大内存限制的话）。</span><br><span class="line">命令可能在 EXEC 调用之后失败。举个例子，事务中的命令可能处理了错误类型的键，比如将列表命令用在了字符串键上面，诸如此类。</span><br></pre></td></tr></table></figure><p>对于发生在 EXEC 执行之前的错误，客户端以前的做法是检查命令入队所得的返回值：如果命令入队时返回 QUEUED ，那么入队成功；否则，就是入队失败。如果有命令在入队时失败，那么大部分客户端都会停止并取消这个事务。</p><p>不过，从 Redis 2.6.5 开始，服务器会对命令入队失败的情况进行记录，并在客户端调用 EXEC 命令时，拒绝执行并自动放弃这个事务。</p><p>在 Redis 2.6.5 以前， Redis 只执行事务中那些入队成功的命令，而忽略那些入队失败的命令。 而新的处理方式则使得在流水线（pipeline）中包含事务变得简单，因为发送事务和读取事务的回复都只需要和服务器进行一次通讯。</p><p>至于那些在 EXEC 命令执行之后所产生的错误， 并没有对它们进行特别处理： 即使事务中有某个/某些命令在执行时产生了错误， 事务中的其他命令仍然会继续执行。</p><h2 id="为什么-Redis-不支持回滚（roll-back）"><a href="#为什么-Redis-不支持回滚（roll-back）" class="headerlink" title="为什么 Redis 不支持回滚（roll back）"></a>为什么 Redis 不支持回滚（roll back）</h2><p>如果你有使用关系式数据库的经验， 那么 “Redis 在事务失败时不进行回滚，而是继续执行余下的命令”这种做法可能会让你觉得有点奇怪。</p><p>以下是这种做法的优点：</p><ul><li>Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。</li><li>因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。</li></ul><p>有种观点认为 Redis 处理事务的做法会产生 bug ， 然而需要注意的是， 在通常情况下， 回滚并不能解决编程错误带来的问题。 举个例子， 如果你本来想通过 <a href="http://redis.cn/commands/incr.html">INCR</a> 命令将键的值加上 1 ， 却不小心加上了 2 ， 又或者对错误类型的键执行了 <a href="http://redis.cn/commands/incr.html">INCR</a> ， 回滚是没有办法处理这些情况的。</p><hr><h1 id="redis集群方案有哪些"><a href="#redis集群方案有哪些" class="headerlink" title="redis集群方案有哪些"></a>redis集群方案有哪些</h1><h2 id="常见集群分类"><a href="#常见集群分类" class="headerlink" title="常见集群分类"></a>常见集群分类</h2><p>主从复制集群</p><p>分片集群</p><h2 id="redis有那些："><a href="#redis有那些：" class="headerlink" title="redis有那些："></a>redis有那些：</h2><p>主从复制集群，手动切换</p><p>带有哨兵的HA的主从复制集群</p><p>客户端实现路由索引的分片集群</p><p>使用中间件代理层的分片集群</p><p>redis自身实现的cluster分片集群</p><hr><h1 id="redis主从复制的原理是什么"><a href="#redis主从复制的原理是什么" class="headerlink" title="redis主从复制的原理是什么"></a>redis主从复制的原理是什么</h1><h2 id="主从复制机制"><a href="#主从复制机制" class="headerlink" title="主从复制机制"></a>主从复制机制</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当一个 master 实例和一个 slave 实例连接正常时， master 会发送一连串的命令流来保持对 slave 的更新，以便于将自身数据集的改变复制给 slave ， ：包括客户端的写入、key 的过期或被逐出等等。</span><br><span class="line"></span><br><span class="line">当 master 和 slave 之间的连接断开之后，因为网络问题、或者是主从意识到连接超时， slave 重新连接上 master 并会尝试进行部分重同步：这意味着它会尝试只获取在断开连接期间内丢失的命令流。</span><br><span class="line"></span><br><span class="line">当无法进行部分重同步时， slave 会请求进行全量重同步。这会涉及到一个更复杂的过程，例如 master 需要创建所有数据的快照，将之发送给 slave ，之后在数据集更改时持续发送命令流到 slave 。</span><br></pre></td></tr></table></figure><h2 id="主从复制的关注点"><a href="#主从复制的关注点" class="headerlink" title="主从复制的关注点"></a>主从复制的关注点</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Redis 使用异步复制，slave 和 master 之间异步地确认处理的数据量</span><br><span class="line"></span><br><span class="line">一个 master 可以拥有多个 slave</span><br><span class="line"></span><br><span class="line">slave 可以接受其他 slave 的连接。除了多个 slave 可以连接到同一个 master 之外， slave 之间也可以像层叠状的结构（cascading-like structure）连接到其他 slave 。自 Redis 4.0 起，所有的 sub-slave 将会从 master 收到完全一样的复制流。</span><br><span class="line"></span><br><span class="line">Redis 复制在 master 侧是非阻塞的。这意味着 master 在一个或多个 slave 进行初次同步或者是部分重同步时，可以继续处理查询请求。</span><br><span class="line"></span><br><span class="line">复制在 slave 侧大部分也是非阻塞的。当 slave 进行初次同步时，它可以使用旧数据集处理查询请求，假设你在 redis.conf 中配置了让 Redis 这样做的话。否则，你可以配置如果复制流断开， Redis slave 会返回一个 error 给客户端。但是，在初次同步之后，旧数据集必须被删除，同时加载新的数据集。 slave 在这个短暂的时间窗口内（如果数据集很大，会持续较长时间），会阻塞到来的连接请求。自 Redis 4.0 开始，可以配置 Redis 使删除旧数据集的操作在另一个不同的线程中进行，但是，加载新数据集的操作依然需要在主线程中进行并且会阻塞 slave 。</span><br><span class="line"></span><br><span class="line">复制既可以被用在可伸缩性，以便只读查询可以有多个 slave 进行（例如 O(N) 复杂度的慢操作可以被下放到 slave ），或者仅用于数据安全。</span><br><span class="line"></span><br><span class="line">可以使用复制来避免 master 将全部数据集写入磁盘造成的开销：一种典型的技术是配置你的 master Redis.conf 以避免对磁盘进行持久化，然后连接一个 slave ，其配置为不定期保存或是启用 AOF。但是，这个设置必须小心处理，因为重新启动的 master 程序将从一个空数据集开始：如果一个 slave 试图与它同步，那么这个 slave 也会被清空。</span><br><span class="line">任何时候数据安全性都是很重要的，所以如果 master 使用复制功能的同时未配置持久化，那么自动重启进程这项应该被禁用。</span><br></pre></td></tr></table></figure><h2 id="Redis-复制功能是如何工作的"><a href="#Redis-复制功能是如何工作的" class="headerlink" title="Redis 复制功能是如何工作的"></a>Redis 复制功能是如何工作的</h2><p>每一个 Redis master 都有一个 replication ID ：这是一个较大的伪随机字符串，标记了一个给定的数据集。每个 master 也持有一个偏移量，master 将自己产生的复制流发送给 slave 时，发送多少个字节的数据，自身的偏移量就会增加多少，目的是当有新的操作修改自己的数据集时，它可以以此更新 slave 的状态。复制偏移量即使在没有一个 slave 连接到 master 时，也会自增，所以基本上每一对给定的</p><blockquote><p>Replication ID, offset</p></blockquote><p>都会标识一个 master 数据集的确切版本。</p><p>当 slave 连接到 master 时，它们使用 PSYNC 命令来发送它们记录的旧的 master replication ID 和它们至今为止处理的偏移量。通过这种方式， master 能够仅发送 slave 所需的增量部分。但是如果 master 的缓冲区中没有足够的命令积压缓冲记录，或者如果 slave 引用了不再知道的历史记录（replication ID），则会转而进行一个全量重同步：在这种情况下， slave 会得到一个完整的数据集副本，从头开始。</p><p>下面是一个全量同步的工作细节：</p><p>master 开启一个后台保存进程，以便于生产一个 RDB 文件。同时它开始缓冲所有从客户端接收到的新的写入命令。当后台保存完成时， master 将数据集文件传输给 slave， slave将之保存在磁盘上，然后加载文件到内存。再然后 master 会发送所有缓冲的命令发给 slave。这个过程以指令流的形式完成并且和 Redis 协议本身的格式相同。</p><p>你可以用 telnet 自己进行尝试。在服务器正在做一些工作的同时连接到 Redis 端口并发出 <a href="https://redis.io/commands/sync">SYNC</a> 命令。你将会看到一个批量传输，并且之后每一个 master 接收到的命令都将在 telnet 回话中被重新发出。事实上 SYNC 是一个旧协议，在新的 Redis 实例中已经不再被使用，但是其仍然向后兼容：但它不允许部分重同步，所以现在 <strong>PSYNC</strong> 被用来替代 SYNC。</p><p>之前说过，当主从之间的连接因为一些原因崩溃之后， slave 能够自动重连。如果 master 收到了多个 slave 要求同步的请求，它会执行一个单独的后台保存，以便于为多个 slave 服务。</p><h2 id="无需磁盘参与的复制"><a href="#无需磁盘参与的复制" class="headerlink" title="无需磁盘参与的复制"></a>无需磁盘参与的复制</h2><p>正常情况下，一个全量重同步要求在磁盘上创建一个 RDB 文件，然后将它从磁盘加载进内存，然后 slave以此进行数据同步。</p><p>如果磁盘性能很低的话，这对 master 是一个压力很大的操作。Redis 2.8.18 是第一个支持无磁盘复制的版本。在此设置中，子进程直接发送 RDB 文件给 slave，无需使用磁盘作为中间储存介质。</p><hr><h1 id="redis缓存如何回收"><a href="#redis缓存如何回收" class="headerlink" title="redis缓存如何回收"></a>redis缓存如何回收</h1><h2 id="回收策略"><a href="#回收策略" class="headerlink" title="回收策略"></a>回收策略</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">noeviction:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）</span><br><span class="line">allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。</span><br><span class="line">volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。</span><br><span class="line">allkeys-random: 回收随机的键使得新添加的数据有空间存放。</span><br><span class="line">volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。</span><br><span class="line">volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。</span><br><span class="line">volatile-lfu：从所有配置了过期时间的键中驱逐使用频率最少的键</span><br><span class="line">allkeys-lfu：从所有键中驱逐使用频率最少的键</span><br></pre></td></tr></table></figure><p>如果没有键满足回收的前提条件的话，策略<strong>volatile-lru</strong>, <strong>volatile-random</strong>以及<strong>volatile-ttl</strong>就和noeviction 差不多了。</p><p>选择正确的回收策略是非常重要的，这取决于你的应用的访问模式，不过你可以在运行时进行相关的策略调整，并且监控缓存命中率和没命中的次数，通过RedisINFO命令输出以便调优。</p><p>一般的经验规则:</p><ul><li>使用<strong>allkeys-lru</strong>策略：当你希望你的请求符合一个幂定律分布，也就是说，你希望部分的子集元素将比其它其它元素被访问的更多。如果你不确定选择什么，这是个很好的选择。.</li><li>使用<strong>allkeys-random</strong>：如果你是循环访问，所有的键被连续的扫描，或者你希望请求分布正常（所有元素被访问的概率都差不多）。</li><li>使用<strong>volatile-ttl</strong>：如果你想要通过创建缓存对象时设置TTL值，来决定哪些对象应该被过期。</li></ul><p><strong>allkeys-lru</strong> 和 <strong>volatile-random</strong>策略对于当你想要单一的实例实现缓存及持久化一些键时很有用。不过一般运行两个实例是解决这个问题的更好方法。</p><p>为了键设置过期时间也是需要消耗内存的，所以使用<strong>allkeys-lru</strong>这种策略更加高效，因为没有必要为键取设置过期时间当内存有压力时。</p><h2 id="回收进程如何工作"><a href="#回收进程如何工作" class="headerlink" title="回收进程如何工作"></a><strong>回收进程如何工作</strong></h2><p>理解回收进程如何工作是非常重要的:</p><ul><li>一个客户端运行了新的命令，添加了新的数据。</li><li>Redi检查内存使用情况，如果大于maxmemory的限制, 则根据设定好的策略进行回收。</li><li>一个新的命令被执行，等等。</li><li>所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。</li></ul><p>如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。</p><h1 id="RabbitMQ的架构设计是什么样的"><a href="#RabbitMQ的架构设计是什么样的" class="headerlink" title="RabbitMQ的架构设计是什么样的"></a>RabbitMQ的架构设计是什么样的</h1><h2 id="是AMQP的实现，相关概念语义"><a href="#是AMQP的实现，相关概念语义" class="headerlink" title="是AMQP的实现，相关概念语义"></a>是AMQP的实现，相关概念语义</h2><p>Broker:它提供一种传输服务,它的角色就是维护一条从生产者到消费者的路线，保证数据能按照指定的方式进行传输</p><p>Exchange：消息交换机,它指定消息按什么规则,路由到哪个队列。 </p><p>Queue:消息的载体,每个消息都会被投到一个或多个队列。 </p><p>Binding:绑定，它的作用就是把exchange和queue按照路由规则绑定起来. </p><p>Routing Key:路由关键字,exchange根据这个关键字进行消息投递。 </p><p>vhost:虚拟主机,一个broker里可以有多个vhost，用作不同用户的权限分离。</p><p>Producer:消息生产者,就是投递消息的程序. </p><p>Consumer:消息消费者,就是接受消息的程序. </p><p>Channel:消息通道,在客户端的每个连接里,可建立多个channel.</p><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p>在mq领域中，producer将msg发送到queue，然后consumer通过消费queue完成P.C解耦</p><p>kafka是由producer决定msg发送到那个queue</p><p>rabbitmq是由Exchange决定msg应该怎么样发送到目标queue，这就是binding及对应的策略</p><h3 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a>Exchange</h3><p>Direct Exchange:直接匹配,通过Exchange名称+RountingKey来发送与接收消息.<br>Fanout Exchange:广播订阅,向所有的消费者发布消息,但是只有消费者将队列绑定到该路由器才能收到消息,忽略Routing Key.<br>Topic Exchange：主题匹配订阅,这里的主题指的是RoutingKey,RoutingKey可以采用通配符,如:*或#，RoutingKey命名采用.来分隔多个词,只有消息这将队列绑定到该路由器且指定RoutingKey符合匹配规则时才能收到消息;<br>Headers Exchange:消息头订阅,消息发布前,为消息定义一个或多个键值对的消息头,然后消费者接收消息同时需要定义类似的键值对请求头:(如:x-mactch=all或者x_match=any)，只有请求头与消息头匹配,才能接收消息,忽略RoutingKey.<br>默认的exchange:如果用空字符串去声明一个exchange，那么系统就会使用”amq.direct”这个exchange，我们创建一个queue时,默认的都会有一个和新建queue同名的routingKey绑定到这个默认的exchange上去</p><h2 id="复杂与精简"><a href="#复杂与精简" class="headerlink" title="复杂与精简"></a>复杂与精简</h2><p>在众多的MQ中间件中，首先学习Rabbitmq的时候，就理解他是一个单机的mq组件，为了系统的解耦，可以自己在业务层面做AKF</p><p>其在内卷能力做的非常出色，这得益于AMQP，也就是消息的传递形式、复杂度有exchange和queue的binding实现，这，对于P.C有很大的帮助</p><hr><h1 id="RabbitMQ如何确保消息发送和消息接收"><a href="#RabbitMQ如何确保消息发送和消息接收" class="headerlink" title="RabbitMQ如何确保消息发送和消息接收"></a>RabbitMQ如何确保消息发送和消息接收</h1><h2 id="消息发送确认"><a href="#消息发送确认" class="headerlink" title="消息发送确认"></a>消息发送确认</h2><h3 id="1-ConfirmCallback方法"><a href="#1-ConfirmCallback方法" class="headerlink" title="1 ConfirmCallback方法"></a>1 ConfirmCallback方法</h3><p>ConfirmCallback 是一个回调接口，消息发送到 Broker 后触发回调，确认消息是否到达 Broker 服务器，<strong>也就是只确认是否正确到达 Exchange 中。</strong></p><h3 id="2-ReturnCallback方法"><a href="#2-ReturnCallback方法" class="headerlink" title="2 ReturnCallback方法"></a>2 ReturnCallback方法</h3><p>通过实现 ReturnCallback 接口，启动消息失败返回，此接口是在交换器路由不到队列时触发回调，该方法可以不使用，因为交换器和队列是在代码里绑定的，如果消息成功投递到 Broker 后几乎不存在绑定队列失败，除非你代码写错了。</p><h2 id="消息接收确认"><a href="#消息接收确认" class="headerlink" title="消息接收确认"></a>消息接收确认</h2><p>RabbitMQ 消息确认机制（ACK）默认是自动确认的，自动确认会在消息发送给消费者后立即确认，但存在丢失消息的可能，如果消费端消费逻辑抛出异常，假如你用回滚了也只是保证了数据的一致性，但是消息还是丢了，也就是消费端没有处理成功这条消息，那么就相当于丢失了消息。</p><p>消息确认模式有：</p><p>AcknowledgeMode.NONE：自动确认。<br>AcknowledgeMode.AUTO：根据情况确认。<br>AcknowledgeMode.MANUAL：手动确认。<br>消费者收到消息后，手动调用 Basic.Ack 或 Basic.Nack 或 Basic.Reject 后，RabbitMQ 收到这些消息后，才认为本次投递完成。</p><p>Basic.Ack 命令：用于确认当前消息。<br>Basic.Nack 命令：用于否定当前消息（注意：这是AMQP 0-9-1的RabbitMQ扩展） 。<br>Basic.Reject 命令：用于拒绝当前消息。<br>Nack,Reject后都有能力要求是否requeue消息或者进入死信队列</p><hr><h1 id="RabbitMQ事务消息原理是什么"><a href="#RabbitMQ事务消息原理是什么" class="headerlink" title="RabbitMQ事务消息原理是什么"></a>RabbitMQ事务消息原理是什么</h1><h2 id="事务V-S确认"><a href="#事务V-S确认" class="headerlink" title="事务V.S确认"></a>事务V.S确认</h2><p>确认是对一件事的确认</p><p>事务是对批量的确认</p><p>增删改查中，事务是对于增删改的保证</p><h2 id="发送方事务"><a href="#发送方事务" class="headerlink" title="发送方事务"></a>发送方事务</h2><p>开启事务，发送多条数据，事务提交或回滚是原子的，要么都提交，要么都回滚</p><h2 id="消费方事务"><a href="#消费方事务" class="headerlink" title="消费方事务"></a>消费方事务</h2><p>消费方是读取行为，那么事务体现在哪里呢</p><p>rabbitmq的消费行为会触发queue中msg的是否删除、是否重新放回队列等行为，类增删改</p><p>所以，消费方的ack是要手动提交的，且最终确定以事务的提交和回滚决定</p><hr><h1 id="RabbitMQ死信队列、延时队列分别是什么"><a href="#RabbitMQ死信队列、延时队列分别是什么" class="headerlink" title="RabbitMQ死信队列、延时队列分别是什么"></a>RabbitMQ死信队列、延时队列分别是什么</h1><h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><p>DLX（Dead Letter Exchange），<strong>死信交换器</strong>。</p><p>当队列中的消息被拒绝、或者过期会变成死信，死信可以被重新发布到另一个交换器，这个交换器就是DLX，与DLX绑定的队列称为死信队列。<br>造成死信的原因：</p><ul><li>信息被拒绝</li><li>信息超时</li><li>超过了队列的最大长度</li></ul><h3 id="过期消息："><a href="#过期消息：" class="headerlink" title="过期消息："></a>过期消息：</h3><pre><code>在 rabbitmq 中存在2种方可设置消息的过期时间，第一种通过对队列进行设置，这种设置后，该队列中所有的消息都存在相同的过期时间，第二种通过对消息本身进行设置，那么每条消息的过期时间都不一样。如果同时使用这2种方法，那么以过期时间小的那个数值为准。当消息达到过期时间还没有被消费，那么那个消息就成为了一个 死信 消息。队列设置：在队列申明的时候使用 x-message-ttl 参数，单位为 毫秒单个消息设置：是设置消息属性的 expiration 参数的值，单位为 毫秒</code></pre><h2 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h2><p>延迟队列存储的是延迟消息</p><p>延迟消息指的是，当消息被发发布出去之后，并不立即投递给消费者，而是在指定时间之后投递。如：</p><p>在订单系统中，订单有30秒的付款时间，在订单超时之后在投递给消费者处理超时订单。</p><p>rabbitMq没有直接支持延迟队列，可以通过死信队列实现。</p><p>在死信队列中，可以为普通交换器绑定多个消息队列，假设绑定过期时间为5分钟，10分钟和30分钟，3个消息队列，然后为每个消息队列设置DLX，为每个DLX关联一个死信队列。</p><p>当消息过期之后，被转存到对应的死信队列中，然后投递给指定的消费者消费。</p><hr><h1 id="简述kafka架构设计是什么样"><a href="#简述kafka架构设计是什么样" class="headerlink" title="简述kafka架构设计是什么样"></a>简述kafka架构设计是什么样</h1><p>语义概念</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 broker</span><br><span class="line">Kafka 集群包含一个或多个服务器，服务器节点称为broker。</span><br><span class="line"></span><br><span class="line">broker存储topic的数据。如果某topic有N个partition，集群有N个broker，那么每个broker存储该topic的一个partition。</span><br><span class="line"></span><br><span class="line">如果某topic有N个partition，集群有(N+M)个broker，那么其中有N个broker存储该topic的一个partition，剩下的M个broker不存储该topic的partition数据。</span><br><span class="line"></span><br><span class="line">如果某topic有N个partition，集群中broker数目少于N个，那么一个broker存储该topic的一个或多个partition。在实际生产环境中，尽量避免这种情况的发生，这种情况容易导致Kafka集群数据不均衡。</span><br><span class="line"></span><br><span class="line">2 Topic</span><br><span class="line">每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。（物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个broker上但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处）</span><br><span class="line"></span><br><span class="line">类似于数据库的表名</span><br><span class="line"></span><br><span class="line">3 Partition</span><br><span class="line">topic中的数据分割为一个或多个partition。每个topic至少有一个partition。每个partition中的数据使用多个segment文件存储。partition中的数据是有序的，不同partition间的数据丢失了数据的顺序。如果topic有多个partition，消费数据时就不能保证数据的顺序。在需要严格保证消息的消费顺序的场景下，需要将partition数目设为1。</span><br><span class="line"></span><br><span class="line">4 Producer</span><br><span class="line">生产者即数据的发布者，该角色将消息发布到Kafka的topic中。broker接收到生产者发送的消息后，broker将该消息追加到当前用于追加数据的segment文件中。生产者发送的消息，存储到一个partition中，生产者也可以指定数据存储的partition。</span><br><span class="line"></span><br><span class="line">5 Consumer</span><br><span class="line">消费者可以从broker中读取数据。消费者可以消费多个topic中的数据。</span><br><span class="line"></span><br><span class="line">6 Consumer Group</span><br><span class="line">每个Consumer属于一个特定的Consumer Group（可为每个Consumer指定group name，若不指定group name则属于默认的group）。这是kafka用来实现一个topic消息的广播（发给所有的consumer）和单播（发给任意一个consumer）的手段。一个topic可以有多个CG。topic的消息会复制-给consumer。如果需要实现广播，只要每个consumer有一个独立的CG就可以了。要实现单播只要所有的consumer在同一个CG。用CG还可以将consumer进行自由的分组而不需要多次发送消息到不同的topic。</span><br><span class="line"></span><br><span class="line">7 Leader</span><br><span class="line">每个partition有多个副本，其中有且仅有一个作为Leader，Leader是当前负责数据的读写的partition。</span><br><span class="line"></span><br><span class="line">8 Follower</span><br><span class="line">Follower跟随Leader，所有写请求都通过Leader路由，数据变更会广播给所有Follower，Follower与Leader保持数据同步。如果Leader失效，则从Follower中选举出一个新的Leader。当Follower与Leader挂掉、卡住或者同步太慢，leader会把这个follower从“in sync replicas”（ISR）列表中删除，重新创建一个Follower。</span><br><span class="line"></span><br><span class="line">9 Offset</span><br><span class="line">kafka的存储文件都是按照offset.kafka来命名，用offset做名字的好处是方便查找。例如你想找位于2049的位置，只要找到2048.kafka的文件即可。当然the first offset就是00000000000.kafka</span><br></pre></td></tr></table></figure><p>KAFKA天生是分布式的，满足AKF的XYZ轴特点，扩展性，可靠性，高性能是没得说</p><p>而且，kafka具备自己的特色，比如动态ISR集合，是在强一致性，过半一致性之外的另一个实现手段</p><hr><hr><h1 id="Kafka消息丢失的场景有哪些"><a href="#Kafka消息丢失的场景有哪些" class="headerlink" title="Kafka消息丢失的场景有哪些"></a>Kafka消息丢失的场景有哪些</h1><p>生产者在生产过程中的消息丢失</p><p>broker在故障后的消息丢失</p><p>消费者在消费过程中的消息丢失</p><h2 id="ACK机制"><a href="#ACK机制" class="headerlink" title="ACK机制"></a>ACK机制</h2><p>ack有3个可选值，分别是1，0，-1。</p><h2 id="ack-0：生产者在生产过程中的消息丢失"><a href="#ack-0：生产者在生产过程中的消息丢失" class="headerlink" title="ack=0：生产者在生产过程中的消息丢失"></a>ack=0：生产者在生产过程中的消息丢失</h2><p>简单来说就是，producer发送一次就不再发送了，不管是否发送成功。</p><h2 id="ack-1：broker在故障后的消息丢失"><a href="#ack-1：broker在故障后的消息丢失" class="headerlink" title="ack=1：broker在故障后的消息丢失"></a>ack=1：broker在故障后的消息丢失</h2><p>简单来说就是，producer只要收到一个分区副本成功写入的通知就认为推送消息成功了。这里有一个地方需要注意，这个副本必须是leader副本。只有leader副本成功写入了，producer才会认为消息发送成功。</p><p>注意，ack的默认值就是1。这个默认值其实就是吞吐量与可靠性的一个折中方案。生产上我们可以根据实际情况进行调整，比如如果你要追求高吞吐量，那么就要放弃可靠性。</p><h2 id="ack-1：生产侧和存储侧不会丢失数据"><a href="#ack-1：生产侧和存储侧不会丢失数据" class="headerlink" title="ack=-1：生产侧和存储侧不会丢失数据"></a>ack=-1：生产侧和存储侧不会丢失数据</h2><p>简单来说就是，producer只有收到分区内所有副本的成功写入的通知才认为推送消息成功了。</p><h2 id="Offset机制"><a href="#Offset机制" class="headerlink" title="Offset机制"></a>Offset机制</h2><p>kafka消费者的三种消费语义</p><p>at-most-once：最多一次，可能丢数据</p><p>at-least-once：最少一次，可能重复消费数据</p><p>exact-once message：精确一次</p><hr><h1 id="Kafka是pull？push？以及优劣势分析"><a href="#Kafka是pull？push？以及优劣势分析" class="headerlink" title="Kafka是pull？push？以及优劣势分析"></a>Kafka是pull？push？以及优劣势分析</h1><p>Kafka最初考虑的问题是，customer应该从brokes拉取消息还是brokers将消息推送到consumer，也就是pull还push。</p><p>Kafka遵循了一种大部分消息系统共同的传统的设计：producer将消息推送到broker，consumer从broker拉取消息。</p><p>一些消息系统比如Scribe和Apache Flume采用了push模式，将消息推送到下游的consumer。</p><p>这样做有好处也有坏处：由broker决定消息推送的速率，对于不同消费速率的consumer就不太好处理了。</p><p>消息系统都致力于让consumer以最大的速率最快速的消费消息，但不幸的是，push模式下，当broker推送的速率远大于consumer消费的速率时，consumer恐怕就要崩溃了。</p><p>最终Kafka还是选取了传统的pull模式。</p><p>Pull模式的另外一个好处是consumer可以自主决定是否批量的从broker拉取数据。</p><p>Push模式必须在不知道下游consumer消费能力和消费策略的情况下决定是立即推送每条消息还是缓存之后批量推送。</p><p>如果为了避免consumer崩溃而采用较低的推送速率，将可能导致一次只推送较少的消息而造成浪费。</p><p>Pull模式下，consumer就可以根据自己的消费能力去决定这些策略。</p><p>Pull有个缺点是，如果broker没有可供消费的消息，将导致consumer不断在循环中轮询，直到新消息到达。</p><p>为了避免这点，Kafka有个参数可以让consumer阻塞知道新消息到达(当然也可以阻塞知道消息的数量达到某个特定的量这样就可以批量发</p><hr><h1 id="Kafka中zk的作用是什么"><a href="#Kafka中zk的作用是什么" class="headerlink" title="Kafka中zk的作用是什么"></a>Kafka中zk的作用是什么</h1><p>Zookeeper是分布式协调，注意它不是数据库</p><p>kafka中使用了zookeeper的分布式锁和分布式配置及统一命名的分布式协调解决方案</p><p>在kafka的broker集群中的controller的选择，是通过zk的临时节点争抢获得的</p><p>brokerID等如果自增的话也是通过zk的节点version实现的全局唯一</p><p>kafka中broker中的状态数据也是存储在zk中，不过这里要注意，zk不是数据库，所以存储的属于元数据</p><p>而，新旧版本变化中，就把曾经的offset从zk中迁移出了zk</p><hr><h1 id="Kafka中高性能如何保障"><a href="#Kafka中高性能如何保障" class="headerlink" title="Kafka中高性能如何保障"></a>Kafka中高性能如何保障</h1><p>首先，性能的最大瓶颈依然是IO，这个是不能逾越的鸿沟</p><p>虽然，broker在持久化数据的时候已经最大努力的使用了磁盘的顺序读写</p><p>更进一步的性能优化是零拷贝的使用，也就是从磁盘日志到消费者客户端的数据传递，因为kafka是mq，对于msg不具备加工处理，所以得以实现</p><p>然后就是大多数分布式系统一样，总要做tradeoff，在速度与可用性/可靠性中挣扎</p><p>ACK的0，1，-1级别就是在性能和可靠中权衡</p><hr><h1 id="kafka的rebalance机制是什么"><a href="#kafka的rebalance机制是什么" class="headerlink" title="kafka的rebalance机制是什么"></a>kafka的rebalance机制是什么</h1><h2 id="消费者分区分配策略"><a href="#消费者分区分配策略" class="headerlink" title="消费者分区分配策略"></a>消费者分区分配策略</h2><p>Range 范围分区(默认的)</p><p>RoundRobin 轮询分区</p><p>Sticky策略</p><h2 id="触发-Rebalance-的时机"><a href="#触发-Rebalance-的时机" class="headerlink" title="触发 Rebalance 的时机"></a>触发 Rebalance 的时机</h2><p>Rebalance 的触发条件有3个。</p><ul><li>组成员个数发生变化。例如有新的 consumer 实例加入该消费组或者离开组。</li><li>订阅的 Topic 个数发生变化。</li><li>订阅 Topic 的分区数发生变化。</li></ul><h2 id="Coordinator协调过程"><a href="#Coordinator协调过程" class="headerlink" title="Coordinator协调过程"></a>Coordinator协调过程</h2><p>消费者如何发现协调者</p><p>消费者如何确定分配策略</p><p>如果需要再均衡分配策略的影响</p><hr><h1 id="zk的数据模型和节点类型有哪些"><a href="#zk的数据模型和节点类型有哪些" class="headerlink" title="zk的数据模型和节点类型有哪些"></a>zk的数据模型和节点类型有哪些</h1><h2 id="ZooKeeper数据模型"><a href="#ZooKeeper数据模型" class="headerlink" title="ZooKeeper数据模型"></a>ZooKeeper数据模型</h2><p>ZooKeeper的数据模型，在结构上和标准文件系统的非常相似，拥有一个层次的命名空间，都是采用树形层次结构，ZooKeeper树中的每个节点被称为—Znode。</p><p>和文件系统的目录树一样，ZooKeeper树中的每个节点可以拥有子节点。但也有不同之处：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Znode兼具文件和目录两种特点。既像文件一样维护着数据、元信息、ACL、时间戳等数据结构，又像目录一样可以作为路径标识的一部分，并可以具有子Znode。用户对Znode具有增、删、改、查等操作（权限允许的情况下）</span><br><span class="line"></span><br><span class="line">Znode具有原子性操作，读操作将获取与节点相关的所有数据，写操作也将替换掉节点的所有数据。另外，每一个节点都拥有自己的ACL(访问控制列表)，这个列表规定了用户的权限，即限定了特定用户对目标节点可以执行的操作</span><br><span class="line"></span><br><span class="line">Znode存储数据大小有限制。ZooKeeper虽然可以关联一些数据，但并没有被设计为常规的数据库或者大数据存储，相反的是，它用来管理调度数据，比如分布式应用中的配置文件信息、状态信息、汇集位置等等。这些数据的共同特性就是它们都是很小的数据，通常以KB为大小单位。ZooKeeper的服务器和客户端都被设计为严格检查并限制每个Znode的数据大小至多1M，当时常规使用中应该远小于此值</span><br><span class="line"></span><br><span class="line">Znode通过路径引用，如同Unix中的文件路径。路径必须是绝对的，因此他们必须由斜杠字符来开头。除此以外，他们必须是唯一的，也就是说每一个路径只有一个表示，因此这些路径不能改变。在ZooKeeper中，路径由Unicode字符串组成，并且有一些限制。字符串&quot;/zookeeper&quot;用以保存管理信息，比如关键配额信息。</span><br></pre></td></tr></table></figure><h2 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h2><p>Znode有两种，分别为临时节点和永久节点。<br>节点的类型在创建时即被确定，并且不能改变。<br>临时节点：该节点的生命周期依赖于创建它们的会话。一旦会话结束，临时节点将被自动删除，当然可以也可以手动删除。临时节点不允许拥有子节点。</p><p>永久节点：该节点的生命周期不依赖于会话，并且只有在客户端显示执行删除操作的时候，他们才能被删除。<br>　　<br>Znode还有一个序列化的特性，如果创建的时候指定的话，该Znode的名字后面会自动追加一个不断增加的序列号。序列号对于此节点的父节点来说是唯一的，这样便会记录每个子节点创建的先后顺序。它的格式为“%10d”(10位数字，没有数值的数位用0补充，例如“0000000001”)</p><p>在ZooKeeper中，每个数据节点都是有生命周期的，其生命周期的长短取决于数据节点的节点类型。</p><p>1、持久节点（PERSISTENT）</p><p>该数据节点别创建后，就会一直存在于ZooKeeper服务器上，直到有删除操作来主动删除该节点。</p><p>2、持久顺序节点（PERSISTENT_SEQUENTIAL）</p><p>持久顺序节点的基本特性和持久节点是一致的，额外的特性表现在顺序性上。在ZooKeeper中，每个父节点都会为它的第一级子节点维护一份顺序，用于记录每个子节点创建的先后顺序。</p><p>3、临时节点（EPHEMERAL）</p><p>临时节点的生命周期和客户端的回话绑定在一起，如果客户端会话失效，那么这个节点就会被自动地清理掉。</p><p>ZooKeeper规定了不能基于临时节点来创建子节点，即临时节点只能作为叶子节点。</p><p>4、临时顺序节点（EPHEMERAL_SEQUENTIAL）</p><hr><h1 id="Zookeeper-watch机制是什么"><a href="#Zookeeper-watch机制是什么" class="headerlink" title="Zookeeper watch机制是什么"></a>Zookeeper watch机制是什么</h1><p>ZooKeeper是用来协调（同步）分布式进程的服务，提供了一个简单高性能的协调内核，用户可以在此之上构建更多复杂的分布式协调功能。</p><p>多个分布式进程通过ZooKeeper提供的API来操作共享的ZooKeeper内存数据对象ZNode来达成某种一致的行为或结果，这种模式本质上是基于状态共享的并发模型，与Java的多线程并发模型一致，他们的线程或进程都是”共享式内存通信“。</p><p>Java没有直接提供某种响应式通知接口来监控某个对象状态的变化，只能要么浪费CPU时间毫无响应式的轮询重试，或基于Java提供的某种主动通知（Notif）机制（内置队列）来响应状态变化，但这种机制是需要循环阻塞调用。</p><p>而ZooKeeper实现这些分布式进程的状态（ZNode的Data、Children）共享时，基于性能的考虑采用了类似的异步非阻塞的主动通知模式即Watch机制，使得分布式进程之间的“共享状态通信”更加实时高效，其实这也是ZooKeeper的主要任务决定的—协调。Consul虽然也实现了Watch机制，但它是阻塞的长轮询。</p><h2 id="ZooKeeper的Watch特性"><a href="#ZooKeeper的Watch特性" class="headerlink" title="ZooKeeper的Watch特性"></a>ZooKeeper的Watch特性</h2><ol><li>Watch是一次性的，每次都需要重新注册，并且客户端在会话异常结束时不会收到任何通知，而快速重连接时仍不影响接收通知。</li><li>Watch的回调执行都是顺序执行的，并且客户端在没有收到关注数据的变化事件通知之前是不会看到最新的数据，另外需要注意不要在Watch回调逻辑中阻塞整个客户端的Watch回调</li><li>Watch是轻量级的，WatchEvent是最小的通信单元，结构上只包含通知状态、事件类型和节点路径。ZooKeeper服务端只会通知客户端发生了什么，并不会告诉具体内容。</li></ol><h2 id="Zookeeper状态"><a href="#Zookeeper状态" class="headerlink" title="Zookeeper状态"></a>Zookeeper状态</h2><p>Disconnected：客户端是断开连接的状态，不能连接服务集合中的任意一个<br>SyncConnected：客户端是连接状态，连接其中的一个服务<br>AuthFailed：鉴权失败<br>ConnectedReadOnly：客户端连接只读的服务器<br>SaslAuthenticated：SASL认证<br>Expired：服务器已经过期了该客户端的Session</p><h2 id="Zookeeper事件类型"><a href="#Zookeeper事件类型" class="headerlink" title="Zookeeper事件类型"></a>Zookeeper事件类型</h2><p>None：无<br>NodeCreated：节点创建<br>NodeDeleted：节点删除<br>NodeDataChanged：节点数据改变<br>NodeChildrenChanged：子节点改变（添加/删除）</p><h2 id="Watcher使用的注意事项"><a href="#Watcher使用的注意事项" class="headerlink" title="Watcher使用的注意事项"></a>Watcher使用的注意事项</h2><p>Watcher是一次触发器，假如需要持续监听数据变更，需要在每次获取时设置Watcher<br>会话过期：当客户端会话过期时，该客户端注册的Watcher会失效<br>事件丢失：在接收通知和注册监视点之间，可能会丢失事件,但Zookeeper的状态变更和数据变化，都会记录在状态元数据信息和ZK数据节点上，所以能够获取最终一致的ZK信息状态<br>避免Watcher过多：服务器会对每一个注册Watcher事件的客户端发送通知，通知通过Socket连接的方式发送，当Watcher过多时，会产生一个尖峰的通知</p><h1 id="zk的命名服务、配置管理、集群管理分别是什么"><a href="#zk的命名服务、配置管理、集群管理分别是什么" class="headerlink" title="zk的命名服务、配置管理、集群管理分别是什么"></a>zk的命名服务、配置管理、集群管理分别是什么</h1><h2 id="分布式协调"><a href="#分布式协调" class="headerlink" title="分布式协调"></a>分布式协调</h2><p>大于等于一的情况下，才会有协调，在协调的事务进行分类得到一些名词，语义能够接受就可以</p><h2 id="命名服务"><a href="#命名服务" class="headerlink" title="命名服务"></a>命名服务</h2><p>通过使用有序节点的特性做到协调命名规则</p><p>通过zk的事务ID递增，做到有序行命名规则</p><p>通过使用自己点做map映射，做到1:N的命名映射，比如DNS</p><p>顺序关系、映射关系</p><h2 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h2><p>配置、元数据、状态等语义可以通过ZK的节点1MB存储，或者通过zk的节点目录结构特性存储</p><p>并且通过watch机制，满足配置变化的全局通知能力</p><h2 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a>集群管理</h2><p>通过zk的排他性，有序性</p><p>满足分布式锁、分布式选主、队列锁</p><p>串行化回调调度</p><p>分布式调度等</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法DAY-08</title>
      <link href="/%E7%AE%97%E6%B3%95DAY-08/"/>
      <url>/%E7%AE%97%E6%B3%95DAY-08/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法DAY-07</title>
      <link href="/%E7%AE%97%E6%B3%95DAY-07/"/>
      <url>/%E7%AE%97%E6%B3%95DAY-07/</url>
      
        <content type="html"><![CDATA[<h1 id="算法总结-DAY-07"><a href="#算法总结-DAY-07" class="headerlink" title="算法总结 DAY_07"></a>算法总结 DAY_07</h1><h2 id="链表专题"><a href="#链表专题" class="headerlink" title="链表专题"></a>链表专题</h2><h2 id="一、反转链表"><a href="#一、反转链表" class="headerlink" title="一、反转链表"></a>一、反转链表</h2><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">LeetCode 206. reverse-linked-list</a></p><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220326190449117.png" alt="image-20220326190449117" style="zoom:80%;" /><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="1-迭代"><a href="#1-迭代" class="headerlink" title="1. 迭代"></a>1. 迭代</h4><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220326192124184.png" alt="image-20220326192124184" style="zoom:67%;" /><p>在遍历链表时，将当前节点的 <code>next</code> 指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* mid = head;       <span class="comment">// 需翻转的节点</span></span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;    <span class="comment">// 前一个节点  </span></span><br><span class="line">        ListNode* aft = head-&gt;next; <span class="comment">// 后一个节点</span></span><br><span class="line">        <span class="keyword">while</span>(aft)&#123;</span><br><span class="line">            mid-&gt;next = pre;</span><br><span class="line">            pre = mid;</span><br><span class="line">            mid = aft;</span><br><span class="line">            aft = aft-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        mid-&gt;next = pre;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<code>O(n)</code>，其中 n 是链表的长度。需要遍历链表一次。</li><li>空间复杂度：<code>O(1)</code>。</li></ul><h4 id="2-递归"><a href="#2-递归" class="headerlink" title="2.递归"></a>2.递归</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* newHead = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<code>O(n)</code>，其中 n 是链表的长度。需要对链表的每个节点进行反转操作。</li><li>空间复杂度：<code>O(n)</code>，其中 n 是链表的长度。空间复杂度主要取决于递归调用的栈空间，最多为 n 层。</li></ul><h2 id="二、反转链表-II"><a href="#二、反转链表-II" class="headerlink" title="二、反转链表 II"></a>二、反转链表 II</h2><p><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">LeetCode 92. reverse-linked-list-ii</a></p><h3 id="题目：-1"><a href="#题目：-1" class="headerlink" title="题目："></a>题目：</h3><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220326192633719.png" alt="image-20220326192633719" style="zoom:80%;" /><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>使用「206. 反转链表」的解法，反转 left 到 right 部分以后，再拼接起来。我们还需要记录 left 的前一个节点，和 right 的后一个节点。如图所示：</p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/1615105150-pfWiGq-image.png" alt="image.png" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220326193234247.png" alt="image-20220326193234247" style="zoom:50%;" /><h4 id="1-迭代-1"><a href="#1-迭代-1" class="headerlink" title="1. 迭代"></a>1. 迭代</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//ListNode* ans = head;</span></span><br><span class="line">        <span class="keyword">int</span> Count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!head || left == right)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *pre = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);              <span class="comment">// 前一个节点  </span></span><br><span class="line">        pre-&gt;next = head;</span><br><span class="line">        <span class="comment">//ListNode* aft = head-&gt;next; // 后一个节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;left; i++)&#123;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* cur1 = pre;</span><br><span class="line">        ListNode* cur2 = pre-&gt;next;</span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">        ListNode* mid = pre-&gt;next;</span><br><span class="line">        ListNode* aft = pre-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;right-left; i++)&#123;</span><br><span class="line">            mid-&gt;next = pre;</span><br><span class="line">            pre = mid;</span><br><span class="line">            mid = aft;</span><br><span class="line">            aft = aft-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        mid-&gt;next = pre;</span><br><span class="line">        pre = mid;</span><br><span class="line">        mid = aft;</span><br><span class="line">        cur2-&gt;next = mid;</span><br><span class="line">        cur1-&gt;next = pre;</span><br><span class="line">        <span class="keyword">if</span>(cur1-&gt;val == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> cur1-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>官方题解</strong>：</p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220326193542892.png" alt="image-20220326193542892" style="zoom:67%;" /><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">reverseBetween</span><span class="params">(ListNode *head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置 dummyNode 是这一类问题的一般做法</span></span><br><span class="line">        ListNode *dummyNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummyNode-&gt;next = head;</span><br><span class="line">        ListNode *pre = dummyNode;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; left - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *cur = pre-&gt;next;</span><br><span class="line">        ListNode *next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; right - left; i++) &#123;</span><br><span class="line">            next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = next-&gt;next;</span><br><span class="line">            next-&gt;next = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：<code>O(N)</code>，其中 N 是链表总节点数。最多只遍历了链表一次，就完成了反转。</li><li>空间复杂度：<code>O(1)</code>。只使用到常数个变量。</li></ul><h2 id="三、相交链表"><a href="#三、相交链表" class="headerlink" title="三、相交链表"></a>三、相交链表</h2><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">LeetCode 160. intersection-of-two-linked-lists</a></p><h3 id="题目：-2"><a href="#题目：-2" class="headerlink" title="题目："></a>题目：</h3><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220326194118986.png" alt="image-20220326194118986" style="zoom:80%;" /><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><h4 id="1-哈希表"><a href="#1-哈希表" class="headerlink" title="1. 哈希表"></a>1. 哈希表</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        map&lt;ListNode*, <span class="keyword">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">while</span>(headA)&#123;</span><br><span class="line">            map[headA] ++;</span><br><span class="line">            headA = headA-&gt;next;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">while</span>(headB)&#123;</span><br><span class="line">            map[headB] ++;</span><br><span class="line">            <span class="keyword">if</span>(map[headB] &gt; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> headB;</span><br><span class="line">            headB = headB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<code>O(m+n)</code>，其中 m 和 n 是分别是链表 headA 和 headB 的长度。需要遍历两个链表各一次。</li><li>空间复杂度：<code>O(m)</code>，其中 m 是链表 headA 的长度。需要使用哈希集合存储链表 headA 中的全部节点。</li></ul><h4 id="2-双指针"><a href="#2-双指针" class="headerlink" title="2. 双指针"></a>2. 双指针</h4><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220326195406267.png" alt="image-20220326195406267" style="zoom:80%;" /><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="literal">nullptr</span> || headB == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *pA = headA, *pB = headB;</span><br><span class="line">        <span class="keyword">while</span> (pA != pB) &#123;</span><br><span class="line">            pA = pA == <span class="literal">nullptr</span> ? headB : pA-&gt;next;</span><br><span class="line">            pB = pB == <span class="literal">nullptr</span> ? headA : pB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<code>O(m+n)</code>，其中 m 和 n 是分别是链表 headA 和 headB 的长度。两个指针同时遍历两个链表，每个指针遍历两个链表各一次。</li><li>空间复杂度：<code>O(1)</code>。</li></ul><h2 id="四、环形链表-II"><a href="#四、环形链表-II" class="headerlink" title="四、环形链表 II"></a>四、环形链表 II</h2><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">LeetCode 142. linked-list-cycle-ii</a></p><h3 id="题目：-3"><a href="#题目：-3" class="headerlink" title="题目："></a>题目：</h3><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220326195852498.png" alt="image-20220326195852498" style="zoom:80%;" /><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><h4 id="1-哈希表-1"><a href="#1-哈希表-1" class="headerlink" title="1. 哈希表"></a>1. 哈希表</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;ListNode*, <span class="keyword">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            map[head]++;</span><br><span class="line">            <span class="keyword">if</span>(map[head] &gt; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<code>O(N)</code>，其中 N 为链表中节点的数目。我们恰好需要访问链表中的每一个节点。</li><li>空间复杂度：<code>O(N)</code>，其中 N 为链表中节点的数目。我们需要将链表中的每个节点都保存在哈希表当中。</li></ul><h4 id="2-快慢指针"><a href="#2-快慢指针" class="headerlink" title="2. 快慢指针"></a>2. 快慢指针</h4><p><strong>原理解释参照</strong>：<a href="https://chenduowen233.github.io/DAY-03/">https://chenduowen233.github.io/DAY-03/</a></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ListNode* cur1 = head;</span><br><span class="line">            ListNode* cur2 = head;</span><br><span class="line">            <span class="keyword">while</span>(cur2)&#123;</span><br><span class="line">                cur1 = cur1-&gt;next;</span><br><span class="line">                <span class="keyword">if</span>(cur2-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">                cur2 = cur2-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">if</span>(cur1 == cur2)&#123;</span><br><span class="line">                    ListNode* cur3 = head;</span><br><span class="line">                    <span class="keyword">while</span>(cur2 != cur3)&#123;</span><br><span class="line">                        cur2 = cur2-&gt;next;</span><br><span class="line">                        cur3 = cur3-&gt;next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> cur3;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220326200652638.png" alt="image-20220326200652638" style="zoom:80%;" /><h2 id="五、排序链表"><a href="#五、排序链表" class="headerlink" title="五、排序链表"></a>五、排序链表</h2><p><a href="https://leetcode-cn.com/problems/sort-list/">LeetCode 148. sort-list</a></p><h3 id="题目：-4"><a href="#题目：-4" class="headerlink" title="题目："></a>题目：</h3><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220327213328681.png" alt="image-20220327213328681" style="zoom:67%;" /><h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><h4 id="1-自底向上归并排序"><a href="#1-自底向上归并排序" class="headerlink" title="1. 自底向上归并排序"></a>1. 自底向上归并排序</h4><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220327214438775.png" alt="image-20220327214438775" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/c1d5347aa56648afdec22372ee0ed13cf4c25347bd2bb9727b09327ce04360c2-Picture1.png" alt="Picture1.png" style="zoom:67%;" /><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        ListNode* node = head;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> subLength = <span class="number">1</span>; subLength &lt; length; subLength &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            ListNode* prev = dummyHead, *curr = dummyHead-&gt;next;</span><br><span class="line">            <span class="keyword">while</span> (curr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                ListNode* head1 = curr;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; subLength &amp;&amp; curr-&gt;next != <span class="literal">nullptr</span>; i++) &#123;</span><br><span class="line">                    curr = curr-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode* head2 = curr-&gt;next;</span><br><span class="line">                curr-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">                curr = head2;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; subLength &amp;&amp; curr != <span class="literal">nullptr</span> &amp;&amp; curr-&gt;next != <span class="literal">nullptr</span>; i++) &#123;</span><br><span class="line">                    curr = curr-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode* next = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="keyword">if</span> (curr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    next = curr-&gt;next;</span><br><span class="line">                    curr-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode* merged = <span class="built_in">merge</span>(head1, head2);</span><br><span class="line">                prev-&gt;next = merged;</span><br><span class="line">                <span class="keyword">while</span> (prev-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    prev = prev-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                curr = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* head1, ListNode* head2)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode* temp = dummyHead, *temp1 = head1, *temp2 = head2;</span><br><span class="line">        <span class="keyword">while</span> (temp1 != <span class="literal">nullptr</span> &amp;&amp; temp2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp1-&gt;val &lt;= temp2-&gt;val) &#123;</span><br><span class="line">                temp-&gt;next = temp1;</span><br><span class="line">                temp1 = temp1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp-&gt;next = temp2;</span><br><span class="line">                temp2 = temp2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            temp-&gt;next = temp1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            temp-&gt;next = temp2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<code>O(n log n)</code>，其中 n 是链表的长度。</li><li>空间复杂度：<code>O(1)</code>。</li></ul><h4 id="2-自顶向下归并排序"><a href="#2-自顶向下归并排序" class="headerlink" title="2. 自顶向下归并排序"></a>2. 自顶向下归并排序</h4><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220327214654573.png" alt="image-20220327214654573"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sortList</span>(head, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head, ListNode* tail)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;next == tail) &#123;</span><br><span class="line">            head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* slow = head, *fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != tail) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast != tail) &#123;</span><br><span class="line">                fast = fast-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* mid = slow;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(<span class="built_in">sortList</span>(head, mid), <span class="built_in">sortList</span>(mid, tail));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* head1, ListNode* head2)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode* temp = dummyHead, *temp1 = head1, *temp2 = head2;</span><br><span class="line">        <span class="keyword">while</span> (temp1 != <span class="literal">nullptr</span> &amp;&amp; temp2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp1-&gt;val &lt;= temp2-&gt;val) &#123;</span><br><span class="line">                temp-&gt;next = temp1;</span><br><span class="line">                temp1 = temp1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp-&gt;next = temp2;</span><br><span class="line">                temp2 = temp2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            temp-&gt;next = temp1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            temp-&gt;next = temp2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<code>O(nlogn)</code>，其中 n 是链表的长度。</li><li>空间复杂度：<code>O(logn)</code>，其中 n 是链表的长度。空间复杂度主要取决于递归调用的栈空间。</li></ul><h3 id="知识点拓展"><a href="#知识点拓展" class="headerlink" title="知识点拓展"></a>知识点拓展</h3><h4 id="1-归并排序"><a href="#1-归并排序" class="headerlink" title="1. 归并排序"></a>1. 归并排序</h4><p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法，归并排序对序列的元素进行逐层折半分组，然后从最小分组开始比较排序，合并成一个大的分组，逐层进行，最终所有的元素都是有序的</p><p><strong>算法原理</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/20200619151903848.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-nvJMNUvk-1592551094228)(./归并1.png)]"></p><p>然后从下往上逐层合并，首先对第一层序列1（只包含元素4）和序列2（只包含元素5）进行合并</p><p>创建一个大序列，序列长度为两个小序列长度之和，p1、p2指针分别指向两个小序列的第一个元素，p指向大序列的第一个元素</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/20200619151928587.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-oHexl6py-1592551094230)(./归并2.png)]"></p><p>比较p1、p2指向的元素，4小于5，将4填入p指向的元素，p、p1往右移一位</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/2020061915195029.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-51zK7Ns2-1592551094231)(./归并3.png)]"></p><p>此时，序列1已经没有元素，将序列2的元素依次填入大序列中</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/20200619152014989.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-3QMWsy0X-1592551094232)(./归并4.png)]"></p><p>序列8和1，序列7和2，序列6和3，用同样的方式填入新的序列</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/20200619152035747.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-rWPH114Z-1592551094235)(./归并5.png)]"></p><p>接着，以4、5为序列1，1、8为序列2，继续进行合并</p><p>创建一个序列长度为4的大序列，p1指向序列1的第一个元素4，p2指向序列2的第一个元素1，p指向大序列的第一个元素</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/20200619152057575.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-oNDu9TdZ-1592551094236)(./归并6.png)]"></p><p>4和1比较，4大于1，1填入p指向的元素，p、p2往右移一位</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/202006191521208.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-nnIhGQnf-1592551094237)(./归并7.png)]"></p><p>4和8比较，4小于8，4填入p指向的元素，p、p1往右移一位</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/20200619152136296.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-YQxfZV0b-1592551094239)(./归并8.png)]"></p><p>5和8比较，5小于8，5填入p指向的元素，p、p1往右移一位</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/202006191521593.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-wFyyXNrc-1592551094240)(./归并9.png)]"></p><p>自此，序列1已经没有元素，将序列2的元素依次填入大序列中</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/20200619152220636.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Kiyj3tbz-1592551094241)(./归并10.png)]"></p><p>序列2、7和序列3、6以同样的方式合并成新的序列</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/20200619152242410.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-u26c0pOr-1592551094244)(./归并11.png)]"></p><p>最后，将序列1、4、5、8和序列2、3、6、7以同样的方式继续合并成新的序列</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/20200619152303145.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-tK2Rw29s-1592551094245)(./归并12.png)]"></p><p>至此所有的元素都是有序的</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">sort</span><span class="params">(arr, startIndex = <span class="number">0</span>, endIndex = arr.length - <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归结束条件：startIndex大于等于endIndex的时候</span></span><br><span class="line">    <span class="keyword">if</span> (startIndex &gt;= endIndex) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 折半递归</span></span><br><span class="line">    let midIndex = <span class="built_in">parseInt</span>((startIndex + endIndex) / <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">sort</span>(arr, startIndex, midIndex);</span><br><span class="line">    <span class="built_in">sort</span>(arr, midIndex + <span class="number">1</span>, endIndex);</span><br><span class="line">    <span class="comment">// 将两个有序的小数组，合并成一个大数组</span></span><br><span class="line">    <span class="built_in">merge</span>(arr, startIndex, midIndex, endIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">merge</span><span class="params">(arr, startIndex, midIndex, endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 新建一个大数组</span></span><br><span class="line">    let tempArr = [];</span><br><span class="line">    let p1 = startIndex;</span><br><span class="line">    let p2 = midIndex + <span class="number">1</span>;</span><br><span class="line">    let p = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较两个有序小数组的元素，依次放入大数组中</span></span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= midIndex &amp;&amp; p2 &lt;= endIndex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[p1] &lt;= arr[p2]) &#123;</span><br><span class="line">            tempArr[p++] = arr[p1++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tempArr[p++] = arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 右侧小数组已排序完毕，左侧小数组还有剩余，将左侧小数组元素依次放入大数组尾部</span></span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= midIndex) &#123;</span><br><span class="line">        tempArr[p++] = arr[p1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左侧小数组已排序完毕，右侧小数组还有剩余，将右侧小数组元素依次放入大数组尾部</span></span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= endIndex) &#123;</span><br><span class="line">        tempArr[p++] = arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (let i = <span class="number">0</span>; i &lt; tempArr.length; i++) &#123;</span><br><span class="line">        arr[i + startIndex] = tempArr[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let arr = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">sort</span>(arr);</span><br><span class="line">console.<span class="built_in">log</span>(arr);</span><br></pre></td></tr></table></figure><p><strong>参考链接</strong>：<a href="https://blog.csdn.net/qq_35344198/article/details/106857042?ops_request_misc=%7B%22request_id%22:%22164838628116780271923339%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=164838628116780271923339&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-106857042.142%5Ev5%5Epc_search_insert_es_download,143%5Ev6%5Econtrol&utm_term=%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F&spm=1018.2226.3001.4187">(50条消息) 十大经典排序算法-归并排序算法详解_小小学编程的博客-CSDN博客_归并排序算法</a></p><p><strong>常见排序算法时间、空间复杂度</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/FA2B55F41C58721193D0F8BB193B5F7A.png" alt="FA2B55F41C58721193D0F8BB193B5F7A"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法DAY-06</title>
      <link href="/%E7%AE%97%E6%B3%95DAY-06/"/>
      <url>/%E7%AE%97%E6%B3%95DAY-06/</url>
      
        <content type="html"><![CDATA[<h1 id="算法总结-DAY-06"><a href="#算法总结-DAY-06" class="headerlink" title="算法总结 DAY_06"></a>算法总结 DAY_06</h1><h2 id="链表专题"><a href="#链表专题" class="headerlink" title="链表专题"></a>链表专题</h2><h2 id="删除链表中的节点"><a href="#删除链表中的节点" class="headerlink" title="删除链表中的节点"></a>删除链表中的节点</h2><p><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/">LeetCode 237. delete-node-in-a-linked-list</a></p><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220325165146862.png" alt="image-20220325165146862" style="zoom:67%;" /><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="和下一个节点交换"><a href="#和下一个节点交换" class="headerlink" title="和下一个节点交换"></a>和下一个节点交换</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;val = node-&gt;next-&gt;val;</span><br><span class="line">        node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<code>O(1)</code></li><li>空间复杂度：<code>O(1)</code></li></ul><h2 id="删除链表的倒数第-N-个结点"><a href="#删除链表的倒数第-N-个结点" class="headerlink" title="删除链表的倒数第 N 个结点"></a>删除链表的倒数第 N 个结点</h2><p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">LeetCode 19. remove-nth-node-from-end-of-list</a></p><h3 id="题目：-1"><a href="#题目：-1" class="headerlink" title="题目："></a>题目：</h3><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220325161729752.png" alt="image-20220325161729752" style="zoom:80%;" /><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><h4 id="计算链表长度"><a href="#计算链表长度" class="headerlink" title="计算链表长度"></a>计算链表长度</h4><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220325162841006.png" alt="image-20220325162841006" style="zoom:67%;" /><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">        ListNode* head1 = head;</span><br><span class="line">        <span class="keyword">while</span>(head1 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            head1 = head1 -&gt; next;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(size == n)&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* head2 = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size - n; i++)&#123;</span><br><span class="line">            head2 = head2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        head2-&gt;next = head2-&gt;next-&gt;next;</span><br><span class="line">        ListNode* ans = head;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>官方题解</strong>：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            ++length;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head); <span class="comment">// 知识点1： 新链表建立</span></span><br><span class="line">        <span class="keyword">int</span> length = <span class="built_in">getLength</span>(head);</span><br><span class="line">        ListNode* cur = dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length - n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        ListNode* ans = dummy-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummy;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(L)，其中 L 是链表的长度。</li><li>空间复杂度：O(1)。</li></ul><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220325163149926.png" alt="image-20220325163149926" style="zoom:67%;" /><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        stack&lt;ListNode*&gt; stk;</span><br><span class="line">        ListNode* cur = dummy;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            stk.<span class="built_in">push</span>(cur);</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* prev = stk.<span class="built_in">top</span>();</span><br><span class="line">        prev-&gt;next = prev-&gt;next-&gt;next;</span><br><span class="line">        ListNode* ans = dummy-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummy;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<code>O(L)</code>，其中 L 是链表的长度。</li><li>空间复杂度：<code>O(L)</code>，其中 L 是链表的长度。主要为栈的开销。</li></ul><h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220325163350726.png" alt="image-20220325163350726" style="zoom:80%;" /><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        ListNode* first = head;</span><br><span class="line">        ListNode* second = dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            first = first-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (first) &#123;</span><br><span class="line">            first = first-&gt;next;</span><br><span class="line">            second = second-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        second-&gt;next = second-&gt;next-&gt;next;</span><br><span class="line">        ListNode* ans = dummy-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummy;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<code>O(L)</code>，其中 L是链表的长度。</li><li>空间复杂度：<code>O(1)</code>。</li></ul><h3 id="知识点拓展"><a href="#知识点拓展" class="headerlink" title="知识点拓展"></a>知识点拓展</h3><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>定义一个新节点，<code>val</code>为0，<code>next</code>为head。这样做是因为head节点也可能被删除，避免增加更多代码处理边界情况。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br></pre></td></tr></table></figure><p>定义一个新节点，并且节点指向<strong>head</strong>。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ListNode* first = head;</span><br></pre></td></tr></table></figure><h2 id="删除排序链表中的重复元素"><a href="#删除排序链表中的重复元素" class="headerlink" title="删除排序链表中的重复元素"></a>删除排序链表中的重复元素</h2><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">LeetCode 83. remove-duplicates-from-sorted-list</a></p><h3 id="题目：-2"><a href="#题目：-2" class="headerlink" title="题目："></a>题目：</h3><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220325170423070.png" alt="image-20220325170423070" style="zoom:67%;" /><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><h4 id="一次遍历"><a href="#一次遍历" class="headerlink" title="一次遍历"></a>一次遍历</h4><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220325170659822.png" alt="image-20220325170659822" style="zoom:80%;" /><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* deleteDuplicates(ListNode* head) &#123;</span><br><span class="line">        ListNode* h = head;</span><br><span class="line">        if(head == nullptr)&#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        while(h-&gt;next)&#123;</span><br><span class="line">            if(h-&gt;val == h-&gt;next-&gt;val)&#123;</span><br><span class="line">                h-&gt;next = h-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                h = h-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<code>O(n)</code>，其中 n 是链表的长度。</li><li>空间复杂度：<code>O(1)</code>。</li></ul><h2 id="旋转链表"><a href="#旋转链表" class="headerlink" title="旋转链表"></a>旋转链表</h2><p><a href="https://leetcode-cn.com/problems/rotate-list/">LeetCode 61. rotate-list</a></p><h3 id="题目：-3"><a href="#题目：-3" class="headerlink" title="题目："></a>题目：</h3><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220325170956971.png" alt="image-20220325170956971" style="zoom:80%;" /><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><h4 id="闭合为环"><a href="#闭合为环" class="headerlink" title="闭合为环"></a>闭合为环</h4><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220325182615940.png" alt="image-20220325182615940" style="zoom:80%;" /><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!head || head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* c = head;</span><br><span class="line">        <span class="keyword">while</span>(c != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            c = c -&gt; next;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k%size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* c1 = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size-(k%size); i++)&#123;</span><br><span class="line">            c1 = c1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* c2 = c1;</span><br><span class="line">        ListNode* c3 = head;</span><br><span class="line">        ListNode* ans = c1-&gt;next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k%size; i++)&#123;</span><br><span class="line">            c2 = c2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        c1-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        c2-&gt;next = c3;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>官方题解</strong>：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">        ListNode* iter = head;</span><br><span class="line">        <span class="keyword">while</span> (iter-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            iter = iter-&gt;next;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> add = n - k % n;</span><br><span class="line">        <span class="keyword">if</span> (add == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        iter-&gt;next = head;</span><br><span class="line">        <span class="keyword">while</span> (add--) &#123;</span><br><span class="line">            iter = iter-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* ret = iter-&gt;next;</span><br><span class="line">        iter-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<code>O(n)</code>，最坏情况下，我们需要遍历该链表两次。</li><li>空间复杂度：<code>O(1)</code>，我们只需要常数的空间存储若干变量。</li></ul><h2 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h2><p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">LeetCode 24. swap-nodes-in-pairs</a></p><h3 id="题目：-4"><a href="#题目：-4" class="headerlink" title="题目："></a>题目：</h3><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220325183418965.png" alt="image-20220325183418965" style="zoom:80%;" /><h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p><strong>思路与算法</strong></p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220325183755155.png" alt="image-20220325183755155" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220325183644738.png" alt="image-20220325183644738" style="zoom:50%;" /><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* cur1 = head;</span><br><span class="line">        ListNode* cur2 = head-&gt;next;</span><br><span class="line">        ListNode* ans = head-&gt;next;    <span class="comment">//交换后从第二个节点开始</span></span><br><span class="line">        <span class="keyword">while</span>(cur1-&gt;next-&gt;next &amp;&amp; cur2-&gt;next-&gt;next)&#123;  <span class="comment">//交换节点</span></span><br><span class="line">            ListNode* temp1 = cur1-&gt;next-&gt;next;</span><br><span class="line">            ListNode* temp2 = cur2-&gt;next-&gt;next;</span><br><span class="line">            cur1-&gt;next = temp2;</span><br><span class="line">            cur2-&gt;next = cur1; </span><br><span class="line">            cur1 = temp1;</span><br><span class="line">            cur2 = cur2-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur1-&gt;next-&gt;next)                <span class="comment">//处理最后两个节点</span></span><br><span class="line">            cur1-&gt;next = cur1-&gt;next-&gt;next;  <span class="comment">//节点为三个</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cur1-&gt;next = <span class="literal">nullptr</span>;           <span class="comment">//节点大于三</span></span><br><span class="line">        cur2-&gt;next = cur1;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>官方题解</strong>：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>); <span class="comment">//创建值为0的</span></span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line">        ListNode* temp = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (temp-&gt;next != <span class="literal">nullptr</span> &amp;&amp; temp-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode* node1 = temp-&gt;next;</span><br><span class="line">            ListNode* node2 = temp-&gt;next-&gt;next;</span><br><span class="line">            temp-&gt;next = node2;</span><br><span class="line">            node1-&gt;next = node2-&gt;next;</span><br><span class="line">            node2-&gt;next = node1;</span><br><span class="line">            temp = node1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<code>O(n)</code>，其中 n 是链表的节点数量。需要对每个节点进行更新指针的操作。</li><li>空间复杂度：<code>O(1)</code>。</li></ul><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p><strong>思路与算法</strong></p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220325184332959.png" alt="image-20220325184332959" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220325185110423.png" alt="image-20220325185110423" style="zoom:80%;" /><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* newHead = head-&gt;next;</span><br><span class="line">        head-&gt;next = <span class="built_in">swapPairs</span>(newHead-&gt;next);</span><br><span class="line">        newHead-&gt;next = head;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<code>O(n)</code>，其中 n 是链表的节点数量。需要对每个节点进行更新指针的操作。</li><li>空间复杂度：<code>O(n)</code>，其中 n 是链表的节点数量。空间复杂度主要取决于递归调用的栈空间。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法DAY-05</title>
      <link href="/%E7%AE%97%E6%B3%95DAY-05/"/>
      <url>/%E7%AE%97%E6%B3%95DAY-05/</url>
      
        <content type="html"><![CDATA[<h1 id="算法总结-DAY-05"><a href="#算法总结-DAY-05" class="headerlink" title="算法总结 DAY_05"></a>算法总结 DAY_05</h1><h2 id="二分专题"><a href="#二分专题" class="headerlink" title="二分专题"></a>二分专题</h2><p>复杂度<code>log(n)</code>：二分法的”代言词“</p><p><strong>二分模板</strong>：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">int</span> mid;</span><br><span class="line">      <span class="keyword">while</span>(l &lt;= r)&#123;      <span class="comment">// 另一种模板 l &lt;r</span></span><br><span class="line">          mid = l + (r - l) / <span class="number">2</span>;  <span class="comment">//左中点</span></span><br><span class="line">          <span class="keyword">if</span>(target == nums[mid])</span><br><span class="line">              <span class="keyword">return</span> mid;</span><br><span class="line">          <span class="keyword">if</span>(target &lt; nums[mid])</span><br><span class="line">              r = mid - <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span>(target &gt; nums[mid])</span><br><span class="line">              l = mid + <span class="number">1</span>;    </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> l;</span><br></pre></td></tr></table></figure><p><strong>详细讲解文章链接：</strong></p><p><a href="https://leetcode-cn.com/circle/article/oudzAx/">关于二分法三个模板更详细的说明</a></p><h2 id="第一个错误的版本"><a href="#第一个错误的版本" class="headerlink" title="第一个错误的版本"></a>第一个错误的版本</h2><p><a href="https://leetcode-cn.com/problems/first-bad-version/">LeetCode 278. first-bad-version</a></p><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220323152026209.png" alt="image-20220323152026209" style="zoom:80%;" /><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The API isBadVersion is defined for you.</span></span><br><span class="line"><span class="comment">// bool isBadVersion(int version);</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> r = n;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isBadVersion</span>(mid))&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l = mid + <span class="number">1</span>;    </span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>官方题解</strong>：</p><p>用了另一种二分模板</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = n;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 循环直至区间左右端点相同</span></span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>; <span class="comment">// 防止计算时溢出</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isBadVersion</span>(mid)) &#123;</span><br><span class="line">                right = mid; <span class="comment">// 答案在区间 [left, mid] 中</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>; <span class="comment">// 答案在区间 [mid+1, right] 中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时有 left == right，区间缩为一个点，即为答案</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<code>O(log n)</code>，其中 n是给定版本的数量。</li><li>空间复杂度：<code>O(1)</code>。我们只需要常数的空间保存若干变量。</li></ul><h2 id="寻找旋转排序数组中的最小值"><a href="#寻找旋转排序数组中的最小值" class="headerlink" title="寻找旋转排序数组中的最小值"></a>寻找旋转排序数组中的最小值</h2><p><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">LeetCode 153. find-minimum-in-rotated-sorted-array</a></p><h3 id="题目：-1"><a href="#题目：-1" class="headerlink" title="题目："></a>题目：</h3><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220323154217773.png" alt="image-20220323154217773" style="zoom:80%;" /><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><h4 id="二分法-1"><a href="#二分法-1" class="headerlink" title="二分法"></a>二分法</h4><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220323154945327.png" alt="image-20220323154945327" style="zoom:67%;" /><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(r == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[r];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">min</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[nums.<span class="built_in">size</span>() - <span class="number">1</span>] == nums[mid])</span><br><span class="line">                <span class="keyword">return</span> nums[mid];</span><br><span class="line">            <span class="keyword">if</span>(nums[nums.<span class="built_in">size</span>() - <span class="number">1</span>] &gt; nums[mid])</span><br><span class="line">                r = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l = mid + <span class="number">1</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>官方题解</strong>：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> pivot = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[pivot] &lt; nums[high]) &#123;</span><br><span class="line">                high = pivot;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                low = pivot + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[low];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：时间复杂度为 <code>O(logn)</code>，其中 n 是数组 nums 的长度。在二分查找的过程中，每一步会忽略一半的区间，因此时间复杂度为 O(logn)。</p></li><li><p>空间复杂度：<code>O(1)</code>。</p></li></ul><h2 id="H-指数-II"><a href="#H-指数-II" class="headerlink" title="H 指数 II"></a>H 指数 II</h2><p><a href="https://leetcode-cn.com/problems/h-index-ii/">LeetCode 153. h-index-ii</a></p><h3 id="题目：-2"><a href="#题目：-2" class="headerlink" title="题目："></a>题目：</h3><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220323160330430.png" alt="image-20220323160330430" style="zoom:80%;" /><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><h4 id="二分法-2"><a href="#二分法-2" class="headerlink" title="二分法"></a>二分法</h4><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220323160817652.png" alt="image-20220323160817652" style="zoom:80%;" /><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hIndex</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; citations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = citations.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(n - mid &gt; citations[mid])</span><br><span class="line">                l = mid + <span class="number">1</span>; </span><br><span class="line">            <span class="keyword">if</span>(n - mid &lt;= citations[mid])</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">                   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n - l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<code>O(logn)</code>，其中 n 为数组 citations 的长度。二分查找的时间复杂度为 O(logn)。</p></li><li><p>空间复杂度：<code>O(1)</code>。</p></li></ul><h2 id="寻找峰值"><a href="#寻找峰值" class="headerlink" title="寻找峰值"></a>寻找峰值</h2><p><a href="https://leetcode-cn.com/problems/find-peak-element/">LeetCode 162. find-peak-element</a></p><h3 id="题目：-3"><a href="#题目：-3" class="headerlink" title="题目："></a>题目：</h3><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220323162801584.png" alt="image-20220323162801584" style="zoom:80%;" /><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><h4 id="二分法-3"><a href="#二分法-3" class="headerlink" title="二分法"></a>二分法</h4><p><strong>思路与算法</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220323163218177.png" alt="image-20220323163218177"></p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220323163305802.png" alt="image-20220323163305802" style="zoom:25%;" /><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(r == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(r == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>] &gt; nums[<span class="number">1</span>] ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid != <span class="number">0</span> &amp;&amp; mid != (nums.<span class="built_in">size</span>()<span class="number">-1</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid<span class="number">-1</span>] &lt; nums[mid] &amp;&amp; nums[mid] &gt; nums[mid+<span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">return</span> mid;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid<span class="number">-1</span>] &gt; nums[mid] &amp;&amp; nums[mid] &gt; nums[mid+<span class="number">1</span>])</span><br><span class="line">                    r = mid - <span class="number">1</span>; </span><br><span class="line">                <span class="keyword">if</span>(nums[mid+<span class="number">1</span>] &gt; nums[mid] &amp;&amp; nums[mid] &gt; nums[mid<span class="number">-1</span>])</span><br><span class="line">                    l = mid + <span class="number">1</span>;  </span><br><span class="line">                <span class="keyword">if</span>(nums[mid+<span class="number">1</span>] &gt; nums[mid] &amp;&amp; nums[mid] &lt; nums[mid<span class="number">-1</span>]) </span><br><span class="line">                    <span class="comment">// 两边都大（位于山谷） 默认朝右走</span></span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(mid == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[mid] &gt; nums[mid+<span class="number">1</span>])</span><br><span class="line">                        <span class="keyword">return</span> mid;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">if</span>(mid == (nums.<span class="built_in">size</span>()<span class="number">-1</span>))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[mid] &gt; nums[mid<span class="number">-1</span>])</span><br><span class="line">                        <span class="keyword">return</span> mid;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>官方题解</strong>：</p><p>差别在于官方题解将边界情况用另一个函数分析</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 辅助函数，输入下标 i，返回一个二元组 (0/1, nums[i])</span></span><br><span class="line">        <span class="comment">// 方便处理 nums[-1] 以及 nums[n] 的边界情况</span></span><br><span class="line">        <span class="keyword">auto</span> get = [&amp;](<span class="keyword">int</span> i) -&gt; pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">-1</span> || i == n) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">1</span>, nums[i]&#125;;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>, ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">get</span>(mid - <span class="number">1</span>) &lt; <span class="built_in">get</span>(mid) &amp;&amp; <span class="built_in">get</span>(mid) &gt; <span class="built_in">get</span>(mid + <span class="number">1</span>)) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">get</span>(mid) &lt; <span class="built_in">get</span>(mid + <span class="number">1</span>)) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<code>O(log n)</code>，其中 n是数组 nums 的长度。</li><li>空间复杂度：<code>O(1)</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法DAY-04</title>
      <link href="/%E7%AE%97%E6%B3%95DAY-04/"/>
      <url>/%E7%AE%97%E6%B3%95DAY-04/</url>
      
        <content type="html"><![CDATA[<h1 id="算法总结-DAY-04"><a href="#算法总结-DAY-04" class="headerlink" title="算法总结 DAY_04"></a>算法总结 DAY_04</h1><h2 id="二分专题"><a href="#二分专题" class="headerlink" title="二分专题"></a>二分专题</h2><p>复杂度<code>log(n)</code>：二分法的”代言词“</p><p><strong>二分模板</strong>：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">int</span> mid;</span><br><span class="line">      <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">          mid = l + (r - l) / <span class="number">2</span>;  <span class="comment">//左中点</span></span><br><span class="line">          <span class="keyword">if</span>(target == nums[mid])</span><br><span class="line">              <span class="keyword">return</span> mid;</span><br><span class="line">          <span class="keyword">if</span>(target &lt; nums[mid])</span><br><span class="line">              r = mid - <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span>(target &gt; nums[mid])</span><br><span class="line">              l = mid + <span class="number">1</span>;    </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> l;</span><br></pre></td></tr></table></figure><p><strong>详细讲解文章链接：</strong></p><p><a href="https://leetcode-cn.com/circle/article/oudzAx/">关于二分法三个模板更详细的说明</a></p><h2 id="x-的平方根"><a href="#x-的平方根" class="headerlink" title="x 的平方根"></a>x 的平方根</h2><p><a href="https://leetcode-cn.com/problems/sqrtx/">LeetCode 69. sqrtx</a></p><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220323133836470.png" alt="image-20220323133836470" style="zoom:80%;" /><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h4><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220323134126730.png" alt="image-20220323134126730"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = x, ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">long</span> <span class="keyword">long</span>)mid * mid &lt;= x) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<code>O(logx)</code>，即为二分查找需要的次数。</li><li>空间复杂度：<code>O(1)</code>。</li></ul><h4 id="牛顿迭代"><a href="#牛顿迭代" class="headerlink" title="牛顿迭代"></a>牛顿迭代</h4><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220323135431834.png" alt="image-20220323135431834" style="zoom:67%;" /><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> x = a;</span><br><span class="line">        <span class="keyword">while</span> (x * x &gt; a) x = (x + a / x) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<code>O(log x)</code>，此方法是二次收敛的，相较于二分查找更快。</li><li>空间复杂度：<code>O(1)</code>。</li></ul><h4 id="雷神之锤3-算法"><a href="#雷神之锤3-算法" class="headerlink" title="雷神之锤3 算法"></a>雷神之锤3 算法</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">InvSqrt</span><span class="params">(<span class="keyword">float</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">float</span> xhalf = <span class="number">0.5f</span>*x;</span><br><span class="line"><span class="keyword">int</span> i = *(<span class="keyword">int</span>*)&amp;x; <span class="comment">// get bits for floating VALUE</span></span><br><span class="line">i = <span class="number">0x5f375a86</span>- (i&gt;&gt;<span class="number">1</span>); <span class="comment">// gives initial guess y0</span></span><br><span class="line">x = *(<span class="keyword">float</span>*)&amp;i; <span class="comment">// convert bits BACK to float</span></span><br><span class="line">x = x*(<span class="number">1.5f</span>-xhalf*x*x); <span class="comment">// Newton step, repeating increases accuracy</span></span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>参考资料：<a href="http://zh.wikipedia.org/wiki/%E5%B9%B3%E6%96%B9%E6%A0%B9%E5%80%92%E6%95%B0%E9%80%9F%E7%AE%97%E6%B3%95">平方根倒数速算法</a></p><p>​                <a href="https://zhuanlan.zhihu.com/p/74670736">快速平方根倒数算法 - 知乎 (zhihu.com)</a></p><h2 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a>搜索插入位置</h2><p><a href="https://leetcode-cn.com/problems/search-insert-position/">LeetCode 35. search-insert-position</a></p><h3 id="题目：-1"><a href="#题目：-1" class="headerlink" title="题目："></a>题目：</h3><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220323140707898.png" alt="image-20220323140707898" style="zoom:80%;" /><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><h4 id="二分法-1"><a href="#二分法-1" class="headerlink" title="二分法"></a>二分法</h4><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220323141950125.png" alt="image-20220323141950125" style="zoom:80%;" /><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(target == nums[mid])</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(target &lt; nums[mid])</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(target &gt; nums[mid])</span><br><span class="line">                l = mid + <span class="number">1</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<code>O(logn)</code>，其中 n 为数组的长度。二分查找所需的时间复杂度为 O(logn)。</li><li>空间复杂度：<code>O(1)</code>。我们只需要常数空间存放若干变量。</li></ul><h2 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a>在排序数组中查找元素的第一个和最后一个位置</h2><p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">LeetCode 34. find-first-and-last-position-of-element-in-sorted-array</a></p><h3 id="题目：-2"><a href="#题目：-2" class="headerlink" title="题目："></a>题目：</h3><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220323142118802.png" alt="image-20220323142118802"></p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><h4 id="二分法-2"><a href="#二分法-2" class="headerlink" title="二分法"></a>二分法</h4><p>因为数组都是整数，可以用<code>&#123;target-0.5, target+0.5&#125;</code>两个值来确定位置；</p><p>也可以先找到第一个与<code>target</code>的值，再慢慢向两边扩直到不等于target；</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">int</span> ans[<span class="number">2</span>] = &#123;<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">double</span> t[<span class="number">2</span>] = &#123;target<span class="number">-0.5</span>, target+<span class="number">0.5</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> r = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">                mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(t[i] &lt; nums[mid])</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(t[i] &gt; nums[mid])</span><br><span class="line">                    l = mid + <span class="number">1</span>;    </span><br><span class="line">            &#125;</span><br><span class="line">            ans[i] = l - i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans[<span class="number">0</span>] &gt; ans[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> &#123;ans[<span class="number">0</span>],ans[<span class="number">1</span>]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度： <code>O(logn)</code> ，其中 n 为数组的长度。二分查找的时间复杂度为O(logn)，一共会执行两次，因此总时间复杂度为 O(logn)。</li><li>空间复杂度：<code>O(1)</code> 。只需要常数空间存放若干变量。</li></ul><h2 id="搜索二维矩阵"><a href="#搜索二维矩阵" class="headerlink" title="搜索二维矩阵"></a>搜索二维矩阵</h2><p><a href="https://leetcode-cn.com/problems/search-a-2d-matrix/">LeetCode 74. search-a-2d-matrix</a></p><h3 id="题目：-3"><a href="#题目：-3" class="headerlink" title="题目："></a>题目：</h3><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220323143754118.png" alt="image-20220323143754118" style="zoom:80%;" /><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><h4 id="两次二分查找"><a href="#两次二分查找" class="headerlink" title="两次二分查找"></a>两次二分查找</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(m != <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">                mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(target == matrix[mid][n<span class="number">-1</span>])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(target &lt; matrix[mid][n<span class="number">-1</span>])</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(target &gt; matrix[mid][n<span class="number">-1</span>])</span><br><span class="line">                    l = mid + <span class="number">1</span>;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        h = l;</span><br><span class="line">        <span class="keyword">if</span>(h &gt;= m)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        l = <span class="number">0</span>;</span><br><span class="line">        r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n != <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">                mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(target == matrix[h][mid])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(target &lt; matrix[h][mid])</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(target &gt; matrix[h][mid])</span><br><span class="line">                    l = mid + <span class="number">1</span>;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target == matrix[h][<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>官方题解</strong>：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> row = <span class="built_in">upper_bound</span>(matrix.<span class="built_in">begin</span>(), matrix.<span class="built_in">end</span>(), target, [](<span class="keyword">const</span> <span class="keyword">int</span> b, <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt; &amp;a) &#123;</span><br><span class="line">            <span class="keyword">return</span> b &lt; a[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (row == matrix.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        --row;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">binary_search</span>(row-&gt;<span class="built_in">begin</span>(), row-&gt;<span class="built_in">end</span>(), target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<code>O(logm+logn)=O(logmn)</code>，其中 m 和 n 分别是矩阵的行数和列数。</li><li>空间复杂度：<code>O(1)</code>。</li></ul><h4 id="一次二分查找"><a href="#一次二分查找" class="headerlink" title="一次二分查找"></a>一次二分查找</h4><p><strong>思路</strong></p><p>若将矩阵每一行拼接在上一行的末尾，则会得到一个升序数组，我们可以在该数组上二分找到目标元素。</p><p>代码实现时，可以二分升序数组的下标，将其映射到原矩阵的行和列上。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = m * n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (high - low) / <span class="number">2</span> + low;</span><br><span class="line">            <span class="keyword">int</span> x = matrix[mid / n][mid % n];</span><br><span class="line">            <span class="keyword">if</span> (x &lt; target) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; target) &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<code>O(log mn)</code>，其中 m 和 n 分别是矩阵的行数和列数。</li><li>空间复杂度：<code>O(1)</code>。</li></ul><h2 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a>搜索旋转排序数组</h2><p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">LeetCode 33. search-in-rotated-sorted-array</a></p><h3 id="题目：-4"><a href="#题目：-4" class="headerlink" title="题目："></a>题目：</h3><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220323150544769.png" alt="image-20220323150544769" style="zoom:80%;" /><h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><h4 id="二分法-3"><a href="#二分法-3" class="headerlink" title="二分法"></a>二分法</h4><p><strong>思路和算法</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220323150824424.png" alt="image-20220323150824424"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(r == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>] == target ? <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(target == nums[mid])</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(nums[<span class="number">0</span>] &lt;= nums[mid])&#123;</span><br><span class="line">                <span class="keyword">if</span>(target &gt;= nums[<span class="number">0</span>] &amp;&amp; target &lt; nums[mid])</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(target &lt;= nums[nums.<span class="built_in">size</span>()<span class="number">-1</span>] &amp;&amp; target &gt; nums[mid])</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    r = mid - <span class="number">1</span>;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度： <code>O(logn)</code>，其中 n 为 nums 数组的大小。整个算法时间复杂度即为二分查找的时间复杂度 O(logn)。</li><li>空间复杂度： <code>O(1)</code> 。我们只需要常数级别的空间存放变量。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法DAY-03</title>
      <link href="/%E7%AE%97%E6%B3%95DAY-03/"/>
      <url>/%E7%AE%97%E6%B3%95DAY-03/</url>
      
        <content type="html"><![CDATA[<h1 id="算法总结-DAY-03"><a href="#算法总结-DAY-03" class="headerlink" title="算法总结 DAY_03"></a>算法总结 DAY_03</h1><h2 id="寻找重复的数"><a href="#寻找重复的数" class="headerlink" title="寻找重复的数"></a>寻找重复的数</h2><p><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/">LeetCode 287. find-the-duplicate-number</a></p><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220319145857496.png" alt="image-20220319145857496"></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>不满足空间<code>O(1)</code>的要求</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// unordered_map&lt;int, int&gt; map;</span></span><br><span class="line">        <span class="comment">// for(int i=0; i&lt;nums.size(); i++)&#123;</span></span><br><span class="line">        <span class="comment">//     map[nums[i]] ++;</span></span><br><span class="line">        <span class="comment">//     if(map[nums[i]] &gt; 1)&#123;</span></span><br><span class="line">        <span class="comment">//         return nums[i];</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        set&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">count</span>(nums[i]) == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220320115902117.png" alt="image-20220320115902117"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = n - <span class="number">1</span>, ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                cnt += nums[i] &lt;= mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &lt;= mid) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">                ans = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>复杂度分析</p><ul><li>时间复杂度：<code>O(nlogn)</code>，其中 n 为 nums 数组的长度。二分查找最多需要二分 O(logn) 次，每次判断的时候需要O(n) 遍历 nums 数组求解小于等于 mid 的数的个数，因此总时间复杂度为 O(nlogn)。</li><li>空间复杂度：<code>O(1)</code>。我们只需要常数空间存放若干变量。</li></ul><h4 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//知识点1；弗洛伊德判圈算法</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125; <span class="keyword">while</span> (slow != fast);</span><br><span class="line">        slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<code>O(n)</code>。「Floyd 判圈算法」时间复杂度为线性的时间复杂度。</li><li>空间复杂度：<code>O(1)</code>。我们只需要常数空间存放若干变量。</li></ul><h3 id="知识点拓展"><a href="#知识点拓展" class="headerlink" title="知识点拓展"></a>知识点拓展</h3><h4 id="弗洛伊德判圈算法"><a href="#弗洛伊德判圈算法" class="headerlink" title="弗洛伊德判圈算法"></a>弗洛伊德判圈算法</h4><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220321170935876.png" alt="image-20220321170935876" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220320120222194.png" alt="image-20220320120222194" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220321170749874.png" alt="image-20220321170749874" style="zoom:67%;" /><h2 id="预测赢家"><a href="#预测赢家" class="headerlink" title="预测赢家"></a>预测赢家</h2><p><a href="https://leetcode-cn.com/problems/predict-the-winner/">LeetCode 486. predict-the-winner</a></p><h3 id="题目：-1"><a href="#题目：-1" class="headerlink" title="题目："></a>题目：</h3><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220321164123782.png" alt="image-20220321164123782" style="zoom:67%;" /><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p><strong>递归到动态规划的过程</strong>参考：<a href="https://chenduowen233.github.io/%E4%BB%8E%E6%9A%B4%E5%8A%9B%E9%80%92%E5%BD%92%E5%88%B0%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">从暴力递归到动态规划</a></p><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/486_fig1.png" alt="fig1" style="zoom: 67%;" /><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">PredictTheWinner</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">total</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, <span class="number">1</span>) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">total</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> turn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[start] * turn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> scoreStart = nums[start] * turn + <span class="built_in">total</span>(nums, start + <span class="number">1</span>, end, -turn);</span><br><span class="line">        <span class="keyword">int</span> scoreEnd = nums[end] * turn + <span class="built_in">total</span>(nums, start, end - <span class="number">1</span>, -turn);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(scoreStart * turn, scoreEnd * turn) * turn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220321165942045.png" alt="image-20220321165942045"></p><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p><code>dp[i][j]</code>表示当数组剩下的部分为下标 <code>i</code> 到下标 j 时，即在下标范围 [i, j] 中，当前玩家与另一个玩家的分数之差的最大值，注意当前玩家不一定是先手。</p><p>最后判断<code>dp[0][n-1]</code> 的值，如果大于或等于 0，则先手得分大于或等于后手得分，因此先手成为赢家，否则后手成为赢家。</p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220321164231124.png" alt="image-20220321164231124" style="zoom: 33%;" /><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">PredictTheWinner</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> dp[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            dp[i][i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;n; j++)&#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i][i]-dp[i+<span class="number">1</span>][j], dp[j][j]-dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>] &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>官方题解：</p><p>计算 dp 的第 i 行的值时，只需要使用到 dp 的第 i 行和第 i+1 行的值，因此可以使用一维数组代替二维数组，对空间进行优化。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">PredictTheWinner</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">auto</span> dp = vector&lt;<span class="keyword">int</span>&gt;(length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            dp[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(nums[i] - dp[j], nums[j] - dp[j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[length - <span class="number">1</span>] &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220321165005830.png" alt="image-20220321165005830" style="zoom:80%;" /><h2 id="前K个高频单词"><a href="#前K个高频单词" class="headerlink" title="前K个高频单词"></a>前K个高频单词</h2><p><a href="https://leetcode-cn.com/problems/top-k-frequent-words/">LeetCode 692. top-k-frequent-words</a></p><h3 id="题目：-2"><a href="#题目：-2" class="headerlink" title="题目："></a>题目：</h3><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220321102926071.png" alt="image-20220321102926071"></p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><h4 id="哈希表-排序"><a href="#哈希表-排序" class="headerlink" title="哈希表+排序"></a>哈希表+排序</h4><p>使用哈希表记录每种单词出现的次数，再进行排序。</p><p>使用<code>map</code>与<code>unordered_map</code>的区别：</p><p><code>map</code>底层采用的是红黑树的实现，<code>Key</code>值默认按由小到大排序，符号题目要求，因此重写<code>stable_sort()</code>函数时，无需比较key值；</p><p>而<code>unordered_map</code>底层采用哈希表的实现，内部就是无序的，因此重写<code>sort()</code>函数时，需比较key值。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;string&gt;&amp; words, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// unordered_map&lt;string, int&gt; map;</span></span><br><span class="line">        map&lt;string, <span class="keyword">int</span>&gt; map;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; w : words)&#123;</span><br><span class="line">            map[w] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;pair&lt;string, <span class="keyword">int</span>&gt;&gt; vecs;</span><br><span class="line">        <span class="comment">// for (auto it = map.begin();it!= map.end();it++) &#123;</span></span><br><span class="line">        <span class="comment">//     vecs.push_back(make_pair(it-&gt;first, it-&gt;second));</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// 知识点1： assign() 函数的使用</span></span><br><span class="line">        vecs.<span class="built_in">assign</span>(map.<span class="built_in">begin</span>(), map.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 知识点2： sort() 函数重写</span></span><br><span class="line">        <span class="comment">// 知识点3. stable_sort()与sort()的区别</span></span><br><span class="line">        <span class="built_in">stable_sort</span>(vecs.<span class="built_in">begin</span>(), vecs.<span class="built_in">end</span>(), [](pair&lt;string, <span class="keyword">int</span>&gt;a, pair&lt;string, <span class="keyword">int</span>&gt; b) -&gt;    <span class="keyword">bool</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(vecs[i].first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>官方题解：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;string&gt;&amp; words, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;string, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; word : words) &#123;</span><br><span class="line">            ++cnt[word];</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;string&gt; rec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [key, value] : cnt) &#123;</span><br><span class="line">            rec.<span class="built_in">emplace_back</span>(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(rec.<span class="built_in">begin</span>(), rec.<span class="built_in">end</span>(), [&amp;](<span class="keyword">const</span> string&amp; a, <span class="keyword">const</span> string&amp; b) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cnt[a] == cnt[b] ? a &lt; b : cnt[a] &gt; cnt[b];</span><br><span class="line">        &#125;);</span><br><span class="line">        rec.<span class="built_in">erase</span>(rec.<span class="built_in">begin</span>() + k, rec.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> rec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220321104004861.png" alt="image-20220321104004861"></p><h4 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h4><p><strong>思路及算法</strong></p><p>对于前 k 大或前 k 小这类问题，有一个通用的解法：优先队列。优先队列可以在 O(logn) 的时间内完成插入或删除元素的操作（其中 n 为优先队列的大小），并可以 O(1) 地查询优先队列顶端元素。</p><p>在本题中，我们可以创建一个小根优先队列（顾名思义，就是优先队列顶端元素是最小元素的优先队列）。我们将每一个字符串插入到优先队列中，如果优先队列的大小超过了 k，那么我们就将优先队列顶端元素弹出。这样最终优先队列中剩下的 k 个元素就是前 k 个出现次数最多的单词。</p><p>（可以通过此方法解决数量级较小的Top-K问题）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;string&gt;&amp; words, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;string, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; word : words) &#123;</span><br><span class="line">            cnt[word]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> cmp = [](<span class="keyword">const</span> pair&lt;string, <span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> pair&lt;string, <span class="keyword">int</span>&gt;&amp; b) &#123;</span><br><span class="line">            <span class="keyword">return</span> a.second == b.second ? a.first &lt; b.first : a.second &gt; b.second;</span><br><span class="line">        &#125;;</span><br><span class="line">        priority_queue&lt;pair&lt;string, <span class="keyword">int</span>&gt;, vector&lt;pair&lt;string, <span class="keyword">int</span>&gt;&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">que</span>(cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : cnt) &#123;</span><br><span class="line">            que.<span class="built_in">emplace</span>(it);</span><br><span class="line">            <span class="keyword">if</span> (que.<span class="built_in">size</span>() &gt; k) &#123;</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">ret</span><span class="params">(k)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            ret[i] = que.<span class="built_in">top</span>().first;</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220321110804418.png" alt="image-20220321110804418"></p><h3 id="知识点拓展-1"><a href="#知识点拓展-1" class="headerlink" title="知识点拓展"></a>知识点拓展</h3><h4 id="assign-函数的使用"><a href="#assign-函数的使用" class="headerlink" title="assign() 函数的使用"></a>assign() 函数的使用</h4><p>STL中不同容器之间是不能直接赋值的，assign（）可以实现不同容器但相容的类型赋值，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list&lt;string&gt; names;</span><br><span class="line">vector&lt;const char*&gt; oldstyle = &#123; &quot;I&quot;,&quot;love&quot;,&quot;you&quot; &#125;;</span><br><span class="line">//names = oldstyle;错误！不同的类型不能执行&quot;=&quot;操作</span><br><span class="line">names.assign(oldstyle.cbegin(), oldstyle.cend());</span><br><span class="line">list&lt;string&gt;::iterator it;</span><br><span class="line">for (auto it = names.begin(); names.begin() != names.end(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/20160901100335975" alt="img"></p><h4 id="sort-函数的重写"><a href="#sort-函数的重写" class="headerlink" title="sort() 函数的重写"></a>sort() 函数的重写</h4><p><strong>sort函数有三种用法：</strong></p><p>一：对基本类型数组从小到大排序</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>( 数组名+n1，数组名+n2)； </span><br></pre></td></tr></table></figure><p>将数组中下标从n1到n2的元素进行从小到大排序，不包括n2，通过n1,n2 可以对整个或者部分数组排序</p><p>二：对元素类型为T的基本类型数组从大到小排序</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>( 数组名+n1，数组名+n2，greater&lt;T&gt;()); </span><br></pre></td></tr></table></figure><p>T对应各种元素类型</p><p>同样，将数组中下标从n1到n2的元素进行从大到小排序，不包括n2，通过n1,n2 可以对整个或者部分数组排序；</p><p>三：第三种自定义排序规则</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(数组名+n1，数组名+n2，排序规则结构名）;</span><br></pre></td></tr></table></figure><p>排序规则结构体定义：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构名&#123;</span></span><br><span class="line">     <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T &amp;a1, <span class="keyword">const</span> T &amp;a2)</span></span>&#123;</span><br><span class="line">          <span class="keyword">return</span>    ;</span><br><span class="line">     &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>返回值为true说明a1应该排在a2前面，false则相反，T对应元素类型。</p><p>或者直接写在sort()函数中：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(vecs.<span class="built_in">begin</span>(), vecs.<span class="built_in">end</span>(), [](pair&lt;string, <span class="keyword">int</span>&gt;a, pair&lt;string, <span class="keyword">int</span>&gt; b) -&gt;    <span class="keyword">bool</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>举个例子：</p><p>排序规则为按个位数从小到大排序：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rule1</span>&#123;</span> </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a1, <span class="keyword">const</span> <span class="keyword">int</span> &amp;a2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a1%<span class="number">10</span>)&lt;(a2%<span class="number">10</span>);</span><br><span class="line">&#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="stable-sort-与-sort-函数的区别"><a href="#stable-sort-与-sort-函数的区别" class="headerlink" title="stable_sort() 与 sort() 函数的区别"></a>stable_sort() 与 sort() 函数的区别</h4><p><code>stable_sort()</code>可以对<a href="https://so.csdn.net/so/search?q=vector&spm=1001.2101.3001.7020">vector</a>的某个成员进行排序，而且可保证相等元素的原本相对次序在排序后保持不变。</p><p>例如，如果你写一个比较函数:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">less_len</span><span class="params">(<span class="keyword">const</span> string &amp;str1, <span class="keyword">const</span> string &amp;str2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str1.<span class="built_in">length</span>() &lt; str2.<span class="built_in">length</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，**”apples” 和 “winter” 就是相等的，如果在”apples” 出现在”winter”前面，用带stable的函数排序后，他们的次序一定不变，如果你使用的是不带”stable”的函数排序，那么排序完 后，”winter”有可能在”apples”的前面。**</p><h2 id="数据流的中位数"><a href="#数据流的中位数" class="headerlink" title="数据流的中位数"></a>数据流的中位数</h2><p><a href="https://leetcode-cn.com/problems/find-median-from-data-stream/">LeetCode 295. find-median-from-data-stream</a></p><h3 id="题目：-3"><a href="#题目：-3" class="headerlink" title="题目："></a>题目：</h3><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220321114211354.png" alt="image-20220321114211354"></p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><h4 id="优先队列-1"><a href="#优先队列-1" class="headerlink" title="优先队列"></a>优先队列</h4><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220321114514930.png" alt="image-20220321114514930"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 知识点1： 优先队列</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt;&gt; queMin;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; queMax;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MedianFinder</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (queMin.<span class="built_in">empty</span>() || num &lt;= queMin.<span class="built_in">top</span>()) &#123;</span><br><span class="line">            queMin.<span class="built_in">push</span>(num);</span><br><span class="line">            <span class="keyword">if</span> (queMax.<span class="built_in">size</span>() + <span class="number">1</span> &lt; queMin.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                queMax.<span class="built_in">push</span>(queMin.<span class="built_in">top</span>());</span><br><span class="line">                queMin.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            queMax.<span class="built_in">push</span>(num);</span><br><span class="line">            <span class="keyword">if</span> (queMax.<span class="built_in">size</span>() &gt; queMin.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                queMin.<span class="built_in">push</span>(queMax.<span class="built_in">top</span>());</span><br><span class="line">                queMax.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (queMin.<span class="built_in">size</span>() &gt; queMax.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> queMin.<span class="built_in">top</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (queMin.<span class="built_in">top</span>() + queMax.<span class="built_in">top</span>()) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：addNum: <code>O(logn)</code>，其中 n 为累计添加的数的数量。</p><p>​                    findMedian: <code>O(1)</code>。</p></li><li><p>空间复杂度：<code>O(n)</code>，主要为优先队列的开销。</p></li></ul><h4 id="有序集合-双指针"><a href="#有序集合-双指针" class="headerlink" title="有序集合+双指针"></a>有序集合+双指针</h4><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220321142308045.png" alt="image-20220321142308045"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line">    multiset&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    multiset&lt;<span class="keyword">int</span>&gt;::iterator left, right;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MedianFinder</span>() : <span class="built_in">left</span>(nums.<span class="built_in">end</span>()), <span class="built_in">right</span>(nums.<span class="built_in">end</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">size_t</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        nums.<span class="built_in">insert</span>(num);</span><br><span class="line">        <span class="keyword">if</span> (!n) &#123;</span><br><span class="line">            left = right = nums.<span class="built_in">begin</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &lt; *left) &#123;</span><br><span class="line">                left--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt; *left &amp;&amp; num &lt; *right) &#123;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &gt;= *right) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right--;</span><br><span class="line">                left = right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (*left + *right) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：addNum: <code>O(logn)</code>，其中 n 为累计添加的数的数量。</p><p>​                    findMedian: <code>O(1)</code>。</p></li><li><p>空间复杂度：<code>O(n)</code>，主要为有序集合的开销。</p></li></ul><h3 id="知识点拓展-2"><a href="#知识点拓展-2" class="headerlink" title="知识点拓展"></a>知识点拓展</h3><h4 id="优先队列-2"><a href="#优先队列-2" class="headerlink" title="优先队列"></a>优先队列</h4><p>包含头文件<code>#include &lt;queue&gt;</code>, 他和<code>queue</code>不同的就在于我们可以自定义其中数据的优先级, 让优先级高的排在队列前面,优先出队</p><p>优先队列具有队列的所有特性，包括基本操作，只是在这基础上添加了内部的一个排序，它本质是一个堆实现的和队列基本操作相同:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">top 访问队头元素</span><br><span class="line">empty 队列是否为空</span><br><span class="line">size 返回队列内元素个数</span><br><span class="line">push 插入元素到队尾 (并排序)</span><br><span class="line">emplace 原地构造一个元素并插入队列</span><br><span class="line">pop 弹出队头元素</span><br><span class="line">swap 交换内容</span><br></pre></td></tr></table></figure><p>定义：<code>priority_queue&lt;Type, Container, Functional&gt;</code></p><p><code>Type</code> 就是数据类型，<code>Container</code> 就是容器类型（Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector），<code>Functional</code> 就是比较的方式，当需要用自定义的数据类型时才需要传入这三个参数，使用基本数据类型时，只需要传入数据类型，默认是大顶堆。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//升序队列</span></span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"><span class="comment">//降序队列</span></span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt; &gt;q;</span><br><span class="line"></span><br><span class="line"><span class="comment">//greater和less是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有类似函数的行为，就是一个仿函数类了）</span></span><br></pre></td></tr></table></figure><p>基本类型例子：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//对于基础类型 默认是大顶堆</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; a; </span><br><span class="line">    <span class="comment">//等同于 priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; a;</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; c;  <span class="comment">//这样就是小顶堆</span></span><br><span class="line">    priority_queue&lt;string&gt; b;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        a.<span class="built_in">push</span>(i);</span><br><span class="line">        c.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!a.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; a.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        a.<span class="built_in">pop</span>();</span><br><span class="line">    &#125; </span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!c.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; c.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        c.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    b.<span class="built_in">push</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    b.<span class="built_in">push</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">    b.<span class="built_in">push</span>(<span class="string">&quot;cbd&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (!b.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; b.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        b.<span class="built_in">pop</span>();</span><br><span class="line">    &#125; </span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 3 2 1 0</span><br><span class="line">0 1 2 3 4</span><br><span class="line">cbd abcd abc</span><br></pre></td></tr></table></figure><p><code>pari</code>的比较，先比较第一个元素，第一个相等比较第二个</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; a;</span><br><span class="line">    <span class="function">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">c</span><span class="params">(<span class="number">1</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(<span class="number">2</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    a.<span class="built_in">push</span>(d);</span><br><span class="line">    a.<span class="built_in">push</span>(c);</span><br><span class="line">    a.<span class="built_in">push</span>(b);</span><br><span class="line">    <span class="keyword">while</span> (!a.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; a.<span class="built_in">top</span>().first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">top</span>().second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        a.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 5</span><br><span class="line">1 3</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure><p>对于自定义类型</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tmp1</span> //运算符重载&lt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">tmp1</span>(<span class="keyword">int</span> a) &#123;x = a;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> tmp1&amp; a) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; a.x; <span class="comment">//大顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//方法2</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tmp2</span> //重写仿函数</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(tmp1 a, tmp1 b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.x &lt; b.x; <span class="comment">//大顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">tmp1 <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">tmp1 <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">tmp1 <span class="title">c</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    priority_queue&lt;tmp1&gt; d;</span><br><span class="line">    d.<span class="built_in">push</span>(b);</span><br><span class="line">    d.<span class="built_in">push</span>(c);</span><br><span class="line">    d.<span class="built_in">push</span>(a);</span><br><span class="line">    <span class="keyword">while</span> (!d.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; d.<span class="built_in">top</span>().x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        d.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    priority_queue&lt;tmp1, vector&lt;tmp1&gt;, tmp2&gt; f;</span><br><span class="line">    f.<span class="built_in">push</span>(c);</span><br><span class="line">    f.<span class="built_in">push</span>(b);</span><br><span class="line">    f.<span class="built_in">push</span>(a);</span><br><span class="line">    <span class="keyword">while</span> (!f.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; f.<span class="built_in">top</span>().x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        f.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>参考链接：<a href="https://blog.csdn.net/weixin_36888577/article/details/79937886?ops_request_misc=%7B%22request_id%22:%22164769686316780255255620%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=164769686316780255255620&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-79937886.142%5Ev2%5Ees_vector,143%5Ev4%5Econtrol&utm_term=c++priority_queue&spm=1018.2226.3001.4449">(44条消息) c++优先队列(priority_queue)用法详解_吕白_的博客-CSDN博客_c++ 优先队列</a></p><h2 id="寻找重复的子树"><a href="#寻找重复的子树" class="headerlink" title="寻找重复的子树"></a>寻找重复的子树</h2><p><a href="https://leetcode-cn.com/problems/find-duplicate-subtrees/">LeetCode 652. find-duplicate-subtrees</a></p><h3 id="题目：-4"><a href="#题目：-4" class="headerlink" title="题目："></a>题目：</h3><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220321145143286.png" alt="image-20220321145143286" style="zoom:67%;" /><h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><h4 id="序列化-DFS-哈希表"><a href="#序列化-DFS-哈希表" class="headerlink" title="序列化+DFS+哈希表"></a>序列化+DFS+哈希表</h4><p><strong>思路</strong></p><p>序列化二叉树（先序）：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="number">1</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">2</span>   <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">4</span>   <span class="number">5</span></span><br></pre></td></tr></table></figure><p>例如上面这棵树序列化结果为 1,2,#,#,3,4,#,#,5,#,#。每棵不同子树的序列化结果都是唯一的。</p><p><strong>算法</strong></p><p>使用深度优先搜索，其中递归函数返回当前子树的序列化结果。把每个节点开始的子树序列化结果保存在 <strong>map</strong> 中，然后判断是否存在重复的子树。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string n = <span class="built_in">to_string</span>(root-&gt;val)+<span class="string">&#x27;,&#x27;</span>+<span class="built_in">dfs</span>(root-&gt;left)+<span class="string">&#x27;,&#x27;</span>+<span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">        map[n] ++;</span><br><span class="line">        <span class="keyword">if</span>(map[n] == <span class="number">2</span>)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(root);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">findDuplicateSubtrees</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;string, <span class="keyword">int</span>&gt; map;</span><br><span class="line">    vector&lt;TreeNode*&gt; ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<code>O(N^2)</code>，其中 NN 是二叉树上节点的数量。遍历所有节点，在每个节点处序列化需要时间 O(N)。</li><li>空间复杂度：<code>O(N^2)</code>，count 的大小。</li></ul><h4 id="唯一标识符"><a href="#唯一标识符" class="headerlink" title="唯一标识符"></a>唯一标识符</h4><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220321155821996.png" alt="image-20220321155821996"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    Map&lt;String, Integer&gt; trees;</span><br><span class="line">    Map&lt;Integer, Integer&gt; count;</span><br><span class="line">    List&lt;TreeNode&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">findDuplicateSubtrees</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        t = <span class="number">1</span>;</span><br><span class="line">        trees = <span class="keyword">new</span> HashMap();</span><br><span class="line">        count = <span class="keyword">new</span> HashMap();</span><br><span class="line">        ans = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        lookup(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lookup</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        String serial = node.val + <span class="string">&quot;,&quot;</span> + lookup(node.left) + <span class="string">&quot;,&quot;</span> + lookup(node.right);</span><br><span class="line">        <span class="keyword">int</span> uid = trees.computeIfAbsent(serial, x-&gt; t++);</span><br><span class="line">        count.put(uid, count.getOrDefault(uid, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (count.get(uid) == <span class="number">2</span>)</span><br><span class="line">            ans.add(node);</span><br><span class="line">        <span class="keyword">return</span> uid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<code>O(N)</code>，其中 NN 二叉树上节点的数量，每个节点都需要访问一次。</li><li>空间复杂度：<code>O(N)</code>，每棵子树的存储空间都为 O(1)。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从暴力递归到动态规划</title>
      <link href="/%E4%BB%8E%E6%9A%B4%E5%8A%9B%E9%80%92%E5%BD%92%E5%88%B0%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/%E4%BB%8E%E6%9A%B4%E5%8A%9B%E9%80%92%E5%BD%92%E5%88%B0%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="从暴力递归到动态规划"><a href="#从暴力递归到动态规划" class="headerlink" title="从暴力递归到动态规划"></a>从暴力递归到动态规划</h1><p>动态规划算法是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决，是暴力递归的优化版本。所以做算题遇到不能直接写出的动态规划时，从暴力递归入手是个正确的选择，接下来我们看看两者的特点。</p><h4 id="暴力递归"><a href="#暴力递归" class="headerlink" title="暴力递归"></a>暴力递归</h4><ol><li>把问题转化为规模缩小了的同类问题的子问题</li><li>有明确的不需要继续进行递归的条件（base case）</li><li>有当得到了子问题的结果之后的决策过程</li><li>不记录每一个子问题的解</li></ol><h4 id="动态规化"><a href="#动态规化" class="headerlink" title="动态规化"></a>动态规化</h4><ol><li>从暴力递归中来</li><li>将每一个子问题的解记录下来，避免重复计算</li><li>把暴力递归的过程，抽象成了状态表达</li><li>并且存在化简状态表达，使其更加简洁的可能</li></ol><h2 id="解答流程"><a href="#解答流程" class="headerlink" title="解答流程"></a>解答流程</h2><p>参考<strong>左神</strong>视频教程<a href="https://www.bilibili.com/video/BV1kK411u7LW?p=5">《程序员代码面试指南》作者：左神-左程云带你学习进大厂必问难点暴力递归到动态规划——IT名企算法与数据结构题目最优解_哔哩哔哩_bilibili</a></p><p>接着我们明确一般的解答流程：<strong>暴力递归解法-&gt;带记忆数组的递归解法-&gt;动态规划解法</strong>，只要按照这个流程去做基本都能解答出来。下面我以大家最为熟悉的斐波那契数列入手。 斐波那契数列的递推式是f(n)=f(n-1)+f(n-2)。(1,1,2,3,5,8…)</p><h3 id="第一步：写出暴力递归解法"><a href="#第一步：写出暴力递归解法" class="headerlink" title="第一步：写出暴力递归解法"></a>第一步：写出暴力递归解法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">public int <span class="function"><span class="title">fibonacci</span>(<span class="params">int n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个解法相信大部分人都能写出来，暴力递归之所以低效是因为存在大量的重复计算，借鉴<a href="https://links.jianshu.com/go?to=https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-tao-lu-xiang-jie-by-wei-lai-bu-ke/">LeetCode题解区一位大佬的图</a>，如图所示，f(20)=f(19)+f(18)，而f(19)=f(18)+f(17)，这里就产生了重复计算，而且这种重复计算还很多，正是因为这些大量的重复计算，所以暴力递归很低效，这个算法的时间复杂度为 O(2^n)。</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220319104100103.png" alt="image-20220319104100103"></p><h3 id="步骤二：带记忆数组的递归"><a href="#步骤二：带记忆数组的递归" class="headerlink" title="步骤二：带记忆数组的递归"></a>步骤二：带记忆数组的递归</h3><p>步骤一的计算过程中国充斥着大量的重复计算，解决重复计算的方法很简单，用一个数组或者其他容器装起来，递归的时候判断是否已经计算过的，如果已经计算过，就直接返回。这个是典型的用过空间换时间的做法，反应到上述递归图中就是“剪枝”了。（<a href="https://links.jianshu.com/go?to=https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-tao-lu-xiang-jie-by-wei-lai-bu-ke/">下图同样是借鉴的</a>）</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220319104026005.png" alt="image-20220319104026005"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">public int <span class="function"><span class="title">fibonacci</span>(<span class="params">int n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int[] memo = <span class="keyword">new</span> int[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> helper(n, memo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int <span class="function"><span class="title">helper</span>(<span class="params">int n, int[] memo</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果计算过，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (memo[n] != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> memo[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没被计算过</span></span><br><span class="line">    memo[n] = helper(n - <span class="number">1</span>, memo) + helper(n - <span class="number">2</span>, memo);</span><br><span class="line">    <span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤三：转为动态规划"><a href="#步骤三：转为动态规划" class="headerlink" title="步骤三：转为动态规划"></a>步骤三：转为动态规划</h3><p>写出来了带记忆数组的递归解法，动态规划也就基本成型了，因为这两者区别不是很大，<strong>前者是自顶向下的，后者是自底向上的</strong>。自顶向下的意思是，比如求f(5)，递归的做法是先递归到f(1)，然后再往上走得到f(5)；而动态规划是直接从f(1)开始往上求的。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">public int <span class="function"><span class="title">fibonacci</span>(<span class="params">int n</span>)</span>&#123;</span><br><span class="line">    int[] dp = <span class="keyword">new</span> int[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考链接：<a href="https://cloud.tencent.com/developer/article/1582666">暴力递归如何转动态规划 - 云+社区 - 腾讯云 (tencent.com)</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>动态规划一定能由递归转变，递归不一定能转变为动态规划。</strong></p><p>带记忆数组的递归和动态规划相似，他两的时间复杂度也相差无几，<strong>动态规划中很关键的转移方程就是从暴力递归中而来的</strong>，所以当遇到没做过或者不能一下子写出转移方程的，从暴力递归做起总是一个正确的选择。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法DAY-02</title>
      <link href="/%E7%AE%97%E6%B3%95DAY-02/"/>
      <url>/%E7%AE%97%E6%B3%95DAY-02/</url>
      
        <content type="html"><![CDATA[<h1 id="算法总结-DAY-02"><a href="#算法总结-DAY-02" class="headerlink" title="算法总结 DAY_02"></a>算法总结 DAY_02</h1><h2 id="省份数量"><a href="#省份数量" class="headerlink" title="省份数量"></a>省份数量</h2><p><a href="https://leetcode-cn.com/problems/number-of-provinces/">LeetCode 547. number-of-provinces</a></p><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220314162659080.png" alt="image-20220314162659080" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220314162814544.png" alt="image-20220314162814544" style="zoom:80%;" /><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h4><p>深度优先搜索的思路是很直观的。遍历所有城市，对于每个城市，如果该城市尚未被访问过，则从该城市开始深度优先搜索，通过矩阵 <code>isConnected</code> 得到与该城市直接相连的城市有哪些，这些城市和该城市属于同一个连通分量，然后对这些城市继续深度优先搜索，直到同一个连通分量的所有城市都被访问到，即可得到一个省份。遍历完全部城市以后，即可得到连通分量的总数，即省份的总数。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; isConnected, vector&lt;<span class="keyword">int</span>&gt;&amp; visited, <span class="keyword">int</span> city, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;city; j++)&#123;  </span><br><span class="line">            <span class="keyword">if</span>(visited[j] != <span class="number">1</span> &amp;&amp; isConnected[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                visited[j] = <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(isConnected, visited, city, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; isConnected)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> provience = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> city = isConnected.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">visited</span><span class="params">(city)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;city; i++)&#123;    </span><br><span class="line">            <span class="keyword">if</span>(visited[i] != <span class="number">1</span>)&#123;</span><br><span class="line">               <span class="built_in">dfs</span>(isConnected, visited, city, i);</span><br><span class="line">                provience++; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> provience;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<code>O(n^2)</code>，其中 n 是城市的数量。需要遍历矩阵 n 中的每个元素。</p></li><li><p>空间复杂度：<code>O(n)</code>，其中 n 是城市的数量。需要使用数组 visited 记录每个城市是否被访问过，数组长度是 n，递归调用栈的深度不会超过 n。</p></li></ul><h4 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h4><p>也可以通过广度优先搜索的方法得到省份的总数。对于每个城市，如果该城市尚未被访问过，则从该城市开始广度优先搜索，直到同一个连通分量中的所有城市都被访问到，即可得到一个省份。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; isConnected)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> provinces = isConnected.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">visited</span><span class="params">(provinces)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> circles = <span class="number">0</span>;</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; provinces; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                Q.<span class="built_in">push</span>(i);</span><br><span class="line">                <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    <span class="keyword">int</span> j = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">                    visited[j] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; provinces; k++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (isConnected[j][k] == <span class="number">1</span> &amp;&amp; !visited[k]) &#123;</span><br><span class="line">                            Q.<span class="built_in">push</span>(k);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                circles++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> circles;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<code>O(n^2)</code>，其中 n 是城市的数量。需要遍历矩阵 isConnected 中的每个元素。</p></li><li><p>空间复杂度：<code>O(n)</code>，其中 n 是城市的数量。需要使用数组 visited 记录每个城市是否被访问过，数组长度是 n，广度优先搜索使用的队列的元素个数不会超过 n。</p></li></ul><h4 id="并查表"><a href="#并查表" class="headerlink" title="并查表"></a>并查表</h4><p>计算连通分量数的另一个方法是使用并查集。初始时，每个城市都属于不同的连通分量。遍历矩阵 isConnected，如果两个城市之间有相连关系，则它们属于同一个连通分量，对它们进行合并。</p><p>遍历矩阵 isConnected 的全部元素之后，计算连通分量的总数，即为省份的总数。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; parent, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[index] != index) &#123;</span><br><span class="line">            parent[index] = <span class="built_in">Find</span>(parent, parent[index]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; parent, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">        parent[<span class="built_in">Find</span>(parent, index1)] = <span class="built_in">Find</span>(parent, index2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; isConnected)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> provinces = isConnected.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">parent</span><span class="params">(provinces)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; provinces; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; provinces; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; provinces; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isConnected[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="built_in">Union</span>(parent, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> circles = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; provinces; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent[i] == i) &#123;</span><br><span class="line">                circles++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> circles;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220314164525963.png" alt="image-20220314164525963"></p><h3 id="知识点拓展"><a href="#知识点拓展" class="headerlink" title="知识点拓展"></a>知识点拓展</h3><h4 id="并查集的概念与性质"><a href="#并查集的概念与性质" class="headerlink" title="并查集的概念与性质"></a>并查集的概念与性质</h4><p><strong>初始化</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> fa[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        fa[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如有编号为1, 2, 3, …, n的n个元素，我们用一个数组fa[]来存储每个元素的父节点（因为每个元素有且只有一个父节点，所以这是可行的）。一开始，我们先将它们的父节点设为自己。</p><p><strong>合并</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == fa[x])</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        fa[x] = <span class="built_in">find</span>(fa[x]);  <span class="comment">//父节点设为根节点</span></span><br><span class="line">        <span class="keyword">return</span> fa[x];         <span class="comment">//返回父节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要我们在查询的过程中，<strong>把沿途的每个节点的父节点都设为根节点</strong>即可。</p><p><strong>查询</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x] == x)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用递归的写法实现对代表元素的查询：一层一层访问父节点，直至根节点（根节点的标志就是父节点是本身）。要判断两个元素是否属于同一个集合，只需要看它们的根节点是否相同即可。</p><p>参考链接：<a href="https://zhuanlan.zhihu.com/p/93647900">算法学习笔记(1) : 并查集 - 知乎 (zhihu.com)</a></p><h2 id="第一个只出现一次的字符"><a href="#第一个只出现一次的字符" class="headerlink" title="第一个只出现一次的字符"></a>第一个只出现一次的字符</h2><p><a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">面试题50. 第一个只出现一次的字符</a></p><h3 id="题目：-1"><a href="#题目：-1" class="headerlink" title="题目："></a>题目：</h3><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220317171031229.png" alt="image-20220317171031229"></p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>我们可以对字符串进行两次遍历。</p><p>在第一次遍历时，我们使用哈希映射统计出字符串中每个字符出现的次数。在第二次遍历时，我们只要遍历到了一个只出现一次的字符，那么就返回该字符，否则在遍历结束后返回空格。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">firstUniqChar</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            map[s[i]] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map[s[i]]==<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<code>O(n)</code>，其中 n 是字符串 s 的长度。我们需要进行两次遍历。</li><li>空间复杂度：<code>O(∣Σ∣)</code>，其中 Σ 是字符集，在本题中 s 只包含小写字母，因此 ∣Σ∣≤26。我们需要 O(∣Σ∣) 的空间存储哈希映射。</li></ul><h4 id="使用哈希表存储索引"><a href="#使用哈希表存储索引" class="headerlink" title="使用哈希表存储索引"></a>使用哈希表存储索引</h4><p><strong>思路与算法</strong></p><p>我们可以对方法一进行修改，使得第二次遍历的对象从字符串变为哈希映射。</p><p>具体地，对于哈希映射中的每一个键值对，键表示一个字符，值表示它的首次出现的索引（如果该字符只出现一次）或者 −1（如果该字符出现多次）。当我们第一次遍历字符串时，设当前遍历到的字符为 c，如果 c 不在哈希映射中，我们就将 c 与它的索引作为一个键值对加入哈希映射中，否则我们将 c 在哈希映射中对应的值修改为 −1。</p><p>在第一次遍历结束后，我们只需要再遍历一次哈希映射中的所有值，找出其中不为 −1 的最小值，即为第一个不重复字符的索引，然后返回该索引对应的字符。如果哈希映射中的所有值均为 −1，我们就返回空格。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">firstUniqChar</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; position;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (position.<span class="built_in">count</span>(s[i])) &#123;</span><br><span class="line">                position[s[i]] = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                position[s[i]] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> first = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [_, pos]: position) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos != <span class="number">-1</span> &amp;&amp; pos &lt; first) &#123;</span><br><span class="line">                first = pos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> first == n ? <span class="string">&#x27; &#x27;</span> : s[first];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<code>O(n)</code>，其中 n 是字符串 s 的长度。第一次遍历字符串的时间复杂度为 O(n)，第二次遍历哈希映射的时间复杂度为 O(∣Σ∣)，由于 s 包含的字符种类数一定小于 s 的长度，因此 O(∣Σ∣) 在渐进意义下小于 O(n)，可以忽略。</li><li>空间复杂度：<code>O(∣Σ∣)</code>，其中 Σ 是字符集，在本题中 ss 只包含小写字母，因此 ∣Σ∣≤26。我们需要 O(∣Σ∣) 的空间存储哈希映射。</li></ul><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p><strong>思路与算法</strong></p><p>我们也可以借助队列找到第一个不重复的字符。队列具有「先进先出」的性质，因此很适合用来找出第一个满足某个条件的元素。</p><p>具体地，我们使用与方法二相同的哈希映射，并且使用一个额外的队列，按照顺序存储每一个字符以及它们第一次出现的位置。当我们对字符串进行遍历时，设当前遍历到的字符为 c，如果 c 不在哈希映射中，我们就将 c 与它的索引作为一个二元组放入队尾，否则我们就需要检查队列中的元素是否都满足「只出现一次」的要求，即我们不断地根据哈希映射中存储的值（是否为 −1）选择弹出队首的元素，直到队首元素「真的」只出现了一次或者队列为空。</p><p>在遍历完成后，如果队列为空，说明没有不重复的字符，返回空格，否则队首的元素即为第一个不重复的字符以及其索引的二元组。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">firstUniqChar</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; position;</span><br><span class="line">        queue&lt;pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!position.<span class="built_in">count</span>(s[i])) &#123;</span><br><span class="line">                position[s[i]] = i;</span><br><span class="line">                <span class="comment">// 知识点1：emplace的使用</span></span><br><span class="line">                q.<span class="built_in">emplace</span>(s[i], i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                position[s[i]] = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; position[q.<span class="built_in">front</span>().first] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">empty</span>() ? <span class="string">&#x27; &#x27;</span> : q.<span class="built_in">front</span>().first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<code>O(n)</code>，其中 n 是字符串 s 的长度。遍历字符串的时间复杂度为O(n)，而在遍历的过程中我们还维护了一个队列，由于每一个字符最多只会被放入和弹出队列最多各一次，因此维护队列的总时间复杂度为 O(∣Σ∣)，由于 s 包含的字符种类数一定小于 s 的长度，因此 O(∣Σ∣) 在渐进意义下小于 O(n)，可以忽略。</li><li>空间复杂度：<code>O(∣Σ∣)</code>，其中 Σ 是字符集，在本题中 s 只包含小写字母，因此∣Σ∣≤26。我们需要 O(∣Σ∣) 的空间存储哈希映射以及队列。</li></ul><h3 id="知识点拓展-1"><a href="#知识点拓展-1" class="headerlink" title="知识点拓展"></a>知识点拓展</h3><h4 id="1-emplace的使用"><a href="#1-emplace的使用" class="headerlink" title="1. emplace的使用"></a>1. emplace的使用</h4><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220317173713180.png" alt="image-20220317173713180"></p><p><strong>两者的区别</strong> </p><p>当调用<code>insert</code>时，是将对象传递给insert，对象被拷贝到容器中，而当我们使用<code>emplace</code>时，是将参数传递给构造函数，emplace使用这些参数在容器管理的内存空间中直接构造元素。</p><p><code>emplace_back</code>能通过参数构造对象，不需要拷贝或者移动<a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">内存</a>，相比<code>push_back</code>能更好地避免内存的拷贝与移动，使容器插入元素的性能得到进一步提升。使用emplace比常规的push_back少调用了一次复制<a href="https://so.csdn.net/so/search?q=%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020">构造函数</a>。</p><h2 id="到达终点数字"><a href="#到达终点数字" class="headerlink" title="到达终点数字"></a>到达终点数字</h2><p> <a href="https://leetcode-cn.com/problems/reach-a-number/">LeetCode 754. reach-a-number</a></p><h3 id="题目：-2"><a href="#题目：-2" class="headerlink" title="题目："></a>题目：</h3><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220317174458626.png" alt="image-20220317174458626"></p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><h4 id="分析-数学"><a href="#分析-数学" class="headerlink" title="分析 + 数学"></a>分析 + 数学</h4><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/IMG_3454.PNG" alt="IMG_3454" style="zoom: 33%;" /><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reachNumber</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ar[<span class="number">46341</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">46341</span>; i++)&#123;</span><br><span class="line">            ar[i] = (i*(i+<span class="number">1</span>))/<span class="number">2</span>;</span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="keyword">while</span>(ar[n] &lt; <span class="built_in">abs</span>(target))&#123;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>((ar[n<span class="number">-1</span>]+n)%<span class="number">2</span> != <span class="built_in">abs</span>(target)%<span class="number">2</span>)&#123;</span><br><span class="line">            n++;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220318160212156.png" alt="image-20220318160212156"></p><h4 id="分析-数学（进一步优化）"><a href="#分析-数学（进一步优化）" class="headerlink" title="分析 + 数学（进一步优化）"></a>分析 + 数学（进一步优化）</h4><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220318155953444.png" alt="image-20220318155953444"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reachNumber</span><span class="params">(<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    target = <span class="built_in">abs</span>(target);</span><br><span class="line">    <span class="keyword">int</span> s, dt;</span><br><span class="line">    <span class="comment">// 1+2+...+n求和公式Sn = n*(n+1)/2</span></span><br><span class="line">    <span class="comment">// 由求和公式逆推得n = sqrt(2*Sn - 0.25) - 0.5</span></span><br><span class="line">    s = <span class="built_in">sqrt</span>(<span class="number">2</span> * target + <span class="number">0.25</span>) - <span class="number">0.5</span>;</span><br><span class="line">    s += s * (s + <span class="number">1</span>)/<span class="number">2</span> &lt; target? <span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    dt = s * (s + <span class="number">1</span>)/<span class="number">2</span> - target;</span><br><span class="line">    <span class="keyword">return</span> dt % <span class="number">2</span> == <span class="number">0</span>? s: s + <span class="number">1</span> + s % <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<code>O(1)</code>。</li><li>空间复杂度：<code>O(1)</code>。</li></ul><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p> <a href="https://leetcode-cn.com/problems/longest-common-subsequence/">LeetCode 1143. longest-common-subsequence</a></p><h3 id="题目：-3"><a href="#题目：-3" class="headerlink" title="题目："></a>题目：</h3><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220318161832955.png" alt="image-20220318161832955"></p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pu</span><span class="params">(string t1, string t2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = t1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n2 = t2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> dp[n1][n2];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = (t1[<span class="number">0</span>] == t2[<span class="number">0</span>] ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n1; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>], t1[i] == t2[<span class="number">0</span>] ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n2; j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="built_in">max</span>(dp[<span class="number">0</span>][j<span class="number">-1</span>], t1[<span class="number">0</span>] == t2[j] ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n1; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n2; j++)&#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j]);</span><br><span class="line">                <span class="keyword">if</span>(t1[i] == t2[j])</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n1<span class="number">-1</span>][n2<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pu</span>(text1, text2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>官方代码：</strong></p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220318163315889.png" alt="image-20220318163315889" style="zoom:80%;" /><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = text1.<span class="built_in">length</span>(), n = text2.<span class="built_in">length</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c1 = text1.<span class="built_in">at</span>(i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">char</span> c2 = text2.<span class="built_in">at</span>(j - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (c1 == c2) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<code>O(mn)</code>，其中 m 和 n 分别是字符串 text 1和 text 2的长度。二维数组 dp 有 m+1 行和 n+1 列，需要对 dp 中的每个元素进行计算。</li><li>空间复杂度：<code>O(mn)</code>，其中 m 和 n 分别是字符串 text 1和 text 2的长度。创建了 m+1 行 n+1 列的二维数组 dp。</li></ul><h2 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h2><p> <a href="https://leetcode-cn.com/problems/edit-distance/">LeetCode 72. edit-distance</a></p><h3 id="题目：-4"><a href="#题目：-4" class="headerlink" title="题目："></a>题目：</h3><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220318164215871.png" alt="image-20220318164215871"></p><h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><p><strong>递归到动态规划的过程</strong>参考：<a href="https://chenduowen233.github.io/%E4%BB%8E%E6%9A%B4%E5%8A%9B%E9%80%92%E5%BD%92%E5%88%B0%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">从暴力递归到动态规划</a></p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/IMG_3455.PNG" alt="IMG_3455"></p><h4 id="暴力递归"><a href="#暴力递归" class="headerlink" title="暴力递归"></a>暴力递归</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">le</span><span class="params">(string w, string target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = w.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n2 = target.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n1 == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>  n2 - n1;</span><br><span class="line">        <span class="keyword">if</span>(n2 == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>  n1 - n2;</span><br><span class="line">        string w1 = w.<span class="built_in">substr</span>(<span class="number">1</span>,n1<span class="number">-1</span>);</span><br><span class="line">        string t1 = target.<span class="built_in">substr</span>(<span class="number">1</span>,n2<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(w[<span class="number">0</span>] == target[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">le</span>(w1, t1);</span><br><span class="line">        <span class="keyword">if</span>(w[<span class="number">0</span>] != target[<span class="number">0</span>])</span><br><span class="line">            <span class="comment">// 改、 删、 插 </span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">min</span>(<span class="built_in">le</span>(w1, t1) + <span class="number">1</span>, <span class="built_in">le</span>(w1, target) + <span class="number">1</span>), <span class="built_in">le</span>(w, t1) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">le</span>(word1, word2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="带记忆数组的递归"><a href="#带记忆数组的递归" class="headerlink" title="带记忆数组的递归"></a>带记忆数组的递归</h4><p>存储已经算过的值，再次调用时直接返回值</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;string, <span class="keyword">int</span>&gt; map;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">le</span><span class="params">(string w, string target)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n1 = w.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n2 = target.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> it =map.<span class="built_in">find</span>(w+<span class="string">&quot;_&quot;</span>+target);</span><br><span class="line">         <span class="keyword">if</span>(it != map.<span class="built_in">end</span>())</span><br><span class="line">             <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">        <span class="keyword">if</span>(n1 == <span class="number">0</span>)</span><br><span class="line">            map[w+<span class="string">&quot;_&quot;</span>+target] = n2 - n1;</span><br><span class="line">            <span class="keyword">return</span> map[w+<span class="string">&quot;_&quot;</span>+target];</span><br><span class="line">        <span class="keyword">if</span>(n2 == <span class="number">0</span>)</span><br><span class="line">            map[w+<span class="string">&quot;_&quot;</span>+target] = n1 - n2;</span><br><span class="line">            <span class="keyword">return</span> map[w+<span class="string">&quot;_&quot;</span>+target];</span><br><span class="line">        string w1 = w.<span class="built_in">substr</span>(<span class="number">1</span>,n1<span class="number">-1</span>);</span><br><span class="line">        string t1 = target.<span class="built_in">substr</span>(<span class="number">1</span>,n2<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(w[<span class="number">0</span>] == target[<span class="number">0</span>])</span><br><span class="line">            temp = <span class="built_in">le</span>(w1, t1);</span><br><span class="line">            map[w+<span class="string">&quot;_&quot;</span>+target] = temp;</span><br><span class="line">            <span class="keyword">return</span> map[w+<span class="string">&quot;_&quot;</span>+target];</span><br><span class="line">        <span class="keyword">if</span>(w[<span class="number">0</span>] != target[<span class="number">0</span>])</span><br><span class="line">            <span class="comment">// 改、 删、 插</span></span><br><span class="line">            temp = <span class="built_in">min</span>(<span class="built_in">min</span>(<span class="built_in">le</span>(w1, t1) + <span class="number">1</span>, <span class="built_in">le</span>(w1, target) + <span class="number">1</span>), <span class="built_in">le</span>(w, t1) + <span class="number">1</span>);</span><br><span class="line">            map[w+<span class="string">&quot;_&quot;</span>+target] = temp;</span><br><span class="line">            <span class="keyword">return</span> map[w+<span class="string">&quot;_&quot;</span>+target];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">le</span>(word1, word2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><h4 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h4><p><strong>官方解答：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = word1.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">int</span> m = word2.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有一个字符串为空串</span></span><br><span class="line">        <span class="keyword">if</span> (n * m == <span class="number">0</span>) <span class="keyword">return</span> n + m;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// DP 数组</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">D</span>(n + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(m + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 边界状态初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            D[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            D[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算所有 DP 值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> left = D[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> down = D[i][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> left_down = D[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] != word2[j - <span class="number">1</span>]) left_down += <span class="number">1</span>;</span><br><span class="line">                D[i][j] = <span class="built_in">min</span>(left, <span class="built_in">min</span>(down, left_down));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> D[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 ：<code>O(mn)</code>，其中 m 为 word1 的长度，n 为 word2 的长度。</li><li>空间复杂度 ：<code>O(mn)</code>，我们需要大小为 O(mn) 的 D 数组来记录状态值。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法DAY-01</title>
      <link href="/%E7%AE%97%E6%B3%95DAY-01/"/>
      <url>/%E7%AE%97%E6%B3%95DAY-01/</url>
      
        <content type="html"><![CDATA[<h1 id="算法总结-DAY-01"><a href="#算法总结-DAY-01" class="headerlink" title="算法总结 DAY_01"></a>算法总结 DAY_01</h1><h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><p><a href="https://leetcode-cn.com/problems/two-sum/">LeetCode 1. Two Sum</a></p><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那 <code>两个</code> 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><p>示例:<br>       给定 nums = [2, 7, 11, 15], target = 9<br>       因为 nums[0] + nums[1] = 2 + 7 = 9<br>       所以返回 [0, 1]</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h4><p>两层循环遍历：时间复杂度为 <code>O(N^2)</code>，空间复杂度为 <code>O(1)</code>，运行速度慢且内存空间消耗大。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(size &gt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">sort</span>(nums);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; size; j++)&#123;</span><br><span class="line">                     <span class="keyword">if</span>(target == nums[i] + nums[j])</span><br><span class="line">                         <span class="keyword">return</span> &#123;i, j&#125;;</span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="排序法"><a href="#排序法" class="headerlink" title="排序法"></a>排序法</h4><p>先排序，快排   <code>O(NlogN)</code></p><p>头尾指针向内移动，相加查找，找到后，原数组遍历定位下标  <code>O(N)</code></p><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>对于单个未知数x，利用哈希表寻找target-x的时间复杂度可以降为<code>O(1)</code>，对于含有N个数的数组，整个算法的时间复杂度为<code>O(N)</code>；由于存储哈希表，空间复杂度为<code>O(N)</code>。代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="comment">//知识点3：哈希表</span></span><br><span class="line"><span class="comment">//建立哈希表</span></span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;hashtable;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">//知识点4：auto标识符</span></span><br><span class="line"><span class="comment">//知识点5：迭代器iterator的概念与性质</span></span><br><span class="line"><span class="comment">//针对该数nums[i]，在哈希表内查值。数组下标i为值，nums[i]数本身为键值。</span></span><br><span class="line">           <span class="keyword">auto</span> it = hashtable.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line"><span class="comment">//若在已有哈希表内查到值则返回对应下标。因为是与该数前面的数进行匹配，因此该数下标i返回时在后面。</span></span><br><span class="line">           <span class="keyword">if</span>(it != hashtable.<span class="built_in">end</span>())</span><br><span class="line">            <span class="keyword">return</span> &#123;it-&gt;second,i&#125;;</span><br><span class="line"><span class="comment">//将该数nums[i]加入哈希表</span></span><br><span class="line">           hashtable[nums[i]] = i;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="知识点拓展"><a href="#知识点拓展" class="headerlink" title="知识点拓展"></a>知识点拓展</h3><h4 id="vector的概念与性质"><a href="#vector的概念与性质" class="headerlink" title="vector的概念与性质"></a>vector的概念与性质</h4><p><code>vector</code>是顺序容器，本质是动态数组。创建vector容器时需要说明该容器内元素的类型。如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; twoSum;</span><br></pre></td></tr></table></figure><p>vector容器在做形参传递时，可以采用以下三种方式：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_vector1</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;vectest)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_vector2</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp;vectest)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_vector3</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;*vectest)</span></span>;</span><br></pre></td></tr></table></figure><p>init_vector1中是值传递，形参的改变不会对实参有影响，并且会调用vector的拷贝构造函数将实参的值复制给形参。</p><p>init_vector2和init_vector3分别是引用传递和指针传递，它们会对实参做出影响。</p><p>建议在实际应用中采用引用传递，如下文所示。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="i-和-i的区别"><a href="#i-和-i的区别" class="headerlink" title="i++和++i的区别"></a>i++和++i的区别</h4><p>1、赋值顺序不同</p><p>i++先赋值后运算，++i先运算后赋值。</p><p>2、效率不同</p><p>++i的效率比i++高。因为i++先赋值后运算，因此要多生成一个局部对象。如下所示。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CDemo CDemo::<span class="keyword">operator</span>++ ()</span><br><span class="line">&#123;  <span class="comment">//前置++</span></span><br><span class="line">    ++n;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">CDemo CDemo::<span class="keyword">operator</span> ++(<span class="keyword">int</span> k)</span><br><span class="line">&#123;  <span class="comment">//后置++</span></span><br><span class="line">    <span class="function">CDemo <span class="title">tmp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;  <span class="comment">//记录修改前的对象</span></span><br><span class="line">    n++;</span><br><span class="line">    <span class="keyword">return</span> tmp;  <span class="comment">//返回修改前的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、i++无法做左值，++i可以</p><p>左值是对应内存中有确定存储地址的对象的表达式的值，而右值是所有不是左值的表达式的值。一般来说，左值是可以放到赋值符号左边的变量。</p><p>但能否被赋值不是区分左值与右值的依据。比如，C++的const左值是不可赋值的；而作为临时对象的右值可能允许被赋值。左值与右值的根本区别在于是否允许取地址&amp;运算符获得对应的内存地址。</p><h4 id="哈希表-1"><a href="#哈希表-1" class="headerlink" title="哈希表"></a>哈希表</h4><p>哈希表是一个采用键值和值相互对应的函数，在c++中，与哈希表对应的容器是<code>unordered_map</code>（无序容器）。因此采用unordered_map建立哈希表。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;hashtable;</span><br></pre></td></tr></table></figure><p>该句建立一个名为hashtable的，键值对为&lt;int,int&gt;类型的unordered_map容器。其中&lt;int,int&gt;是指键值对类型，前者是键的类型，后者是值的类型。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = hashtable.<span class="built_in">find</span>(target - nums[i]);</span><br></pre></td></tr></table></figure><p>find(key)是unordered_map容器中寻找键key对应的值的成员方法。若键key与其值的键值对在容器中存在，则返回一个指向该键值对的正向迭代器，反之则返回一个指向容器中最后一个键值对之后位置的迭代器。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(it != hashtable.<span class="built_in">end</span>())</span><br></pre></td></tr></table></figure><p>该句判断是否存在我们需要的键值对。成员方法end()生成指向容器中最后一个键值对之后位置的迭代器。</p><h4 id="auto标识符"><a href="#auto标识符" class="headerlink" title="auto标识符"></a>auto标识符</h4><p>1、<code>auto</code>就是根据变量值推断变量类型。<br>       2、使用auto时必须初始化变量。<br>       3、auto是一个占位符，并不是一个类型，因此无法进行类型转换之类的操作。</p><h4 id="迭代器iterator的概念与性质"><a href="#迭代器iterator的概念与性质" class="headerlink" title="迭代器iterator的概念与性质"></a>迭代器iterator的概念与性质</h4><p>访问、读写容器中的元素，需要使用迭代器<code>iterator</code>。容器可以看作为吉他，迭代器可以看作为拨片，吉他（容器）是声音（元素）的载体，但是使吉他发出声音（能够访问到容器的元素）需要使用拨片（迭代器）。</p><p>迭代器根据访问方式分为正向迭代器、双向迭代器、随机访问迭代器。不同的访问方式使得迭代器可以做的运算不同。</p><p>迭代器常用功能：<br>       1、定义一个正向迭代器<br>容器类名<code>::iterator</code> 迭代器名;</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt;::iterator i; </span><br></pre></td></tr></table></figure><p>2、取得迭代器所指元素</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a = *i;</span><br></pre></td></tr></table></figure><p>3、移动迭代器，访问下一个元素（移动方法视迭代器类别变化）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">++i;</span><br></pre></td></tr></table></figure><p>在unordered_map容器中，迭代器指向键值对，即指向两个元素，键和值。因此通过迭代器访问unordered_map容器时，需要说明访问的是哪个元素。其中first是键，second是值。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;it-&gt;second,i&#125;;</span><br></pre></td></tr></table></figure><p>上句即为访问键值对中的值。<br>参考链接：<a href="https://blog.csdn.net/qq_44106937/article/details/116146592">https://blog.csdn.net/qq_44106937/article/details/116146592</a></p><h4 id="map-与-unordered-map"><a href="#map-与-unordered-map" class="headerlink" title="map 与 unordered_map"></a>map 与 unordered_map</h4><p><code>map</code><br><strong>优点</strong>：有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作。红黑树，内部实现一个红黑书使得map的很多操作在lgn的时间复杂度下就可以实现，因此效率非常的高。<br><strong>缺点</strong>：空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点，孩子节点以及红/黑性质，使得每一个节点都占用大量的空间<br><strong>适用处</strong>：对于那些有顺序要求的问题，用map会更高效一些。</p><p><code>unordered_map</code><br><strong>优点</strong>：内部实现了哈希表，因此其查找速度是常量级别的。<br><strong>缺点</strong>：哈希表的建立比较耗费时间<br><strong>适用处</strong>：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map</p><p>使用方法：</p><p><strong>map</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span> <span class="comment">//map的基本操作如下</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">map&lt;string, <span class="keyword">int</span>&gt; dict;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入数据的三种方式</span></span><br><span class="line">dict.<span class="built_in">insert</span>(pair&lt;string,<span class="keyword">int</span>&gt;(<span class="string">&quot;apple&quot;</span>,<span class="number">2</span>));</span><br><span class="line">dict.<span class="built_in">insert</span>(map&lt;string, <span class="keyword">int</span>&gt;::<span class="built_in">value_type</span>(<span class="string">&quot;orange&quot;</span>,<span class="number">3</span>));</span><br><span class="line">dict[<span class="string">&quot;banana&quot;</span>] = <span class="number">6</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 判断是否有元素</span></span><br><span class="line"><span class="keyword">if</span>(dict.<span class="built_in">empty</span>())</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;该字典无元素&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;该字典共有&quot;</span>&lt;&lt;dict.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot;个元素&quot;</span>&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line">map&lt;string, <span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line"><span class="keyword">for</span>(iter=dict.<span class="built_in">begin</span>();iter!=dict.<span class="built_in">end</span>();iter++)</span><br><span class="line">cout&lt;&lt;iter-&gt;first&lt;&lt;ends&lt;&lt;iter-&gt;second&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 查找</span></span><br><span class="line"><span class="keyword">if</span>((iter=dict.<span class="built_in">find</span>(<span class="string">&quot;banana&quot;</span>))!=dict.<span class="built_in">end</span>()) <span class="comment">//  返回一个迭代器指向键值为key的元素，如果没找到就返回end()</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;已找到banana,其value为&quot;</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="string">&quot;.&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;未找到banana.&quot;</span>&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(dict.<span class="built_in">count</span>(<span class="string">&quot;watermelon&quot;</span>)==<span class="number">0</span>) <span class="comment">// 返回键值等于key的元素的个数</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;watermelon不存在&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;watermelon存在&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">pair&lt;map&lt;string, <span class="keyword">int</span>&gt;::iterator, map&lt;string, <span class="keyword">int</span>&gt;::iterator&gt; ret;</span><br><span class="line">ret = dict.<span class="built_in">equal_range</span>(<span class="string">&quot;banana&quot;</span>); <span class="comment">// 查找键值等于 key 的元素区间为[start,end)，指示范围的两个迭代器以 pair 返回</span></span><br><span class="line">cout&lt;&lt;ret.first-&gt;first&lt;&lt;ends&lt;&lt;ret.first-&gt;second&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;ret.second-&gt;first&lt;&lt;ends&lt;&lt;ret.second-&gt;second&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">iter = dict.<span class="built_in">lower_bound</span>(<span class="string">&quot;boluo&quot;</span>); <span class="comment">// 返回一个迭代器，指向键值&gt;=key的第一个元素。</span></span><br><span class="line">cout&lt;&lt;iter-&gt;first&lt;&lt;endl;</span><br><span class="line">iter = dict.<span class="built_in">upper_bound</span>(<span class="string">&quot;boluo&quot;</span>); <span class="comment">// 返回一个迭代器，指向值键值&gt;key的第一个元素。</span></span><br><span class="line">cout&lt;&lt;iter-&gt;first&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>unordered_map</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">unordered_map&lt;string, <span class="keyword">int</span>&gt;  dict; <span class="comment">// 声明unordered_map对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入数据的三种方式</span></span><br><span class="line">dict.<span class="built_in">insert</span>(pair&lt;string,<span class="keyword">int</span>&gt;(<span class="string">&quot;apple&quot;</span>,<span class="number">2</span>));</span><br><span class="line">dict.<span class="built_in">insert</span>(unordered_map&lt;string, <span class="keyword">int</span>&gt;::<span class="built_in">value_type</span>(<span class="string">&quot;orange&quot;</span>,<span class="number">3</span>));</span><br><span class="line">dict[<span class="string">&quot;banana&quot;</span>] = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否有元素</span></span><br><span class="line"><span class="keyword">if</span>(dict.<span class="built_in">empty</span>())</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;该字典无元素&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;该字典共有&quot;</span>&lt;&lt;dict.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot;个元素&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line">unordered_map&lt;string, <span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line"><span class="keyword">for</span>(iter=dict.<span class="built_in">begin</span>();iter!=dict.<span class="built_in">end</span>();iter++)</span><br><span class="line">cout&lt;&lt;iter-&gt;first&lt;&lt;ends&lt;&lt;iter-&gt;second&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找</span></span><br><span class="line"><span class="keyword">if</span>(dict.<span class="built_in">count</span>(<span class="string">&quot;boluo&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;can&#x27;t find boluo!&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;find boluo!&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((iter=dict.<span class="built_in">find</span>(<span class="string">&quot;banana&quot;</span>))!=dict.<span class="built_in">end</span>())</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;banana=&quot;</span>&lt;&lt;iter-&gt;second&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;can&#x27;t find boluo!&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考链接：<a href="https://blog.csdn.net/zou_albert/article/details/106983268">https://blog.csdn.net/zou_albert/article/details/106983268</a></p><h2 id="重复的DNA序列"><a href="#重复的DNA序列" class="headerlink" title="重复的DNA序列"></a>重复的DNA序列</h2><p><a href="https://leetcode-cn.com/problems/repeated-dna-sequences/">LeetCode 187. Repeated DNA Sequences</a></p><h3 id="题目：-1"><a href="#题目：-1" class="headerlink" title="题目："></a>题目：</h3><p>DNA序列 由一系列核苷酸组成，缩写为 ‘A’, ‘C’, ‘G’ 和 ‘T’.。</p><p>例如，”ACGAATTCCG” 是一个 DNA序列 。<br>在研究 DNA 时，识别 DNA 中的重复序列非常有用。</p><p>给定一个表示 DNA序列 的字符串 s ，返回所有在 DNA 分子中出现不止一次的 长度为 10 的序列(子字符串)。你可以按 任意顺序 返回答案。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;</span><br><span class="line">输出：[&quot;AAAAACCCCC&quot;,&quot;CCCCCAAAAA&quot;]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;AAAAAAAAAAAAA&quot;</span><br><span class="line">输出：[&quot;AAAAAAAAAA&quot;]</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 &lt;= s.length &lt;= 105</span><br><span class="line">s[i]==&#x27;A&#x27;、&#x27;C&#x27;、&#x27;G&#x27; or &#x27;T&#x27;</span><br></pre></td></tr></table></figure><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><h4 id="哈希表-2"><a href="#哈希表-2" class="headerlink" title="哈希表"></a>哈希表</h4><ul><li><p>时间复杂度：<code>O(NL)</code>，其中 N 是字符串 <code>s</code> 的长度，<code>L=10</code> 即目标子串的长度。</p></li><li><p>空间复杂度：<code>O(NL)</code>。</p></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">10</span>;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findRepeatedDnaSequences</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        unordered_map&lt;string,<span class="keyword">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">length</span>() &gt; L)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt;= s.<span class="built_in">length</span>() - L; i++)&#123;</span><br><span class="line">                <span class="comment">//截取长度为10的片段</span></span><br><span class="line">                <span class="comment">//知识点1：substr的使用</span></span><br><span class="line">                string temp = s.<span class="built_in">substr</span>(i, L);</span><br><span class="line">                <span class="keyword">if</span>(++map[temp] == <span class="number">2</span>)</span><br><span class="line">                <span class="comment">//出现大于等于两次的放入</span></span><br><span class="line">                <span class="comment">//知识点2：push_back的使用</span></span><br><span class="line">                    ans.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(s);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="哈希表-滑动窗口-位运算"><a href="#哈希表-滑动窗口-位运算" class="headerlink" title="哈希表 + 滑动窗口 + 位运算"></a>哈希表 + 滑动窗口 + 位运算</h4><ul><li>时间复杂度：<code>O(N)</code>，其中 N 是字符串 s 的长度。</li><li>空间复杂度：<code>O(N)</code>。</li></ul><p>由于 s 中只含有 4 种字符，我们可以将每个字符用 2 个比特表示，即：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A 表示为二进制 00；</span><br><span class="line">C 表示为二进制 01；</span><br><span class="line">G 表示为二进制 10；</span><br><span class="line">T 表示为二进制 11。</span><br></pre></td></tr></table></figure><p>如此一来，一个长为 10 的字符串就可以用 20 个比特表示，而一个 int 整数有 32 个比特，足够容纳该字符串，因此我们可以将 s 的每个长为 10 的子串用一个 int 整数表示（只用低 20 位）。</p><p>注意到上述字符串到整数的映射是一一映射，每个整数都对应着一个唯一的字符串，因此我们可以将方法一中的哈希表改为存储每个长为 10 的子串的整数表示。</p><p>如果我们对每个长为 10 的子串都单独计算其整数表示，那么时间复杂度仍然和方法一一样为 O(NL)。为了优化时间复杂度，我们可以用一个大小固定为 10 的滑动窗口来计算子串的整数表示。设当前滑动窗口对应的整数表示为 x，当我们要计算下一个子串时，就将滑动窗口向右移动一位，此时会有一个新的字符进入窗口，以及窗口最左边的字符离开窗口，这些操作对应的位运算，按计算顺序表示如下：</p><p>滑动窗口向右移动一位：<code>x = x &lt;&lt; 2</code>，由于每个字符用 2 个比特表示，所以要左移 2 位；<br>一个新的字符 ch 进入窗口：<code>x = x | bin[ch]</code>，这里 <code>bin[ch]</code> 为字符 ch 的对应二进制；<br>窗口最左边的字符离开窗口：x = x &amp; ((1 &lt;&lt; 20) - 1)，由于我们只考虑 x 的低 20 位比特，需要将其余位置零，即与上 (1 &lt;&lt; 20) - 1。<br>将这三步合并，就可以用 <code>O(1)</code> 的时间计算出下一个子串的整数表示，即 x = ((x &lt;&lt; 2) | bin[ch]) &amp; ((1 &lt;&lt; 20) - 1)。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> L = <span class="number">10</span>;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; bin = &#123;&#123;<span class="string">&#x27;A&#x27;</span>, <span class="number">0</span>&#125;, &#123;<span class="string">&#x27;C&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;G&#x27;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&#x27;T&#x27;</span>, <span class="number">3</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findRepeatedDnaSequences</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= L) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            x = (x &lt;&lt; <span class="number">2</span>) | bin[s[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - L; ++i) &#123;</span><br><span class="line">            x = ((x &lt;&lt; <span class="number">2</span>) | bin[s[i + L - <span class="number">1</span>]]) &amp; ((<span class="number">1</span> &lt;&lt; (L * <span class="number">2</span>)) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (++cnt[x] == <span class="number">2</span>) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(i, L));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="知识点拓展-1"><a href="#知识点拓展-1" class="headerlink" title="知识点拓展"></a>知识点拓展</h3><h4 id="substr-函数用法"><a href="#substr-函数用法" class="headerlink" title="substr()函数用法"></a>substr()函数用法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">substr</span>(size_type _Off = <span class="number">0</span>,size_type _Count = npos)</span><br></pre></td></tr></table></figure><p>一种构造string的方法<br><strong>形式</strong> ： <code>s.substr(pos, len)</code><br><strong>返回值</strong>： string，包含s中从<code>pos</code>开始的<code>len</code>个字符的拷贝（pos的默认值是0，len的默认值是s.size() - pos，即不加参数会默认拷贝整个s）<br><strong>异常</strong> ：若pos的值超过了string的大小，则substr函数会抛出一个out_of_range异常；若pos+n的值超过了string的大小，则substr会调整n的值，只拷贝到string的末尾</p><p>参考链接：<a href="https://blog.csdn.net/weixin_42240667/article/details/103131329">https://blog.csdn.net/weixin_42240667/article/details/103131329</a></p><h4 id="C-vector操作"><a href="#C-vector操作" class="headerlink" title="C++_vector操作"></a>C++_vector操作</h4><p> <strong>vector 说明</strong>:</p><ul><li>vector是向量类型，可以容纳许多类型的数据，因此也被称为容器</li><li>(可以理解为动态数组，是封装好了的类）</li><li>进行<code>vector</code>操作前应添加头文件<code>#include &lt;vector&gt;</code></li></ul><p><strong>vector初始化</strong>：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式1.</span></span><br><span class="line"><span class="comment">//定义具有10个整型元素的向量（尖括号为元素类型名，它可以是任何合法的数据类型），不具有初值，其值不确定</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;<span class="built_in">a</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2.</span></span><br><span class="line"><span class="comment">//定义具有10个整型元素的向量，且给出的每个元素初值为1</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;<span class="built_in">a</span>(<span class="number">10</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式3.</span></span><br><span class="line"><span class="comment">//用向量b给向量a赋值，a的值完全等价于b的值</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;<span class="built_in">a</span>(b);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式4.</span></span><br><span class="line"><span class="comment">//将向量b中从0-2（共三个）的元素赋值给a，a的类型为int型</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;<span class="built_in">a</span>(b.<span class="built_in">begin</span>(),b.begin+<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式5.</span></span><br><span class="line"> <span class="comment">//从数组中获得初值</span></span><br><span class="line"><span class="keyword">int</span> b[<span class="number">7</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(b,b+<span class="number">7</span>）;</span></span></span><br></pre></td></tr></table></figure><p><strong>vector对象的常用内置函数使用（举例说明）</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; a,b;</span><br><span class="line"><span class="comment">//b为向量，将b的0-2个元素赋值给向量a</span></span><br><span class="line">a.<span class="built_in">assign</span>(b.<span class="built_in">begin</span>(),b.<span class="built_in">begin</span>()+<span class="number">3</span>);</span><br><span class="line"><span class="comment">//a含有4个值为2的元素</span></span><br><span class="line">a.<span class="built_in">assign</span>(<span class="number">4</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">//返回a的最后一个元素</span></span><br><span class="line">a.<span class="built_in">back</span>();</span><br><span class="line"><span class="comment">//返回a的第一个元素</span></span><br><span class="line">a.<span class="built_in">front</span>();</span><br><span class="line"><span class="comment">//返回a的第i元素,当且仅当a存在</span></span><br><span class="line">a[i];</span><br><span class="line"><span class="comment">//清空a中的元素</span></span><br><span class="line">a.<span class="built_in">clear</span>();</span><br><span class="line"><span class="comment">//判断a是否为空，空则返回true，非空则返回false</span></span><br><span class="line">a.<span class="built_in">empty</span>();</span><br><span class="line"><span class="comment">//删除a向量的最后一个元素</span></span><br><span class="line">a.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="comment">//删除a中第一个（从第0个算起）到第二个元素，也就是说删除的元素从a.begin()+1算起（包括它）一直到a.begin()+3（不包括它）结束</span></span><br><span class="line">a.<span class="built_in">erase</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,a.<span class="built_in">begin</span>()+<span class="number">3</span>);</span><br><span class="line"><span class="comment">//在a的最后一个向量后插入一个元素，其值为5</span></span><br><span class="line">a.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//在a的第一个元素（从第0个算起）位置插入数值5,</span></span><br><span class="line">a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">//在a的第一个元素（从第0个算起）位置插入3个数，其值都为5</span></span><br><span class="line">a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">//b为数组，在a的第一个元素（从第0个元素算起）的位置插入b的第三个元素到第5个元素（不包括b+6）</span></span><br><span class="line">a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,b+<span class="number">3</span>,b+<span class="number">6</span>);</span><br><span class="line"><span class="comment">//返回a中元素的个数</span></span><br><span class="line">a.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">//返回a在内存中总共可以容纳的元素个数</span></span><br><span class="line">a.<span class="built_in">capacity</span>();</span><br><span class="line"><span class="comment">//将a的现有元素个数调整至10个，多则删，少则补，其值随机</span></span><br><span class="line">a.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//将a的现有元素个数调整至10个，多则删，少则补，其值为2</span></span><br><span class="line">a.<span class="built_in">resize</span>(<span class="number">10</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">//将a的容量扩充至100，</span></span><br><span class="line">a.<span class="built_in">reserve</span>(<span class="number">100</span>);</span><br><span class="line"><span class="comment">//b为向量，将a中的元素和b中的元素整体交换</span></span><br><span class="line">a.<span class="built_in">swap</span>(b);</span><br><span class="line"><span class="comment">//b为向量，向量的比较操作还有 != &gt;= &gt; &lt;= &lt;</span></span><br><span class="line">a==b;</span><br></pre></td></tr></table></figure><p><strong>对向量a添加元素的几种方式</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.向向量a中添加元素</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;a;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)&#123;a.<span class="built_in">push_back</span>(i);&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.从数组中选择元素向向量中添加</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">6</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">4</span>;++i)&#123;b.<span class="built_in">push_back</span>(a[i]);&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.从现有向量中选择元素向向量中添加</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">6</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;b;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;<span class="built_in">c</span>(a,a+<span class="number">4</span>);</span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="keyword">int</span>&gt;::iterator it=c.<span class="built_in">begin</span>();it&lt;c.<span class="built_in">end</span>();++it)</span><br><span class="line">&#123;</span><br><span class="line">b.<span class="built_in">push_back</span>(*it);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.从文件中读取元素向向量中添加</span></span><br><span class="line"></span><br><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">&quot;data.txt&quot;</span>)</span></span>;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;a;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i;in&gt;&gt;i)&#123;a.<span class="built_in">push_back</span>(i);&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.常见错误赋值方式</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;a;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)&#123;a[i]=i;&#125;<span class="comment">//下标只能用来获取已经存在的元素</span></span><br></pre></td></tr></table></figure><p><strong>从向量中读取元素</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.通过下标方式获取</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">6</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;<span class="built_in">b</span>(a,a+<span class="number">4</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=b.<span class="built_in">size</span>()<span class="number">-1</span>;++i)&#123;cout&lt;&lt;b[i]&lt;&lt;endl;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.通过迭代器方式读取</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> a[<span class="number">6</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"> vector&lt;<span class="keyword">int</span>&gt;<span class="built_in">b</span>(a,a+<span class="number">4</span>);</span><br><span class="line"> <span class="keyword">for</span>(vector&lt;<span class="keyword">int</span>&gt;::iterator it=b.<span class="built_in">begin</span>();it!=b.<span class="built_in">end</span>();it++)&#123;cout&lt;&lt;*it&lt;&lt;<span class="string">&quot;  &quot;</span>;&#125;</span><br></pre></td></tr></table></figure><p><strong>几个常用的算法</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"> <span class="comment">//对a中的从a.begin()（包括它）到a.end()（不包括它）的元素进行从小到大排列</span></span><br><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line"> <span class="comment">//对a中的从a.begin()（包括它）到a.end()（不包括它）的元素倒置，但不排列，如a中元素为1,3,2,4,倒置后为4,2,3,1</span></span><br><span class="line"><span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">  <span class="comment">//把a中的从a.begin()（包括它）到a.end()（不包括它）的元素复制到b中，从b.begin()+1的位置（包括它）开始复制，覆盖掉原有元素</span></span><br><span class="line"><span class="built_in">copy</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),b.<span class="built_in">begin</span>()+<span class="number">1</span>);</span><br><span class="line"> <span class="comment">//在a中的从a.begin()（包括它）到a.end()（不包括它）的元素中查找10，若存在返回其在向量中的位置</span></span><br><span class="line"><span class="built_in">find</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>参考链接：<a href="https://blog.csdn.net/weixin_41743247/article/details/90635931">https://blog.csdn.net/weixin_41743247/article/details/90635931</a></p><h2 id="设置哈希映射"><a href="#设置哈希映射" class="headerlink" title="设置哈希映射"></a>设置哈希映射</h2><p><a href="https://leetcode-cn.com/problems/design-hashmap/">LeetCode 706. Design HashMap</a></p><h3 id="题目：-2"><a href="#题目：-2" class="headerlink" title="题目："></a>题目：</h3><p>不使用任何内建的哈希表库设计一个哈希映射（HashMap）。</p><p>实现 <code>MyHashMap</code> 类：</p><p>MyHashMap() 用空映射初始化对象</p><p>void put(int key, int value) 向 HashMap 插入一个键值对 (key, value) 。如果 key 已经存在于映射中，则更新其对应的值 value 。</p><p>int get(int key) 返回特定的 key 所映射的 value ；如果映射中不包含 key 的映射，返回 -1 。</p><p>void remove(key) 如果映射中存在 key 的映射，则移除 key 和它所对应的 value 。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MyHashMap&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;remove&quot;, &quot;get&quot;]</span><br><span class="line">[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, 1, -1, null, 1, null, -1]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyHashMap myHashMap = new MyHashMap();</span><br><span class="line">myHashMap.put(1, 1); // myHashMap 现在为 [[1,1]]</span><br><span class="line">myHashMap.put(2, 2); // myHashMap 现在为 [[1,1], [2,2]]</span><br><span class="line">myHashMap.get(1);    // 返回 1 ，myHashMap 现在为 [[1,1], [2,2]]</span><br><span class="line">myHashMap.get(3);    // 返回 -1（未找到），myHashMap 现在为 [[1,1], [2,2]]</span><br><span class="line">myHashMap.put(2, 1); // myHashMap 现在为 [[1,1], [2,1]]（更新已有的值）</span><br><span class="line">myHashMap.get(2);    // 返回 1 ，myHashMap 现在为 [[1,1], [2,1]]</span><br><span class="line">myHashMap.remove(2); // 删除键为 2 的数据，myHashMap 现在为 [[1,1]]</span><br><span class="line">myHashMap.get(2);    // 返回 -1（未找到），myHashMap 现在为 [[1,1]]</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 &lt;= key, value &lt;= 106</span><br><span class="line">最多调用 104 次 put、get 和 remove 方法</span><br></pre></td></tr></table></figure><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><h4 id="暴力一维数组"><a href="#暴力一维数组" class="headerlink" title="暴力一维数组"></a>暴力一维数组</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashMap</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyHashMap</span>() &#123;</span><br><span class="line">        m = vector&lt;<span class="keyword">int</span>&gt; (<span class="number">1000001</span>, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        m[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m[key];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        m[key] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; m;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h4><p>我们假定读者已经完成了<a href="https://leetcode-cn.com/problems/design-hashset/">705. 设计哈希集合</a>这一题目。</p><p>设哈希表的大小为 base，则可以设计一个简单的哈希函数：<code>x mod base</code>。</p><p>我们开辟一个大小为 base 的数组，数组的每个位置是一个链表。当计算出哈希值之后，就插入到对应位置的链表当中。</p><p>由于我们使用整数除法作为哈希函数，为了尽可能避免冲突，应当将base 取为一个质数。在这里，我们取 =769。</p><p>「设计哈希映射」与「设计哈希集合」解法接近，唯一的区别在于我们存储的不是 <code>key</code> 本身，而是 <code>(key,value)</code> 对。除此之外，代码基本是类似的。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashMap</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;list&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; data;  <span class="comment">//知识点1：pair用法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> base = <span class="number">769</span>;  <span class="comment">//哈希数组大小，越大越不容易冲突，</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key % base;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MyHashMap</span>(): <span class="built_in">data</span>(base) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** value will always be non-negative. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="built_in">hash</span>(key);</span><br><span class="line">        <span class="comment">//for (auto &amp;&amp;p : data[h])</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = data[h].<span class="built_in">begin</span>(); it != data[h].<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*it).first == key) &#123;</span><br><span class="line">                (*it).second = value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        data[h].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">        <span class="comment">//可以利用emplace优化</span></span><br><span class="line"><span class="comment">//data[h].emplace_back(key, value);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="built_in">hash</span>(key);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = data[h].<span class="built_in">begin</span>(); it != data[h].<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*it).first == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> (*it).second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the mapping of the specified value key if this map contains a mapping for the key */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="built_in">hash</span>(key);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = data[h].<span class="built_in">begin</span>(); it != data[h].<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*it).first == key) &#123;</span><br><span class="line">                data[h].<span class="built_in">erase</span>(it);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<code>O(n/b)</code>。其中 n 为哈希表中的元素数量，b 为链表的数量。假设哈希值是均匀分布的，则每个链表大概长度为 </p></li><li><p>空间复杂度：<code>O(n+b)</code>。</p></li></ul><h3 id="知识点拓展-2"><a href="#知识点拓展-2" class="headerlink" title="知识点拓展"></a>知识点拓展</h3><h4 id="pair-结合-vector用法"><a href="#pair-结合-vector用法" class="headerlink" title="pair 结合 vector用法"></a>pair 结合 vector用法</h4><p><code>pair</code>：一对值可以具有不同的数据类型</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pair&lt;string , <span class="keyword">int</span>&gt; p;   <span class="comment">//定义</span></span><br><span class="line"><span class="built_in">make_pair</span>(x,y)         <span class="comment">//插入</span></span><br></pre></td></tr></table></figure><p><strong>定义使用pair的vector：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;pair&lt;string,<span class="keyword">int</span>&gt;&gt;vec; 定义使用pair的vector：</span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(x,y));<span class="comment">//插入pair</span></span><br><span class="line">vec[i].first    <span class="comment">//第i个键值对的key</span></span><br><span class="line">vec[i].second   <span class="comment">//第i个键值对的value</span></span><br></pre></td></tr></table></figure><p>结合sort函数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;string,<span class="keyword">int</span>&gt;&amp;a,pair&lt;string,<span class="keyword">int</span>&gt;&amp;b)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;    <span class="comment">//注意这里的**static**</span></span><br><span class="line"><span class="keyword">if</span> (a.second == b.second) &#123;</span><br><span class="line"><span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),cmp);</span><br></pre></td></tr></table></figure><p><strong>结合map，vector和pair</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(it = map.<span class="built_in">begin</span>();it!=map.<span class="built_in">end</span>();++it)</span><br><span class="line">&#123;</span><br><span class="line">    temp.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(it-&gt;first,it-&gt;second));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="平分数组"><a href="#平分数组" class="headerlink" title="平分数组"></a>平分数组</h2><h3 id="题目：-3"><a href="#题目：-3" class="headerlink" title="题目："></a>题目：</h3><p>一个整数数组a，长度为n，将其分为m份，使各份的和相等，求m的最大值</p><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;3，2，4，3，6&#125; 可以分成&#123;3，2，4，3，6&#125; m=1; </span><br><span class="line">&#123;3,6&#125;&#123;2,4,3&#125; m=2</span><br><span class="line">&#123;3,3&#125;&#123;2,4&#125;&#123;6&#125; m=3 所以m的最大值为3</span><br></pre></td></tr></table></figure><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p><strong>思路和算法</strong></p><p>求出数组和 <code>SUM</code>。</p><p>假设可以分成m组，找到一个合适的m. m的取值为sum%m=0,m&lt;=sum/max(a[i])</p><p>从大到小验证找到一个可行的m值. 此过程可以用递归。f(a,m)=f(a-set,m-1)</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxShares</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i, m;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) sum += a[i];</span><br><span class="line">  <span class="keyword">for</span> (m=n; m&gt;=<span class="number">2</span>; m--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sum mod m != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">int</span> aux[n]; <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) aux[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">testShares</span>(a, n, m, sum, sum/m, aux, sum/m, <span class="number">1</span>)) <span class="keyword">return</span> m;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">testShares</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> sum, <span class="keyword">int</span> groupsum, <span class="keyword">int</span>[] aux, <span class="keyword">int</span> goal, <span class="keyword">int</span> groupId)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (goal == <span class="number">0</span>) &#123;</span><br><span class="line">    groupId++;</span><br><span class="line">    <span class="keyword">if</span> (groupId == m+<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (aux[i] != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    aux[i] = groupId;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">testShares</span>(a, n, m, sum, groupsum, aux, goal-a[i], groupId)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    aux[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考链接：<a href="https://www.cnblogs.com/catkins/archive/2012/11/16/5270694.html">https://www.cnblogs.com/catkins/archive/2012/11/16/5270694.html</a></p><h2 id="和为-K-的子数组"><a href="#和为-K-的子数组" class="headerlink" title="和为 K 的子数组"></a>和为 K 的子数组</h2><p><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">LeetCode 560. Subarray Sum Equals K</a></p><h3 id="题目：-4"><a href="#题目：-4" class="headerlink" title="题目："></a>题目：</h3><p>给你一个整数数组 nums 和一个整数 k ，请你统计并返回该数组中和为 k 的连续子数组的个数。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,1], k = 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3], k = 3</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> &lt;= nums.length &lt;= <span class="number">2</span> * <span class="number">104</span></span><br><span class="line"><span class="number">-1000</span> &lt;= nums[i] &lt;= <span class="number">1000</span></span><br><span class="line"><span class="number">-107</span> &lt;= k &lt;= <span class="number">107</span></span><br></pre></td></tr></table></figure><h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p><strong>思路和算法</strong></p><p>考虑以 <code>i</code> 结尾和为 <code>k</code> 的连续子数组个数，我们需要统计符合条件的下标 <code>j</code> 的个数，其中<code>0≤j≤i</code> 且 <code>[j..i]</code> 这个子数组的和恰好为 <code>k</code> 。</p><p>我们可以枚举 <code>[0..i]</code> 里所有的下标 <code>j</code> 来判断是否符合条件，可能有读者会认为假定我们确定了子数组的开头和结尾，还需要 <code>O(n)</code> 的时间复杂度遍历子数组来求和，那样复杂度就将达到 <code>O(n^3)</code> 从而无法通过所有测试用例。但是如果我们知道 <code>[j,i]</code> 子数组的和，就能 <code>O(1)</code> 推出 <code>[j-1,i]</code> 的和，因此这部分的遍历求和是不需要的，我们在枚举下标 <code>j</code> 的时候已经能 <code>O(1)</code> 求出 <code>[j,i]</code> 的子数组之和。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; nums.<span class="built_in">size</span>(); ++start) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> end = start; end &gt;= <span class="number">0</span>; --end) &#123;</span><br><span class="line">                sum += nums[end];</span><br><span class="line">                <span class="keyword">if</span> (sum == k) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<code>O(n^2)</code>，其中 n 为数组的长度。枚举子数组开头和结尾需要 O(n^2)的时间，其中求和需要 O(1) 的时间复杂度，因此总时间复杂度为 O(n^2)。</p></li><li><p>空间复杂度：<code>O(1)</code>。只需要常数空间存放若干变量。</p></li></ul><h4 id="前缀和-哈希表优化"><a href="#前缀和-哈希表优化" class="headerlink" title="前缀和 + 哈希表优化"></a>前缀和 + 哈希表优化</h4><p><strong>思路和算法</strong></p><p>将前缀和<code>pre</code>存入哈希表，出现相同的<code>key</code>值<code>value</code>加一，使用两数之和的方式寻找。</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220313181536527.png" alt="image-20220313181536527"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; map;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; anum;</span><br><span class="line">        <span class="keyword">int</span> Count = <span class="number">0</span>;</span><br><span class="line">        anum.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            anum.<span class="built_in">push_back</span>(nums[i]+anum[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>()+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> it = map.<span class="built_in">find</span>(anum[i] - k);</span><br><span class="line">            <span class="keyword">if</span>(it != map.<span class="built_in">end</span>())</span><br><span class="line">                Count += map[anum[i] - k];</span><br><span class="line">            map[anum[i]] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p><strong>官方题解：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        mp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x:nums) &#123;</span><br><span class="line">            <span class="comment">// 知识点1：(auto&amp; x:nums)使用</span></span><br><span class="line">            pre += x;</span><br><span class="line">            <span class="keyword">if</span> (mp.<span class="built_in">find</span>(pre - k) != mp.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                count += mp[pre - k];</span><br><span class="line">            &#125;</span><br><span class="line">            mp[pre]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>复杂度分析</p><ul><li><p>时间复杂度：<code>O(n)</code>，其中 n 为数组的长度。我们遍历数组的时间复杂度为 O(n)，中间利用哈希表查询删除的复杂度均为 O(1)，因此总时间复杂度为 O(n)。</p></li><li><p>空间复杂度：<code>O(n)</code>，其中 n 为数组的长度。哈希表在最坏情况下可能有 n 个不同的键值，因此需要 O(n) 的空间复杂度。</p></li></ul><h3 id="知识点拓展-3"><a href="#知识点拓展-3" class="headerlink" title="知识点拓展"></a>知识点拓展</h3><h4 id="auto-amp-x-nums-用法"><a href="#auto-amp-x-nums-用法" class="headerlink" title="(auto&amp; x:nums)用法"></a>(auto&amp; x:nums)用法</h4><p>b为<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E7%BB%84&spm=1001.2101.3001.7020">数组</a>或容器，是被遍历的对象</p><p><code>for(auto &amp;a:b)</code>，<code>for(auto &amp;&amp;a:b)</code>，循环体中修改a，b中对应内容也会修改（<code>&amp;&amp;</code> 右值引用，不用复制拷贝，速度更快）</p><p><code>for(auto a:b)</code>，循环体中修改a，b中内容不受影响</p><p><code>for(const auto &amp;a:b)</code>，a不可修改，用于只读取b中内容</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : arr)&#123;</span><br><span class="line">        cout &lt;&lt; a;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> a : arr)&#123;</span><br><span class="line">        cout &lt;&lt; a;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果仅仅对b进行读取操作，而不修改，两者效果一致，如下：</p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/2020071818000298.png" alt="img" style="zoom:50%;" /><p>如果需要对b进行修改，则需要用for(auto &amp;a:b)，如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : arr)&#123;</span><br><span class="line">        a++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> a : arr)&#123;</span><br><span class="line">        cout &lt;&lt; a;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/20200718180057522.png" alt="img"></p><p>如果不加&amp;符号，则b不会发生任何修改。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校招高频智力题</title>
      <link href="/%E6%A0%A1%E6%8B%9B%E9%AB%98%E9%A2%91%E6%99%BA%E5%8A%9B%E9%A2%98/"/>
      <url>/%E6%A0%A1%E6%8B%9B%E9%AB%98%E9%A2%91%E6%99%BA%E5%8A%9B%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="高频智力题"><a href="#高频智力题" class="headerlink" title="高频智力题"></a>高频智力题</h1><h3 id="高楼扔鸡蛋问题"><a href="#高楼扔鸡蛋问题" class="headerlink" title="高楼扔鸡蛋问题"></a><strong>高楼扔鸡蛋问题</strong></h3><p>有一栋楼共<code>**100**</code>层，一个鸡蛋从第<code>**N**</code>层及以上的楼层落下来会摔破， 在第<code>**N**</code>层以下的楼层落下不会摔破。给你<code>**2**</code>个鸡蛋，如何用最少的尝试次数，测试出鸡蛋不会摔碎的临界点？</p><details class="notion-toggle notion-block-e73ea2006387440b8510e04ad29bf36a" open="" style="box-sizing: border-box; margin-block: 0px; outline: 0px; padding: 3px 2px;"><summary style="box-sizing: border-box; margin-block: 0px; outline: none; cursor: pointer; color: var(--theme-color,#42b983); font-weight: 700; font-size: 20px !important;"></summary><div style="box-sizing: border-box; margin-block: 0px; outline: 0px; margin-left: 1.1em;"><div class="notion-text notion-block-7dfbcffd9ed04fdcb593ec7470abcefb" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 2px 0px 1px;">首先要说明的是这道题你要是一上来就说出正确答案，那说明你的智商不是超过160就是你做过这题。</div><div class="notion-text notion-block-eed58f4099fb4749be33c2e4402fc93e" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;">所以建议你循序渐进的回答，一上来就说最优解可能结果不会让面试官满意。</div><div class="notion-text notion-block-7427ed736ec444049d5f9c7c3659a67c" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">1. 暴力法</b></div><div class="notion-text notion-block-8483fff4db71498d9bfbe56b4d115054" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;">从<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">1</b></code>到<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">100</b></code>，一层一层试。在最坏情况下，这个方法需要扔<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">100</b></code>次。 这个办法太蠢了，完全用不上两个鸡蛋这个条件，不建议回答这个方法。</div><div class="notion-text notion-block-ff4d8b17353c4dff9634f0a6d44d85da" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">2. 二分法</b></div><div class="notion-text notion-block-d88ba2dd667441a3b0134be68d23d05a" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;">采用类似于二分查找的方法，把鸡蛋从一半楼层（<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">50</b></code>层）往下扔。</div><ul class="notion-list notion-list-disc notion-block-d30226aed5a6487a859af4ae853be965" style="box-sizing: border-box; margin-block: 0.6em; outline: 0px; margin: 0px; list-style-type: disc; padding-inline-start: 1.7em;"><li style="box-sizing: border-box; margin-block: 0px; outline: 0px; padding: 6px 0px; white-space: pre-wrap;">如果第一枚鸡蛋，在<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">50</b></code>层碎了，第二枚鸡蛋，就从第<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">1</b></code>层开始扔，一层一层增长，一直扔到第<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">49</b></code>层。</li></ul><ul class="notion-list notion-list-disc notion-block-f83b37a691c84be8a015d1a1f14e8512" style="box-sizing: border-box; margin-block: 0.6em; outline: 0px; margin: 0px; list-style-type: disc; padding-inline-start: 1.7em;"><li style="box-sizing: border-box; margin-block: 0px; outline: 0px; padding: 6px 0px; white-space: pre-wrap;">如果第一枚鸡蛋在<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">50</b></code>层没碎，则继续使用二分法，在剩余楼层的一半（<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">75</b></code>层）往下扔......</li></ul><div class="notion-text notion-block-5fd7c90e9c4649ebbbbc4eb132e2edab" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;">这个方法在最坏情况下，需要尝试<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">50</b></code>次。</div><div class="notion-text notion-block-c0bc768ca99e4e878bf5410666218130" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">3. 均匀法</b></div><div class="notion-text notion-block-07a38465dc714b1b854ac15a034c246b" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;">如何让第一枚鸡蛋和第二枚鸡蛋的尝试次数，尽可能均衡呢？</div><div class="notion-text notion-block-d5f727f732784df98f9b7ce05105c146" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;">很简单，做一个平方根运算，<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">100</b></code>的平方根是<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">10</b></code>。</div><div class="notion-text notion-block-9fa37de4f2fb4236afc6ca1d37cfde4f" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;">因此，我们尝试每<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">10</b></code>层扔一次，第一次从<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">10</b></code>层扔，第二次从<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">20</b></code>层扔，第三次从<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">30</b></code>层......一直扔到<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">100</b></code>层。</div><div class="notion-text notion-block-4068d2542e6542d690c3ebd2d13f09da" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;">这样的最好情况是在第<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">10</b></code>层碎掉，尝试次数为&nbsp;<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">1 + 9 = 10</b></code>次。</div><div class="notion-text notion-block-d176111578e64e79a992494b9d306919" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;">最坏的情况是在第<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">100</b></code>层碎掉，尝试次数为&nbsp;<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">10 + 9 = 19</b></code>次。</div><div class="notion-text notion-block-13fb330cf4db40a7abe3ff3ea8f9d6f6" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;">不过，这里有一个小小的优化点，我们可以从<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">15</b></code>层开始扔，接下来从<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">25</b></code>层、<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">35</b></code>层扔......一直到<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">95</b></code>层。</div><div class="notion-text notion-block-90c18385f3b44180991168352908f724" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;">这样最坏情况是在第<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">95</b></code>层碎掉，尝试次数为&nbsp;<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">9 + 9 = 18</b></code>次。</div><div class="notion-text notion-block-ad45f0c12a5648db9d49c4bfded423fd" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">4. 最优解法</b></div><div class="notion-text notion-block-80bf2cc1cc574ec98a592c475292ca7d" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;">最优解法是反向思考的经典：如果最优解法在最坏情况下需要扔<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">X</b></code>次，那第一次在第几层扔最好呢？</div><div class="notion-text notion-block-0723209cd8564a51a182e8a02475894c" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">答案是：从</b><code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">X</b></code><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">层扔</b></div><div class="notion-text notion-block-2f7c85ca5d4e46e797bfa2a438f21374" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;">假设最优的尝试次数的<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">x</b></code>次，为什么第一次扔就要选择第<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">x</b></code>层呢？</div><div class="notion-text notion-block-aff99d32eb534eea96ffb147d6d112db" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;">这里的解释会有些烧脑，请小伙伴们坐稳扶好：</div><ul class="notion-list notion-list-disc notion-block-3df9f57daa4c4517be9f3472a6573a7c" style="box-sizing: border-box; margin-block: 0.6em; outline: 0px; margin: 0px; list-style-type: disc; padding-inline-start: 1.7em;"><li style="box-sizing: border-box; margin-block: 0px; outline: 0px; padding: 6px 0px; white-space: pre-wrap;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">假设第一次扔在第</b><code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">x+1</b></code><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">层：</b></li></ul><div class="notion-text notion-block-6be02769db3d46b3bce2ad8e42e1c3e7" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;">如果第一个鸡蛋碎了，那么第二个鸡蛋只能从第1层开始一层一层扔，一直扔到第x层。</div><div class="notion-text notion-block-b3cd86c16adc468f883f7859fb8411af" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;">这样一来，我们总共尝试了<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">x+1</b></code>次，和假设尝试<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">x</b></code>次相悖。由此可见，第一次扔的楼层必须小于<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">x+1</b></code>层。</div><ul class="notion-list notion-list-disc notion-block-fa3d1acbdd0444baa10a513b4d71fe68" style="box-sizing: border-box; margin-block: 0.6em; outline: 0px; margin: 0px; list-style-type: disc; padding-inline-start: 1.7em;"><li style="box-sizing: border-box; margin-block: 0px; outline: 0px; padding: 6px 0px; white-space: pre-wrap;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">假设第一次扔在第</b><code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">x-1</b></code><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">层：</b></li></ul><div class="notion-text notion-block-6e5d4b15e00f410da8510026eb25f0f1" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;">如果第一个鸡蛋碎了，那么第二个鸡蛋只能从第<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">1</b></code>层开始一层一层扔，一直扔到第<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">x-2</b></code>层。</div><div class="notion-text notion-block-06d8659779c3439b866e302f153e585e" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;">这样一来，我们总共尝试了<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">x-2+1 = x-1</b></code>次，虽然没有超出假设次数，但似乎有些过于保守。</div><ul class="notion-list notion-list-disc notion-block-4fd1b48c5ebe4fe0875cfde01b60c5b1" style="box-sizing: border-box; margin-block: 0.6em; outline: 0px; margin: 0px; list-style-type: disc; padding-inline-start: 1.7em;"><li style="box-sizing: border-box; margin-block: 0px; outline: 0px; padding: 6px 0px; white-space: pre-wrap;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">假设第一次扔在第</b><code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">x</b></code><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">层：</b></li></ul><div class="notion-text notion-block-354331ea2bc94882a7a8763b14fc6d4f" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;">如果第一个鸡蛋碎了，那么第二个鸡蛋只能从第<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">1</b></code>层开始一层一层扔，一直扔到第<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">x-1</b></code>层。</div><div class="notion-text notion-block-4c708dac486642ef9a5c94a75186fbf8" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;">这样一来，我们总共尝试了<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">x-1+1 = x</b></code>次，刚刚好没有超出假设次数。</div><div class="notion-text notion-block-923b719b81f849f3857648a88149449d" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;">因此，要想尽量楼层跨度大一些，又要保证不超过假设的尝试次数x，那么第一次扔鸡蛋的最优选择就是第<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">x</b></code>层。</div><div class="notion-text notion-block-b70255a647e44f158e9b48ec43b6467d" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;">那么算最坏情况，第二次你只剩下<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">x-1</b></code>次机会，按照上面的说法，你第二次尝试的位置必然是<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">X +（X-1）</b></code>；</div><div class="notion-text notion-block-efd2707329c54055b85843869d28c2da" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;">以此类推我们可得：</div><div class="notion-text notion-block-46c380ff05a54d2c9aa321189c1a550b" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;"><code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">x + (x-1) + (x-2) + ... + 1 = 100</b></code></div><div class="notion-text notion-block-81f2a490dc5c41d3875a88f78ca29d7c" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;">这个方程不难理解：</div><div class="notion-text notion-block-f2ac81f900f24a549d6283b266f441fd" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;">左边的多项式是各次扔鸡蛋的楼层跨度之和。由于假设尝试<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">x</b></code>次，所以这个多项式共有<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">x</b></code>项。</div><div class="notion-text notion-block-d45592a7d1524c0b8dfda1dcb83b94c3" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;">右边是总的楼层数<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">100</b></code>。</div><div class="notion-text notion-block-5595c702e81c48a482fc2427b6974f0e" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;">下面我们来解这个方程：</div><div class="notion-text notion-block-255d2ec524c84f7882294f8cb6d0f0a4" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;"><code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">x + (x-1) + (x-2) + ... + 1 = 100</b></code>&nbsp;转化为&nbsp;<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">(x+1)*x/2 = 100</b></code></div><div class="notion-text notion-block-5d1fed07df904b6f87f1626ec314ae21" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;">最终x向上取整，得到&nbsp;<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">x = 14</b></code></div><div class="notion-text notion-block-6bda887926e448ec89e08d56e710f4bf" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;">因此，最优解在最坏情况的尝试次数是<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">14</b></code>次，第一次扔鸡蛋的楼层也是<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">14</b></code>层。</div><div class="notion-text notion-block-0ec834cd14e942d1995be50577699728" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;">最后，让我们把第一个鸡蛋没碎的情况下，所尝试的楼层数完整列举出来：</div><div class="notion-text notion-block-6bba3c34b2e3450684b9aa0870af4d26" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;"><code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">14，27， 39， 50， 60， 69， 77， 84， 90， 95， 99， 100</b></code></div><ul class="notion-list notion-list-disc notion-block-2bf5890b915d4b38b942930639031d9e" style="box-sizing: border-box; margin-block: 0.6em; outline: 0px; margin: 0px; list-style-type: disc; padding-inline-start: 1.7em;"><li style="box-sizing: border-box; margin-block: 0px; outline: 0px; padding: 6px 0px; white-space: pre-wrap;">举个栗子验证下：</li></ul><div class="notion-text notion-block-918abac39f9f495cac15a0fb3bc4803c" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;">假如鸡蛋不会碎的临界点是<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">65</b></code>层，那么第一个鸡蛋扔出的楼层是<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">14，27，50，60，69</b></code>。这时候啪的一声碎了。</div><div class="notion-text notion-block-3c7f4e8bea5f4bf69053048dd971228a" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;">第二个鸡蛋继续，从<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">61</b></code>层开始，<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">61，62，63，64，65，66</b></code>，啪的一声碎了。</div><div class="notion-text notion-block-6453e91b6e34467984428e1e7ab5a5b5" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;">因此得到不会碎的临界点<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">65</b></code>层，总尝试次数是&nbsp;<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">6 + 6 = 12 &lt; 14</b></code>&nbsp;。</div><div class="notion-text notion-block-f79cf0a804f64e9097b32593442e9600" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;">下面是我个人的理解：这个更像是优化版的均匀法，均匀法让你第二次尝试不超过<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">10</b></code>，但是第一次的位置无法保证（最多要<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">9</b></code>次，最好一次），这个由于每多一次尝试，楼层间隔就<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">-1</b></code>，最终使得第一次与第二次的和完全均匀（最差情况）。</div><div class="notion-text notion-block-6987b935a13c4513b9fa93a133c40bd6" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;">但是核心思路是逆向思考，因为即使理解了需要两次的和均匀也很难得到第一次要在哪层楼扔。</div><div class="notion-text notion-block-90e0ab81f7994dbd8ce2172976f9065a" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;">一旦理解了这种方法，多少层楼你都不会怕啦~</div></div></details><h3 id="找砝码问题"><a href="#找砝码问题" class="headerlink" title="找砝码问题"></a><strong>找砝码问题</strong></h3><p>有一个天平，九个砝码，一个轻一些，用天平至少几次能找到轻的？</p><details class="notion-toggle notion-block-bfcff54512ad4c488eb32b5cb6cb0d70" open="" style="box-sizing: border-box; margin-block: 0px; outline: 0px; padding: 3px 2px;"><summary style="box-sizing: border-box; margin-block: 0px; outline: none; cursor: pointer; color: var(--theme-color,#42b983); font-weight: 700; font-size: 20px !important;"></summary><div style="box-sizing: border-box; margin-block: 0px; outline: 0px; margin-left: 1.1em;"><div class="notion-text notion-block-2b9fcd11406b481686c23d3822cd69c3" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 603.198px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 2px 0px 1px;">三分法。</div><div class="notion-text notion-block-96b4cf7c089c4a24af6187da6de3a9ae" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 603.198px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">答案：2次。</b></div><ul class="notion-list notion-list-disc notion-block-8ca0505f81814518a1ff2628cbf6f359" style="box-sizing: border-box; margin-block: 0.6em; outline: 0px; margin: 0px; list-style-type: disc; padding-inline-start: 1.7em;"><li style="box-sizing: border-box; margin-block: 0px; outline: 0px; padding: 6px 0px; white-space: pre-wrap;">分三份，两份比较，第三份放一边，如果两份相等质量，则说明轻的在第三份。</li></ul><ul class="notion-list notion-list-disc notion-block-e3f466065a6845859133a5df45dd906a" style="box-sizing: border-box; margin-block: 0.6em; outline: 0px; margin: 0px; list-style-type: disc; padding-inline-start: 1.7em;"><li style="box-sizing: border-box; margin-block: 0px; outline: 0px; padding: 6px 0px; white-space: pre-wrap;">不论如何，可以确定轻的砝码在某一份的三个之中，再用一次三分法，即可确定。</li></ul></div></details><h3 id="找玻璃球问题"><a href="#找玻璃球问题" class="headerlink" title="找玻璃球问题"></a><strong>找玻璃球问题</strong></h3><p>有十组玻璃球，每组十个，每个玻璃球重<code>**10**</code>g，但其中有一组玻璃球每个只有<code>**9**</code>g，给你一个能显示克数的秤，问你最少几次能找到轻的那一组砝码？</p><details class="notion-toggle notion-block-d20bc14cb57d433d8a876b43bb2f3fc4" open="" style="box-sizing: border-box; margin-block: 0px; outline: 0px; padding: 3px 2px;"><summary style="box-sizing: border-box; margin-block: 0px; outline: none; cursor: pointer; color: var(--theme-color,#42b983); font-weight: 700; font-size: 20px !important;"></summary><div style="box-sizing: border-box; margin-block: 0px; outline: 0px; margin-left: 1.1em;"><div class="notion-text notion-block-50da2c76fddb46c69aad8c8c7a0fcfa2" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 599.198px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 2px 0px 1px;">将十组玻璃珠编号<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">1~10</code>，然后第一组拿一个，第二组拿两个以此类推...第十组拿十个将这些玻璃珠一起放到秤上称出克数<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">x</code>，</div><div class="notion-text notion-block-fcc517a26cc14204ade3c98a6965636c" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 599.198px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;">则<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">y = 1*10 + 2*10 + 3*10 + ... + 10 * 10 - x</code></div><div class="notion-text notion-block-6938d281e303414699c550aab6bf4dd2" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 599.198px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;">等价于<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">y = (1 + 2 + 3 + ... + 10) * 10 - x = 550 - x</code></div><div class="notion-text notion-block-96c80d49c77d4da0ae4f2f87970541d3" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 599.198px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;">第<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">y</code>组就是轻的那组。</div></div></details><h3 id="毒药问题"><a href="#毒药问题" class="headerlink" title="毒药问题"></a><strong>毒药问题</strong></h3><p><code>**1000**</code>瓶水，其中有一瓶可以无限稀释的毒药，小白鼠喝了毒水就会死（不论含量多低）。要快速找出哪一瓶有毒，需要几只小白鼠？</p><details class="notion-toggle notion-block-9415ec64b0144c8397b09ce064d94240" open="" style="box-sizing: border-box; margin-block: 0px; outline: 0px; padding: 3px 2px;"><summary style="box-sizing: border-box; margin-block: 0px; outline: none; cursor: pointer; color: var(--theme-color,#42b983); font-weight: 700; font-size: 20px !important;"></summary><div style="box-sizing: border-box; margin-block: 0px; outline: 0px; margin-left: 1.1em;"><div class="notion-text notion-block-9481820a9e154103a54e8bb3c09e4943" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 2px 0px 1px;">二进制思路。</div><div class="notion-text notion-block-89b533fad9f142d3998aab17fd88d4a9" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">答：</b><code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">2^10 = 1024 &gt; 1000</b></code><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">，因此</b><code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;"><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">10</b></code><b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">只小白鼠即可。</b></div><div class="notion-text notion-block-2e21295978c64ce79bd6488f7ad3fea8" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;">给<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">1000</code>瓶水按照二进制编号，比如<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">3</code>号编为<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">00000 00011</code>，拿<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">10</code>个碗，对应<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">10</code>位，对于<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">3</code>号水来说，最后两位是<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">1</code>，则把水混合进最后两个碗中。最终把<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">10</code>碗水给对应的小白鼠喝，根据最后小白鼠死亡的情况（死即为<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">1</code>，活即为<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">0</code>），即可确定出有毒的那碗水。</div></div></details><h3 id="生成随机数问题"><a href="#生成随机数问题" class="headerlink" title="生成随机数问题"></a><strong>生成随机数问题</strong></h3><p>给定生成<code>**1**</code>到<code>**5**</code>的随机数<code>**Rand5()**</code>，如何得到生成<code>**1**</code>到<code>**7**</code>的随机数函数<code>**Rand7()**</code>？</p><details class="notion-toggle notion-block-2c2bb75282074c728f44b7a7b8b4b938" open="" style="box-sizing: border-box; margin-block: 0px; outline: 0px; padding: 3px 2px;"><summary style="box-sizing: border-box; margin-block: 0px; outline: none; cursor: pointer; color: var(--theme-color,#42b983); font-weight: 700; font-size: 20px !important;"></summary><div style="box-sizing: border-box; margin-block: 0px; outline: 0px; margin-left: 1.1em;"><ul class="notion-list notion-list-disc notion-block-1a9e2dff6a9149dd8555ba04c2e412c6" style="box-sizing: border-box; margin-block: 0.6em; outline: 0px; margin: 0px; list-style-type: disc; padding-inline-start: 1.7em;"><li style="box-sizing: border-box; margin-block: 0px; outline: 0px; padding: 6px 0px; white-space: pre-wrap;">使用 <code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">rand5()</code> 生成 <code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">rand7()</code></li></ul><pre class="notion-code language-java" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 444.594px; padding: 0px; margin: 0.5em 0px 1em; border-radius: 0.375rem; tab-size: 4; display: block; overflow: visible; background: none rgb(253, 253, 253); font-family: Consolas, Monaco, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, monospace; border: 1px solid rgb(229, 231, 235); color: rgb(31, 41, 55); font-size: 13.6px; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.5; hyphens: none; position: relative;"><code class=" language-java" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(31, 41, 55); background: none !important; font-family: Consolas, Monaco, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, monospace; font-size: 1em; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens: none; max-height: inherit; height: inherit; padding: 0px !important; display: block; overflow: auto; border: 0px !important; box-shadow: none !important; position: relative;"><span class="token comment" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(91, 155, 76);">// 需要随机得到 1-7</span><span class="token keyword" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(59, 130, 246);">public</span> <span class="token keyword" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(59, 130, 246);">static</span> <span class="token keyword" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(59, 130, 246);">int</span> <span class="token function" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(236, 72, 153);">rand7</span><span class="token punctuation" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(55, 65, 81);">(</span><span class="token punctuation" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(55, 65, 81);">)</span> <span class="token punctuation" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(55, 65, 81);">&#123;</span>    <span class="token keyword" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(59, 130, 246);">while</span> <span class="token punctuation" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(55, 65, 81);">(</span><span class="token boolean" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(16, 185, 129);">true</span><span class="token punctuation" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(55, 65, 81);">)</span> <span class="token punctuation" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(55, 65, 81);">&#123;</span>      <span class="token keyword" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(59, 130, 246);">int</span> row<span class="token punctuation" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(55, 65, 81);">,</span> col<span class="token punctuation" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(55, 65, 81);">,</span> idx<span class="token punctuation" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(55, 65, 81);">;</span>      <span class="token comment" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(91, 155, 76);">// rand5() 返回 1-5</span>      row <span class="token operator" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(245, 158, 11); background: none;">=</span> <span class="token function" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(236, 72, 153);">rand5</span><span class="token punctuation" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(55, 65, 81);">(</span><span class="token punctuation" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(55, 65, 81);">)</span><span class="token punctuation" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(55, 65, 81);">;</span> <span class="token comment" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(91, 155, 76);">// 5 * 5 = 25, 设想一个 5*5 的矩阵</span>      col <span class="token operator" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(245, 158, 11); background: none;">=</span> <span class="token function" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(236, 72, 153);">rand5</span><span class="token punctuation" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(55, 65, 81);">(</span><span class="token punctuation" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(55, 65, 81);">)</span><span class="token punctuation" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(55, 65, 81);">;</span> <span class="token comment" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(91, 155, 76);">// 然后找到小于25的，7的最大倍数21</span>      idx <span class="token operator" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(245, 158, 11); background: none;">=</span> col <span class="token operator" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(245, 158, 11); background: none;">+</span> <span class="token punctuation" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(55, 65, 81);">(</span>row <span class="token operator" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(245, 158, 11); background: none;">-</span> <span class="token number" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(16, 185, 129);">1</span><span class="token punctuation" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(55, 65, 81);">)</span> <span class="token operator" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(245, 158, 11); background: none;">*</span> <span class="token number" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(16, 185, 129);">5</span><span class="token punctuation" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(55, 65, 81);">;</span>      <span class="token keyword" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(59, 130, 246);">if</span> <span class="token punctuation" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(55, 65, 81);">(</span>idx <span class="token operator" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(245, 158, 11); background: none;">&lt;=</span> <span class="token number" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(16, 185, 129);">21</span><span class="token punctuation" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(55, 65, 81);">)</span> <span class="token comment" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(91, 155, 76);">// 只考虑 1-21，划分成 7 份</span>        <span class="token keyword" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(59, 130, 246);">return</span> <span class="token number" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(16, 185, 129);">1</span> <span class="token operator" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(245, 158, 11); background: none;">+</span> <span class="token punctuation" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(55, 65, 81);">(</span>idx <span class="token operator" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(245, 158, 11); background: none;">-</span> <span class="token number" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(16, 185, 129);">1</span><span class="token punctuation" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(55, 65, 81);">)</span> <span class="token operator" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(245, 158, 11); background: none;">%</span> <span class="token number" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(16, 185, 129);">7</span><span class="token punctuation" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(55, 65, 81);">;</span>    <span class="token punctuation" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(55, 65, 81);">&#125;</span><span class="token punctuation" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(55, 65, 81);">&#125;</span></code></pre></div></details><h3 id="先手必胜策略问题："><a href="#先手必胜策略问题：" class="headerlink" title="先手必胜策略问题："></a><strong>先手必胜策略问题：</strong></h3><ul><li><code>**100**</code>本书，每次能够拿<code>**1-5**</code>本，怎么拿能保证最后一次是你拿？</li></ul><details class="notion-toggle notion-block-6d6e1ef3f3ff4c688accb43b732b9e3e" open="" style="box-sizing: border-box; margin-block: 0px; outline: 0px; padding: 3px 2px;"><summary style="box-sizing: border-box; margin-block: 0px; outline: none; cursor: pointer; color: var(--theme-color,#42b983); font-weight: 700; font-size: 20px !important;"></summary><div style="box-sizing: border-box; margin-block: 0px; outline: 0px; margin-left: 1.1em;"><ul class="notion-list notion-list-disc notion-block-fc687de67c604692b0d6d34620e7cfd6" style="box-sizing: border-box; margin-block: 0.6em; outline: 0px; margin: 0px; list-style-type: disc; padding-inline-start: 1.7em;"><li style="box-sizing: border-box; margin-block: 0px; outline: 0px; padding: 6px 0px; white-space: pre-wrap;">卡关键点，每次只能拿<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">1</code><code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">5</code>本，所以当剩下<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">6</code>本的时候，不论对面怎么拿你都能赢；</li></ul><ul class="notion-list notion-list-disc notion-block-fdd0440fad1d4655afe5f957badd069c" style="box-sizing: border-box; margin-block: 0.6em; outline: 0px; margin: 0px; list-style-type: disc; padding-inline-start: 1.7em;"><li style="box-sizing: border-box; margin-block: 0px; outline: 0px; padding: 6px 0px; white-space: pre-wrap;">然后推<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">6</code>的倍数：<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">12、18、...、96</code>，也就是一开始要拿<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">4</code>本；</li></ul><ul class="notion-list notion-list-disc notion-block-896eb75df19d44d78050202c38f4aa29" style="box-sizing: border-box; margin-block: 0.6em; outline: 0px; margin: 0px; list-style-type: disc; padding-inline-start: 1.7em;"><li style="box-sizing: border-box; margin-block: 0px; outline: 0px; padding: 6px 0px; white-space: pre-wrap;">接下来对面拿<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">1</code>，你就拿<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">5</code>，对面拿<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">2</code>，你就拿<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">4</code>，总之让你拿的和对面拿的加起来是<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">6</code>，最终就能赢。</li></ul></div></details><ul><li>推广到<code>**n**</code>本书，每次拿<code>**1-k**</code>本，怎么保证最后一次是你拿？</li></ul><h3 id="瓶子换饮料问题"><a href="#瓶子换饮料问题" class="headerlink" title="瓶子换饮料问题"></a><strong>瓶子换饮料问题</strong></h3><p><code>**1000**</code>瓶饮料，<code>**3**</code>个空瓶子能够换<code>**1**</code>瓶饮料，问最多能喝几瓶？</p><details class="notion-toggle notion-block-e515da2cee8e427d99159ac9ff836e1f" open="" style="box-sizing: border-box; margin-block: 0px; outline: 0px; padding: 3px 2px;"><summary style="box-sizing: border-box; margin-block: 0px; outline: none; cursor: pointer; color: var(--theme-color,#42b983); font-weight: 700; font-size: 20px !important;"></summary><div style="box-sizing: border-box; margin-block: 0px; outline: 0px; margin-left: 1.1em;"><ul class="notion-list notion-list-disc notion-block-8fecc0f4a8e449739dd4ad47f67549f8" style="box-sizing: border-box; margin-block: 0.6em; outline: 0px; margin: 0px; list-style-type: disc; padding-inline-start: 1.7em;"><li style="box-sizing: border-box; margin-block: 0px; outline: 0px; padding: 6px 0px; white-space: pre-wrap;"><code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">1000 % 3 = 333...1</code> 喝掉<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">1000</code>瓶,可以换<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">333</code>瓶汽水, 余<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">1</code>个空瓶</li></ul><ul class="notion-list notion-list-disc notion-block-d185c315a80f47aab39d5dc87cc74e00" style="box-sizing: border-box; margin-block: 0.6em; outline: 0px; margin: 0px; list-style-type: disc; padding-inline-start: 1.7em;"><li style="box-sizing: border-box; margin-block: 0px; outline: 0px; padding: 6px 0px; white-space: pre-wrap;"><code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">333 % 3 = 111...0</code>　喝掉<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">333</code>瓶，可以换<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">111</code>瓶汽水, 余<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">0</code>个空瓶</li></ul><ul class="notion-list notion-list-disc notion-block-90c3a5f82954423f962dca0d16edca08" style="box-sizing: border-box; margin-block: 0.6em; outline: 0px; margin: 0px; list-style-type: disc; padding-inline-start: 1.7em;"><li style="box-sizing: border-box; margin-block: 0px; outline: 0px; padding: 6px 0px; white-space: pre-wrap;"><code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">111 % 3 = 37...0</code> 喝掉<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">111</code>瓶，可以换<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">37</code>瓶汽水, 余<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">0</code>个空瓶</li></ul><ul class="notion-list notion-list-disc notion-block-4bab8101a7b446e19440509231d998b4" style="box-sizing: border-box; margin-block: 0.6em; outline: 0px; margin: 0px; list-style-type: disc; padding-inline-start: 1.7em;"><li style="box-sizing: border-box; margin-block: 0px; outline: 0px; padding: 6px 0px; white-space: pre-wrap;"><code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">37 % 3 = 12...1</code> 喝掉<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">37</code>瓶，可以换<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">12</code>瓶汽水, 余<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">1</code>个空瓶</li></ul><ul class="notion-list notion-list-disc notion-block-67a00ccdf5554bb8b7288a1f58608de1" style="box-sizing: border-box; margin-block: 0.6em; outline: 0px; margin: 0px; list-style-type: disc; padding-inline-start: 1.7em;"><li style="box-sizing: border-box; margin-block: 0px; outline: 0px; padding: 6px 0px; white-space: pre-wrap;"><code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">12 % 3 = 4...0</code> 喝掉<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">12</code>瓶，可以换<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">4</code>瓶汽水, 余<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">0</code>个空瓶</li></ul><ul class="notion-list notion-list-disc notion-block-4ec5d648a62b4e3e8afdee217206b208" style="box-sizing: border-box; margin-block: 0.6em; outline: 0px; margin: 0px; list-style-type: disc; padding-inline-start: 1.7em;"><li style="box-sizing: border-box; margin-block: 0px; outline: 0px; padding: 6px 0px; white-space: pre-wrap;"><code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">4 % 3 = 1...1</code> 喝掉<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">4</code>瓶，可以换<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">1</code>瓶汽水, 余<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">1</code>个空瓶</li></ul><ul class="notion-list notion-list-disc notion-block-3e916ddc66d04f54870886c03e11ecd7" style="box-sizing: border-box; margin-block: 0.6em; outline: 0px; margin: 0px; list-style-type: disc; padding-inline-start: 1.7em;"><li style="box-sizing: border-box; margin-block: 0px; outline: 0px; padding: 6px 0px; white-space: pre-wrap;">此时剩下<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">1</code>瓶汽水 + <code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">3</code>个空瓶，其中<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">3</code>个空瓶可以再换<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">1</code>瓶</li></ul><ul class="notion-list notion-list-disc notion-block-7c4eb16be7654b78ada109a3180f7a02" style="box-sizing: border-box; margin-block: 0.6em; outline: 0px; margin: 0px; list-style-type: disc; padding-inline-start: 1.7em;"><li style="box-sizing: border-box; margin-block: 0px; outline: 0px; padding: 6px 0px; white-space: pre-wrap;">此时剩下<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">2</code>瓶，喝掉<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">2</code>瓶，不能再换了。总共：<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">1000 + 333 + 111 + 37 + 12 + 4 + 2 = 1499</code>瓶</li></ul></div></details><h3 id="重合问题"><a href="#重合问题" class="headerlink" title="重合问题"></a><strong>重合问题</strong></h3><p>在一天的<code>**24**</code>小时之中，时钟的时针、分针和秒针完全重合在一起的时候有几次？都分别是什么时间？</p><details class="notion-toggle notion-block-45e2d24742d44f08aeb1e674b04e0475" open="" style="box-sizing: border-box; margin-block: 0px; outline: 0px; padding: 3px 2px;"><summary style="box-sizing: border-box; margin-block: 0px; outline: none; cursor: pointer; color: var(--theme-color,#42b983); font-weight: 700; font-size: 20px !important;"></summary><div style="box-sizing: border-box; margin-block: 0px; outline: 0px; margin-left: 1.1em;"><ul class="notion-list notion-list-disc notion-block-d2e2a79b0c7947e4999dff0eda7909a3" style="box-sizing: border-box; margin-block: 0.6em; outline: 0px; margin: 0px; list-style-type: disc; padding-inline-start: 1.7em;"><li style="box-sizing: border-box; margin-block: 0px; outline: 0px; padding: 6px 0px; white-space: pre-wrap;">假设时针的角速度为 <code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">ω（ω = 1 / 120 (度/秒)）</code>，那么分针的角速度就为 <code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">12ω</code>，秒针的角速度为 <code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">720ω</code></li></ul><ul class="notion-list notion-list-disc notion-block-7233d60ad6cd43a89454b4f613a560cc" style="box-sizing: border-box; margin-block: 0.6em; outline: 0px; margin: 0px; list-style-type: disc; padding-inline-start: 1.7em;"><li style="box-sizing: border-box; margin-block: 0px; outline: 0px; padding: 6px 0px; white-space: pre-wrap;">假设时针和分针在 <code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">t</code> 秒后重合，那么分针在 <code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">t</code> 时间内走过的角度减去时针在 <code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">t</code> 时间内走过的角度，得到的结果肯定是 <code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">360</code> 的整数倍</li></ul><ul class="notion-list notion-list-disc notion-block-d09f78f23c954714b594f699a5681909" style="box-sizing: border-box; margin-block: 0.6em; outline: 0px; margin: 0px; list-style-type: disc; padding-inline-start: 1.7em;"><li style="box-sizing: border-box; margin-block: 0px; outline: 0px; padding: 6px 0px; white-space: pre-wrap;">根据上面的规则，可以算出<b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">时针和分针</b>重合的时间 – 集合 <code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">A</code></li></ul><ul class="notion-list notion-list-disc notion-block-b0dab35ed60b4e74a86f37e85ac2cdd5" style="box-sizing: border-box; margin-block: 0.6em; outline: 0px; margin: 0px; list-style-type: disc; padding-inline-start: 1.7em;"><li style="box-sizing: border-box; margin-block: 0px; outline: 0px; padding: 6px 0px; white-space: pre-wrap;">同理也能算出<b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">分针和秒针</b>重合的时间 – 集合 <code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">B</code></li></ul><ul class="notion-list notion-list-disc notion-block-dc8b21830c144236b4e7b8e4c06c149a" style="box-sizing: border-box; margin-block: 0.6em; outline: 0px; margin: 0px; list-style-type: disc; padding-inline-start: 1.7em;"><li style="box-sizing: border-box; margin-block: 0px; outline: 0px; padding: 6px 0px; white-space: pre-wrap;">那么<b style="box-sizing: border-box; margin-block: 0px; outline: 0px; font-weight: 600;">时针、分针及秒针</b>三者重合的时间就是集合 <code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">A、B</code> 的交集</li></ul><div class="notion-text notion-block-187614cb575e44e3ac9db79a10b16bdc" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;">结果：</div><ul class="notion-list notion-list-disc notion-block-8ce52c6d836b4262a44c1349291935ed" style="box-sizing: border-box; margin-block: 0.6em; outline: 0px; margin: 0px; list-style-type: disc; padding-inline-start: 1.7em;"><li style="box-sizing: border-box; margin-block: 0px; outline: 0px; padding: 6px 0px; white-space: pre-wrap;"><code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">A.length = 22</code></li></ul><ul class="notion-list notion-list-disc notion-block-af4f2b111d734dc19c7efdd1c7d84792" style="box-sizing: border-box; margin-block: 0.6em; outline: 0px; margin: 0px; list-style-type: disc; padding-inline-start: 1.7em;"><li style="box-sizing: border-box; margin-block: 0px; outline: 0px; padding: 6px 0px; white-space: pre-wrap;"><code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">B.length = 1416</code></li></ul><ul class="notion-list notion-list-disc notion-block-05de586524954a4bb855698c7e0b2faf" style="box-sizing: border-box; margin-block: 0.6em; outline: 0px; margin: 0px; list-style-type: disc; padding-inline-start: 1.7em;"><li style="box-sizing: border-box; margin-block: 0px; outline: 0px; padding: 6px 0px; white-space: pre-wrap;"><code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">A ∩ B = ['00:00:00', '12:00:00'] = 2</code></li></ul></div></details><h3 id="赛马问题（腾讯高频）"><a href="#赛马问题（腾讯高频）" class="headerlink" title="赛马问题（腾讯高频）"></a><strong>赛马问题（腾讯高频）</strong></h3><ul><li><p>有<code>**25**</code>匹马，每场比赛只能赛<code>**5**</code>匹，找最快的<code>**3**</code>匹马，至少要赛多少场？</p></li><li><p>有<code>**64**</code>匹马，每场比赛只能赛<code>**8**</code>匹，找最快的<code>**4**</code>匹马，至少要赛多少场？</p></li><li><p>有<code>**25**</code>匹马，每场比赛只能赛<code>**5**</code>匹，找最快的<code>**5**</code>匹马，至少要赛多少场？</p></li></ul><details class="notion-toggle notion-block-0604419444854959a5c7e40db0b77648" open="" style="box-sizing: border-box; margin-block: 0px; outline: 0px; padding: 3px 2px;"><summary style="box-sizing: border-box; margin-block: 0px; outline: none; cursor: pointer; color: var(--theme-color,#42b983); font-weight: 700; font-size: 20px !important;"></summary><div style="box-sizing: border-box; margin-block: 0px; outline: 0px; margin-left: 1.1em;"><ul class="notion-list notion-list-disc notion-block-26f1990b21424fa29904c3b1934713a9" style="box-sizing: border-box; margin-block: 0.6em; outline: 0px; margin: 0px; list-style-type: disc; padding-inline-start: 1.7em;"><li style="box-sizing: border-box; margin-block: 0px; outline: 0px; padding: 6px 0px; white-space: pre-wrap;"><code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">25</code>匹马<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">5</code>条跑道找最快的<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">3</code>匹马，需要跑几次？答案：<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">7</code>次</li></ul><ul class="notion-list notion-list-disc notion-block-d75f21044b014893b4fa0a9216788ee8" style="box-sizing: border-box; margin-block: 0.6em; outline: 0px; margin: 0px; list-style-type: disc; padding-inline-start: 1.7em;"><li style="box-sizing: border-box; margin-block: 0px; outline: 0px; padding: 6px 0px; white-space: pre-wrap;"><code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">64</code>匹马<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">8</code>条跑道找最快的<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">4</code>匹马，需要跑几次？答案：最少<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">10</code>次，最多<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">11</code>次</li></ul><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-e61926d37d3e4a01b6ddf6b1e755494b" style="box-sizing: border-box; margin-block: 0px; outline: 0px; margin: 1em 0px; max-width: 100%; min-width: 100%; align-self: center; display: flex; flex-direction: column;"><div style="box-sizing: border-box; margin-block: 0px; outline: 0px; position: relative; display: flex; justify-content: center; align-self: center; width: 754.406px; max-width: 100%; flex-direction: column;"><img src="https://www.notion.so/image/https%3A%2F%2Ftva1.sinaimg.cn%2Flarge%2F0081Kckwly1gls7vtmjw9j324y0kiwzt.jpg?table=block&amp;id=e61926d3-7d3e-4a01-b6dd-f6b1e755494b&amp;cache=v2" loading="lazy" alt="notion image" decoding="async" class="medium-zoom-image" style="box-sizing: border-box; margin-block: 0px; outline: 0px; border-radius: 0px; cursor: zoom-in; transition: transform 0.3s cubic-bezier(0.2, 0, 0.2, 1) 0s !important; width: 754.406px; height: 200.99px; max-height: 100%;"></div></figure><div class="notion-text notion-block-5496b385a5364a9ab7af1b5ef1290e09" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;">此时<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">A1</code>显然是第一名，接下来需要找出第<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">2、3、4</code>名</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-35b387aacdb9423992d5fb17a3f0e6a2" style="box-sizing: border-box; margin-block: 0px; outline: 0px; margin: 1em 0px; max-width: 100%; min-width: 100%; align-self: center; display: flex; flex-direction: column;"><div style="box-sizing: border-box; margin-block: 0px; outline: 0px; position: relative; display: flex; justify-content: center; align-self: center; width: 754.406px; max-width: 100%; flex-direction: column;"><img src="https://www.notion.so/image/https%3A%2F%2Ftva1.sinaimg.cn%2Flarge%2F0081Kckwly1gls84xp950j322k0kgqj9.jpg?table=block&amp;id=35b387aa-cdb9-4239-92d5-fb17a3f0e6a2&amp;cache=v2" loading="lazy" alt="notion image" decoding="async" class="medium-zoom-image" style="box-sizing: border-box; margin-block: 0px; outline: 0px; border-radius: 0px; cursor: zoom-in; transition: transform 0.3s cubic-bezier(0.2, 0, 0.2, 1) 0s !important; width: 754.406px; height: 206.865px; max-height: 100%;"></div></figure><div class="notion-text notion-block-615b48094e97405ca511d6e2d3fb15b2" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;">如果<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">A3</code>拿了第一名</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-0de30bdfb18c4d1b8965acec7cfd6cfd" style="box-sizing: border-box; margin-block: 0px; outline: 0px; margin: 1em 0px; max-width: 100%; min-width: 100%; align-self: center; display: flex; flex-direction: column;"><div style="box-sizing: border-box; margin-block: 0px; outline: 0px; position: relative; display: flex; justify-content: center; align-self: center; width: 754.406px; max-width: 100%; flex-direction: column;"><img src="https://www.notion.so/image/https%3A%2F%2Ftva1.sinaimg.cn%2Flarge%2F0081Kckwly1gls7z4mnnoj326g0k67ov.jpg?table=block&amp;id=0de30bdf-b18c-4d1b-8965-acec7cfd6cfd&amp;cache=v2" loading="lazy" alt="notion image" decoding="async" class="medium-zoom-image" style="box-sizing: border-box; margin-block: 0px; outline: 0px; border-radius: 0px; cursor: zoom-in; transition: transform 0.3s cubic-bezier(0.2, 0, 0.2, 1) 0s !important; width: 754.406px; height: 193.938px; max-height: 100%;"></div></figure><div class="notion-text notion-block-f22fe0501f1541e8bb7a41732730582f" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;">如果<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">A3</code>不是第一，也就是说<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">B1</code>拿了第一</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-a756d260d66d4f33952562813c252d54" style="box-sizing: border-box; margin-block: 0px; outline: 0px; margin: 1em 0px; max-width: 100%; min-width: 100%; align-self: center; display: flex; flex-direction: column;"><div style="box-sizing: border-box; margin-block: 0px; outline: 0px; position: relative; display: flex; justify-content: center; align-self: center; width: 754.406px; max-width: 100%; flex-direction: column;"><img src="https://www.notion.so/image/https%3A%2F%2Ftva1.sinaimg.cn%2Flarge%2F0081Kckwly1gls83sba2uj326y0kwe00.jpg?table=block&amp;id=a756d260-d66d-4f33-9525-62813c252d54&amp;cache=v2" loading="lazy" alt="notion image" decoding="async" class="medium-zoom-image" style="box-sizing: border-box; margin-block: 0px; outline: 0px; border-radius: 0px; cursor: zoom-in; transition: transform 0.3s cubic-bezier(0.2, 0, 0.2, 1) 0s !important; width: 754.406px; height: 199.615px; max-height: 100%;"></div></figure><ul class="notion-list notion-list-disc notion-block-f29bf1b438364173a7e9d2785364eef5" style="box-sizing: border-box; margin-block: 0.6em; outline: 0px; margin: 0px; list-style-type: disc; padding-inline-start: 1.7em;"><li style="box-sizing: border-box; margin-block: 0px; outline: 0px; padding: 6px 0px; white-space: pre-wrap;"><code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">25</code>匹马<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">5</code>条跑道找最快的<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">5</code>匹马，需要跑几次？答案：最少<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">8</code>次，最多<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">9</code>次</li></ul><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-5f54c58fc8784349b3296a15892b922f" style="box-sizing: border-box; margin-block: 0px; outline: 0px; margin: 1em 0px; max-width: 100%; min-width: 100%; align-self: center; display: flex; flex-direction: column;"><div style="box-sizing: border-box; margin-block: 0px; outline: 0px; position: relative; display: flex; justify-content: center; align-self: center; width: 754.406px; max-width: 100%; flex-direction: column;"><img src="https://www.notion.so/image/https%3A%2F%2Ftva1.sinaimg.cn%2Flarge%2F0081Kckwly1gls7v9cethj32420g8n14.jpg?table=block&amp;id=5f54c58f-c878-4349-b329-6a15892b922f&amp;cache=v2" loading="lazy" alt="notion image" decoding="async" class="medium-zoom-image" style="box-sizing: border-box; margin-block: 0px; outline: 0px; border-radius: 0px; cursor: zoom-in; transition: transform 0.3s cubic-bezier(0.2, 0, 0.2, 1) 0s !important; width: 754.406px; height: 160.906px; max-height: 100%;"></div></figure><div class="notion-text notion-block-3ffa757b9b6b4e77b3fb04ab987b735c" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;">现在已经跑了<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">5 + 1</code>=<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">6</code>次</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-4519e4a527e8419d8e6e8056a8f4acb6" style="box-sizing: border-box; margin-block: 0px; outline: 0px; margin: 1em 0px; max-width: 100%; min-width: 100%; align-self: center; display: flex; flex-direction: column;"><div style="box-sizing: border-box; margin-block: 0px; outline: 0px; position: relative; display: flex; justify-content: center; align-self: center; width: 754.406px; max-width: 100%; flex-direction: column;"><img src="https://www.notion.so/image/https%3A%2F%2Ftva1.sinaimg.cn%2Flarge%2F0081Kckwly1gls7oou8h2j324k0g4wun.jpg?table=block&amp;id=4519e4a5-27e8-419d-8e6e-8056a8f4acb6&amp;cache=v2" loading="lazy" alt="notion image" decoding="async" class="medium-zoom-image" style="box-sizing: border-box; margin-block: 0px; outline: 0px; border-radius: 0px; cursor: zoom-in; transition: transform 0.3s cubic-bezier(0.2, 0, 0.2, 1) 0s !important; width: 754.406px; height: 158.76px; max-height: 100%;"></div></figure><div class="notion-text notion-block-0f7c67dc4cf64d05b7cd6188c5c8e92e" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;">现在已经跑了<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">5 + 1 + 1</code> = <code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">7</code>次</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-51b2e861b3db4eddb5432bde46e15803" style="box-sizing: border-box; margin-block: 0px; outline: 0px; margin: 1em 0px; max-width: 100%; min-width: 100%; align-self: center; display: flex; flex-direction: column;"><div style="box-sizing: border-box; margin-block: 0px; outline: 0px; position: relative; display: flex; justify-content: center; align-self: center; width: 754.406px; max-width: 100%; flex-direction: column;"><img src="https://www.notion.so/image/https%3A%2F%2Ftva1.sinaimg.cn%2Flarge%2F0081Kckwly1gls7ok26wbj31ki0u01kx.jpg?table=block&amp;id=51b2e861-b3db-4edd-b543-2bde46e15803&amp;cache=v2" loading="lazy" alt="notion image" decoding="async" class="medium-zoom-image" style="box-sizing: border-box; margin-block: 0px; outline: 0px; border-radius: 0px; cursor: zoom-in; transition: transform 0.3s cubic-bezier(0.2, 0, 0.2, 1) 0s !important; width: 754.406px; height: 400.562px; max-height: 100%;"></div></figure></div></details> <h3 id="烧香确定时间问题"><a href="#烧香确定时间问题" class="headerlink" title="烧香确定时间问题"></a><strong>烧香确定时间问题</strong></h3><p>有两根不均匀的香，燃烧完都需要一个小时，问怎么确定<code>**15**</code>分钟的时长？</p><details class="notion-toggle notion-block-cb07f82aa6a94d868e60ae500215f6ba" open="" style="box-sizing: border-box; margin-block: 0px; outline: 0px; padding: 3px 2px;"><summary style="box-sizing: border-box; margin-block: 0px; outline: none; cursor: pointer; color: var(--theme-color,#42b983); font-weight: 700; font-size: 20px !important;"></summary><div style="box-sizing: border-box; margin-block: 0px; outline: 0px; margin-left: 1.1em;"><div class="notion-text notion-block-5151c7694fb148e88fb9024a3f872322" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 2px 0px 1px;">相对时间的思路。</div><div class="notion-text notion-block-4f63211df93b4d409c9bf1beaef5157f" style="box-sizing: border-box; margin-block: 0px; outline: 0px; width: 754.406px; white-space: pre-wrap; word-break: break-word; padding: 0.5em 2px; margin: 1px 0px;">答：设两根香分别为<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">A</code>、<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">B</code>，先把<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">A</code>一端点燃，然后把<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">B</code>的两端都点燃，这样当<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">B</code>烧完的时候，<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">A</code>就还剩下一半（此时能确定半小时），此时把<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">A</code>的另一端也点燃，那么从此刻到<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">A</code>烧完的时间就是<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">15</code>分钟。</div></div></details><h3 id="掰巧克力问题"><a href="#掰巧克力问题" class="headerlink" title="掰巧克力问题"></a><strong>掰巧克力问题</strong></h3><ul><li><p><code>**N\*M**</code>块巧克力，每次掰一块的一行或一列，掰成<code>**1\*1**</code>的巧克力需要多少次？</p></li><li><p>淘汰问题：<code>**1000**</code>个人参加辩论赛，<code>**1V1**</code>，输了就退出，需要安排多少场比赛？</p></li></ul><details class="notion-toggle notion-block-d316cb3e17df4ef5b893c8cbceecfe8a" open="" style="box-sizing: border-box; margin-block: 0px; outline: 0px; padding: 3px 2px;"><summary style="box-sizing: border-box; margin-block: 0px; outline: none; cursor: pointer; color: var(--theme-color,#42b983); font-weight: 700; font-size: 20px !important;"></summary><div style="box-sizing: border-box; margin-block: 0px; outline: 0px; margin-left: 1.1em;"><ul class="notion-list notion-list-disc notion-block-4a1e12fac6fd444b99d4dac55bbc89c2" style="box-sizing: border-box; margin-block: 0.6em; outline: 0px; margin: 0px; list-style-type: disc; padding-inline-start: 1.7em;"><li style="box-sizing: border-box; margin-block: 0px; outline: 0px; padding: 6px 0px; white-space: pre-wrap;">每次拿起一块巧克力，掰一下（无论横着还是竖着）都会变成两块，因为所有的巧克力共有<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">N*M</code>块，所以要掰<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">N*M-1</code>次，减<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">1</code>是因为最开始的一块是不用算进去的。</li></ul><ul class="notion-list notion-list-disc notion-block-711c2fcd7981497b93e37d1301d5bc2a" style="box-sizing: border-box; margin-block: 0.6em; outline: 0px; margin: 0px; list-style-type: disc; padding-inline-start: 1.7em;"><li style="box-sizing: border-box; margin-block: 0px; outline: 0px; padding: 6px 0px; white-space: pre-wrap;">每一场辩论赛两个人，淘汰一个人，所以可以看作是每一场辩论赛减少一个人，直到最后剩下<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">1</code>个人，所以是<code class="notion-inline-code" style="box-sizing: border-box; margin-block: 0px; outline: 0px; color: rgb(255, 64, 129); padding: 0.2em 0.4em !important; background: rgba(55, 53, 47, 0.1) !important; border-radius: 3px; font-size: 13.6px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; border: 0px !important; box-shadow: none !important;">1000 - 1 = 999</code>场。</li></ul></div></details>]]></content>
      
      
      <categories>
          
          <category> 校招 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 智力题 </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Axios使用</title>
      <link href="/Axios%E4%BD%BF%E7%94%A8/"/>
      <url>/Axios%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Axios使用"><a href="#Axios使用" class="headerlink" title="Axios使用"></a>Axios使用</h1><h2 id="Axios介绍"><a href="#Axios介绍" class="headerlink" title="Axios介绍"></a>Axios介绍</h2><p>Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。</p><p>首先需要知道：axios不是一种新的技术，axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，本质上也是对原生XHR的封装，只不过它是Promise的实现版本，符合最新的ES规范，有以下特点：</p><ul><li>从浏览器中创建 XMLHttpRequests</li><li>从 node.js 创建 http 请求</li><li>支持 Promise API</li><li>拦截请求和响应</li><li>转换请求数据和响应数据</li><li>取消请求</li><li>自动转换 JSON 数据</li><li>客户端支持防御 XSRF</li></ul><h2 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install axios</span></span><br></pre></td></tr></table></figure><p>或通过标签引入：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>执行 <code>GET</code> 请求</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为给定 ID 的 user 创建请求</span></span><br><span class="line">axios.get(<span class="string">&#x27;/user?ID=12345&#x27;</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的请求也可以这样做</span></span><br><span class="line">axios.get(<span class="string">&#x27;/user&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">params</span>: &#123;</span><br><span class="line">      <span class="attr">ID</span>: <span class="number">12345</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>执行 <code>POST</code> 请求</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.post(<span class="string">&#x27;/user&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;Fred&#x27;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&#x27;Flintstone&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>可以通过向 <code>axios</code> 传递相关配置来创建请求</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送 POST 请求</span></span><br><span class="line">axios(&#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;/user/12345&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;Fred&#x27;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&#x27;Flintstone&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>中文文档：<a href="http://www.axios-js.com/zh-cn/docs/">http://www.axios-js.com/zh-cn/docs/</a></p><h2 id="与Vue整合"><a href="#与Vue整合" class="headerlink" title="与Vue整合"></a>与Vue整合</h2><p>在实际项目开发中，几乎每个组件中都会用到 axios 发起数据请求。此时会遇到如下两个问题：</p><ul><li>每个组件中都需要导入 axios（代码臃肿）</li><li>每次发请求都需要填写完整的请求路径（不利于后期的维护）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220213112222585.png" alt="image-20220213112222585"></p><p>可以通过全局配置的方式解决上述问题：</p><p>在 main.js 入口文件中，通过 app.config.globalProperties 全局挂载 axios，示例代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入axios库</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = createApp(App)</span><br><span class="line"><span class="comment">// 配置请求根路径</span></span><br><span class="line">axios.defaults.baseURL = <span class="string">&#x27;http://api.com&#x27;</span></span><br><span class="line"><span class="comment">// 将axios作为全局的自定义属性，每个组件可以在内部直接访问</span></span><br><span class="line">app.config.globalProperties.$http = axios</span><br><span class="line"></span><br><span class="line">app.mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220213112710961.png" alt="image-20220213112710961"></p><h1 id="前后端分离例子"><a href="#前后端分离例子" class="headerlink" title="前后端分离例子"></a>前后端分离例子</h1><h2 id="axios配置"><a href="#axios配置" class="headerlink" title="axios配置"></a>axios配置</h2><h3 id="需显示数据的页面-TChart7-vue"><a href="#需显示数据的页面-TChart7-vue" class="headerlink" title="需显示数据的页面(TChart7.vue)"></a>需显示数据的页面(TChart7.vue)</h3><h4 id="引入axios"><a href="#引入axios" class="headerlink" title="引入axios"></a>引入axios</h4><pre><code>import axios from &quot;axios&quot;;</code></pre><h4 id="建立连接-传递数据"><a href="#建立连接-传递数据" class="headerlink" title="建立连接 传递数据"></a>建立连接 传递数据</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.post(<span class="string">&quot;http://127.0.0.1:5000/TChart7.json&quot;</span>).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;<span class="comment">//与对应端口建立连接</span></span><br><span class="line">    <span class="built_in">this</span>.tChart7 = response.data;      <span class="comment">// 接受数据</span></span><br><span class="line">    myChart.setOption(&#123;  <span class="comment">//重新调用显示图表函数，解决axios异步导致echart图像先渲染而数据没导入的问题</span></span><br><span class="line">                    <span class="attr">series</span>: [&#123;</span><br><span class="line">                    <span class="attr">data</span>: <span class="built_in">this</span>.tChart7 <span class="comment">// 将数据放入</span></span><br><span class="line">                    &#125;]</span><br><span class="line">                &#125;)</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;tchart7&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 600px; height: 400px&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;tc7&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">import</span> cdw <span class="keyword">from</span> <span class="string">&quot;../../../../assets/theme/cdw.json&quot;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">import</span> * <span class="keyword">as</span> echarts <span class="keyword">from</span> <span class="string">&quot;echarts&quot;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">tChart7</span>: <span class="literal">null</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">name</span>: <span class="string">&quot;tchart7&quot;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">myEcharts</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">// 基于准备好的dom，初始化echarts实例</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">let</span> obj = cdw;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      echarts.registerTheme(<span class="string">&#x27;cdw&#x27;</span>, obj)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">//var myChart = this.$echarts.init(document.getElementById(&#x27;chart3&#x27;));</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">var</span> myChart = echarts.init(<span class="built_in">this</span>.$refs.tc7,<span class="string">&#x27;cdw&#x27;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">// 指定图表的配置项和数据</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">var</span> option = &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="attr">title</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          <span class="attr">text</span>: <span class="string">&quot;指标分析&quot;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          <span class="attr">textStyle</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="attr">fontSize</span>: <span class="number">25</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="attr">color</span>: <span class="string">&quot;#ffffff&quot;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="attr">tooltip</span>: &#123;&#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="attr">legend</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          <span class="attr">data</span>: [<span class="string">&quot;百分比&quot;</span>],</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="attr">xAxis</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          <span class="attr">data</span>: [<span class="string">&quot;空间&quot;</span>, <span class="string">&quot;操控&quot;</span>, <span class="string">&quot;外观&quot;</span>, <span class="string">&quot;内饰&quot;</span>, <span class="string">&quot;舒适性&quot;</span>, <span class="string">&quot;性价比&quot;</span>],</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          <span class="attr">nameTextStyle</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="attr">color</span>: <span class="string">&quot;rgba(255, 255, 255, 1)&quot;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="comment">//   [66, 23, 52, 77, 37, 90],</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="attr">yAxis</span>: &#123;&#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="attr">series</span>: [</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="attr">name</span>: <span class="string">&quot;百分比&quot;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="attr">type</span>: <span class="string">&quot;bar&quot;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="attr">data</span>: [],</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="attr">showBackground</span>: <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="attr">backgroundStyle</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">              <span class="attr">color</span>: <span class="string">&quot;rgba(180, 180, 180, 0.2)&quot;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="attr">color</span>: <span class="string">&quot;#44fdc5&quot;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        ],</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">// 使用刚指定的配置项和数据显示图表。</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      myChart.setOption(option);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      axios.post(<span class="string">&quot;http://127.0.0.1:5000/TChart7.json&quot;</span>).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="built_in">this</span>.tChart7 = response.data;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        myChart.setOption(&#123;  <span class="comment">//动画的配置</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">                        <span class="attr">series</span>: [&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">                        <span class="attr">data</span>: <span class="built_in">this</span>.tChart7 <span class="comment">//这里数据是一个数组的形似</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">                        &#125;]</span></span></span><br><span class="line"><span class="javascript"><span class="xml">                    &#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="built_in">this</span>.myEcharts();</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>​        </p><h3 id="python文件（app-py）"><a href="#python文件（app-py）" class="headerlink" title="python文件（app.py）"></a>python文件（app.py）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line"><span class="keyword">from</span> flask_cors <span class="keyword">import</span> cross_origin, CORS</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">app = Flask(__name__, static_folder=<span class="string">&quot;http&quot;</span>, static_url_path=<span class="string">&quot;/pages&quot;</span>)</span><br><span class="line">CORS(app, supports_credentials=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><hr><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/TChart7.json&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>]</span>)  </span></span><br><span class="line"><span class="meta">@cross_origin(<span class="params">supports_credentials=<span class="literal">True</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handleTChart7Request</span>():</span></span><br><span class="line">    data = [<span class="number">66</span>, <span class="number">23</span>, <span class="number">52</span>, <span class="number">77</span>, <span class="number">37</span>, <span class="number">90</span>]     // 放入数据</span><br><span class="line">    <span class="built_in">print</span>(json.dumps(data))</span><br><span class="line">    <span class="keyword">return</span> json.dumps(data)</span><br><span class="line"></span><br><span class="line">app.run(port=<span class="string">&quot;5000&quot;</span>)                    // 设置端口（需和网页端口不同）</span><br></pre></td></tr></table></figure><h3 id="json文件（TChart7-json）"><a href="#json文件（TChart7-json）" class="headerlink" title="json文件（TChart7.json）"></a>json文件（TChart7.json）</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: [</span><br><span class="line">        <span class="number">66</span>, </span><br><span class="line">        <span class="number">23</span>, </span><br><span class="line">        <span class="number">52</span>, </span><br><span class="line">        <span class="number">77</span>, </span><br><span class="line">        <span class="number">37</span>, </span><br><span class="line">        <span class="number">90</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 客户端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 客户端 </tag>
            
            <tag> Axios </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue基础入门</title>
      <link href="/Vue%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
      <url>/Vue%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="vue-简介"><a href="#vue-简介" class="headerlink" title="vue 简介"></a>vue 简介</h1><h2 id="什么是-vue"><a href="#什么是-vue" class="headerlink" title="什么是 vue"></a>什么是 vue</h2><p>Vue (读音 /vjuː/，类似于 <strong>view</strong>) 是一套用于构建用户界面的<strong>渐进式框架</strong>。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p><h3 id="构建用户界面"><a href="#构建用户界面" class="headerlink" title="构建用户界面"></a><strong>构建用户界面</strong></h3><p>前端开发者最主要的工作，就是为网站的使用者（又称为：网站的用户）构建出美观、舒适、好用的网页。</p><p>构建用户界面可分为以下大部分：</p><ul><li>编写结构，基于 HTML 超文本标记语言，搭建出网页的内容结构。</li><li>美化样式，基于CSS 样式，美化网页的可视化效果。</li><li>处理交互，基于 Javascript 来操作网页中的 DOM 对象，处理用户和网页之间的交互行为。</li></ul><h3 id="构建用户界面的传统方式"><a href="#构建用户界面的传统方式" class="headerlink" title="构建用户界面的传统方式"></a><strong>构建用户界面的传统方式</strong></h3><p>在传统的 Web 前端开发中，是基于 jQuery + 模板引擎 的方式来构建用户界面的。</p><ul><li>编写结构，基于模板引擎技术，把数据渲染到页面上，初步解放了前端开发者，从此不用手动拼接字符串来渲染网页结构了，但需要定义大量的模板结构，数据变化时需要重新调用模板编译的函数，否则页面结构不会更新；</li><li>美化样式，基于CSS 样式，美化网页的可视化效果。</li><li>处理交互，基于 jQuery 技术，处理用户和网页之间的交互行为，屏蔽了 DOM API 之间的兼容性，提高了 DOM 操作的效率和体验，当业务复杂时、数据变化频繁时，前端程开发者需要把大量的时间和精力浪费在 DOM的操作上，而不是核心业务的处理上。</li></ul><h3 id="使用-vue-构建用户界面"><a href="#使用-vue-构建用户界面" class="headerlink" title="使用 vue 构建用户界面"></a><strong>使用 vue 构建用户界面</strong></h3><p>使用 vue 构建用户界面，解决了 jQuery + 模板引擎 的诸多痛点，极大的提高了前端开发的效率和体验</p><ul><li>编写结构，基于 vue 中提供的指令，可以方便快捷的渲染页面的结构，数据驱动视图（只要页面依赖的数据源变化，则页面自动重新渲染）</li><li>美化样式，基于CSS 样式，美化网页的可视化效果。</li><li>处理交互，基于 vue 中提供的事件绑定，可以轻松处理用户和页面之间的交互行为。</li></ul><p>官方给 vue 的定位是前端框架，因为它提供了构建用户界面的一整套解决方案（俗称 vue 全家桶）：</p><ul><li><p>vue（核心库）</p></li><li><p>vue-router（路由方案）</p></li><li><p>vuex（状态管理方案）</p></li><li><p>vue 组件库（快速搭建页面 UI 效果的方案）</p></li></ul><p>辅助 vue 项目开发的一系列工具：</p><ul><li><p>vue-cli（npm 全局包：一键生成工程化的 vue 项目 - 基于 webpack）</p></li><li><p>vue-devtools（浏览器插件：辅助调试的工具）</p></li><li><p>vetur（vscode 插件：提供语法高亮和智能提示）</p></li></ul><h2 id="vue-的特性"><a href="#vue-的特性" class="headerlink" title="vue 的特性"></a>vue 的特性</h2><p>vue 框架的特性，主要体现在如下两方面：</p><ul><li>数据驱动视图</li><li>双向数据绑定</li></ul><h3 id="数据驱动视图"><a href="#数据驱动视图" class="headerlink" title="数据驱动视图"></a><strong>数据驱动视图</strong></h3><p>在使用了 vue 的页面中，vue 会监听数据的变化，从而自动重新渲染页面的结构。示意图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image123.png"></p><p>注意，数据驱动视图是单向的数据绑定。</p><h3 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a><strong>双向数据绑定</strong></h3><p>在填写表单时，双向数据绑定可以辅助开发者在不操作 DOM 的前提下，自动把用户填写的内容同步到数据源中，开发者不再需要手动操作 DOM 元素，来获取表单元素最新的值。示意图如下：</p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220212205809167.png" alt="image-20220212205809167" style="zoom:90%;" /><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image28.png" alt="image-20220212205911538" style="zoom:80%;" /><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a><strong>MVVM</strong></h3><p>MVVM 是 vue 实现数据驱动视图和双向数据绑定的核心原理。它把每个 HTML 页面都拆分成了如下三个部分：</p><p>在 MVVM 概念中：</p><ul><li><p>View 表示当前页面所渲染的 DOM 结构。</p></li><li><p>Model 表示当前页面渲染时所依赖的数据源，</p></li><li><p>ViewModel 表示 vue 的实例，它是 MVVM 的核心。</p></li></ul><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image22.png" alt="image-20220212210112022" style="zoom:80%;" /><h3 id="MVVM-的工作原理"><a href="#MVVM-的工作原理" class="headerlink" title="MVVM 的工作原理"></a><strong>MVVM 的工作原理</strong></h3><p>ViewModel 作为 MVVM 的核心，是它把当前页面的数据源（Model）和页面的结构（View）连接在了一起。</p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20220212210234849.png" alt="image-20220212210234849" style="zoom:80%;" /><ul><li>当数据源发生变化时，会被 ViewModel 监听到，VM 会根据最新的数据源自动更新页面的结构</li><li>当表单元素的值发生变化时，也会被 VM 监听到，VM 会把变化过后最新的值自动同步到 Model 数据源中</li></ul><h3 id="vue-的版本"><a href="#vue-的版本" class="headerlink" title="vue 的版本"></a><strong>vue 的版本</strong></h3><p>当前，vue 共有 3 个大版本，其中：</p><ul><li>1.x 版本的 vue 几乎被淘汰，不再建议学习与使用。</li><li>2.x 版本的 vue 是目前企业级项目开发中的主流版本，在未来会被逐渐淘汰。</li><li>3.x 版本的 vue 于 2020-09-19 发布，生态还不完善，尚未在企业级项目开发中普及和推广，是未来企业级项目开发的趋势。</li></ul><h3 id="vue3-x-和-vue2-x-版本的对比"><a href="#vue3-x-和-vue2-x-版本的对比" class="headerlink" title="vue3.x 和 vue2.x 版本的对比"></a><strong>vue3.x 和 vue2.x 版本的对比</strong></h3><p>vue2.x 中绝大多数的 API 与特性，在 vue3.x 中同样支持。同时，vue3.x 中还新增了 3.x 所特有的功能、并废弃了某些 2.x 中的旧功能：</p><p>新增的功能例如：组合式 API、多根节点组件、更好的 TypeScript 支持等</p><p>废弃的旧功能如下：过滤器、不再支持 $on，$off 和 $once 实例方法等</p><h2 id="基本使用步骤"><a href="#基本使用步骤" class="headerlink" title="基本使用步骤"></a>基本使用步骤</h2><ol><li>导入 vue.js 的 script 脚本文件</li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/vue@next&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在页面中声明一个将要被 vue 所控制的 DOM 区域，既MVVM中的View</li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; message &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>创建 vm 实例对象（vue 实例对象）</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hello = &#123;</span><br><span class="line">    <span class="comment">// 指定数据源，既MVVM中的Model</span></span><br><span class="line">    <span class="attr">data</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">message</span>: <span class="string">&#x27;Hello Vue!&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> app = Vue.createApp(hello)</span><br><span class="line">app.mount(<span class="string">&#x27;#app&#x27;</span>) <span class="comment">// 指定当前vue实例要控制页面的哪个区域##</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬取Bilibili排行榜</title>
      <link href="/%E7%88%AC%E5%8F%96Bilibili%E6%8E%92%E8%A1%8C%E6%A6%9C/"/>
      <url>/%E7%88%AC%E5%8F%96Bilibili%E6%8E%92%E8%A1%8C%E6%A6%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="爬取哔哩哔哩排行榜信息"><a href="#爬取哔哩哔哩排行榜信息" class="headerlink" title="爬取哔哩哔哩排行榜信息"></a>爬取哔哩哔哩排行榜信息</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><div class="note warning"><p>这是作者的一个Python通选课的小项目（有些粗糙）</p></div><p><strong>本项目参考自：</strong><a href="https://blog.csdn.net/Jacompol">三秋树&amp;二月花</a></p><p><strong>原项目爬取时间为<span class='p inline-tag t-blue'>2020.12</span>，B站排行榜源码已发生改变，目前已无法爬取。</strong></p><p><strong>本项目爬取时间为<span class='p inline-tag t-red'>2021.12</span></strong> </p><p><strong>项目源码：</strong> <a href="https://github.com/chenduowen233/Py-Bilibili">https://github.com/chenduowen233/Py-Bilibili</a></p><p>通过爬取哔哩哔哩排行榜，支持获取并分析番剧、国产动画、纪录片、电视剧等排行榜的排名、更新话数、播放量、平均每话播放量、追番人数等数据，并绘制出可视化视图。</p><h2 id="数据爬取"><a href="#数据爬取" class="headerlink" title="数据爬取"></a>数据爬取</h2><p><strong>爬取网页网址：</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 国产动画排行榜分析</span></span><br><span class="line"><span class="comment"># url = &#x27;https://www.bilibili.com/v/popular/rank/guochan&#x27;</span></span><br><span class="line"><span class="comment"># 番剧排行榜分析</span></span><br><span class="line">url = <span class="string">&#x27;https://www.bilibili.com/v/popular/rank/bangumi&#x27;</span></span><br><span class="line"><span class="comment"># 电视剧排行榜分析</span></span><br><span class="line"><span class="comment"># url = &#x27;https://www.bilibili.com/v/popular/rank/tv&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>使用<code>requests.get</code>来获取网页数据：</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">requests.get(url) </span><br></pre></td></tr></table></figure><h2 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h2><h3 id="构建BeautifulSoup实例"><a href="#构建BeautifulSoup实例" class="headerlink" title="构建BeautifulSoup实例"></a><strong>构建BeautifulSoup实例</strong></h3><p><strong>解析网页 指定<code>BeautifulSoup</code>的解析器：</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup = BeautifulSoup(html, <span class="string">&#x27;html.parser&#x27;</span>) </span><br></pre></td></tr></table></figure><h3 id="初始化要存入信息的容器"><a href="#初始化要存入信息的容器" class="headerlink" title="初始化要存入信息的容器"></a><strong>初始化要存入信息的容器</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = []    <span class="comment"># 动漫名字</span></span><br><span class="line">hua = []     <span class="comment"># 更新话数</span></span><br><span class="line">bfl = []     <span class="comment"># 播放量</span></span><br><span class="line">zf = []      <span class="comment"># 追番数</span></span><br><span class="line">pjbfl = []   <span class="comment"># 平均每话播放量</span></span><br></pre></td></tr></table></figure><h3 id="数据解析与提取"><a href="#数据解析与提取" class="headerlink" title="数据解析与提取"></a><strong>数据解析与提取</strong></h3><p><strong>使用<code>beautifulsoup</code>的<code>find_all()</code> 解析数据</strong></p><p><strong><code>find_all()</code>的第一个参数是标签名，第二个是标签中的<code>class</code>值</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20211209145205454.png" alt="image-20211209145205454"></p><p><strong>使用正则表达式提取所需数据</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br></pre></td></tr></table></figure><p><strong>提取剧名：</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> tag <span class="keyword">in</span> soup.find_all(<span class="string">&#x27;div&#x27;</span>, class_=<span class="string">&#x27;info&#x27;</span>):</span><br><span class="line">    <span class="comment"># print(tag)</span></span><br><span class="line">    bf = tag.a.string</span><br><span class="line">    name.append(<span class="built_in">str</span>(bf))</span><br><span class="line"><span class="built_in">print</span>(name)</span><br></pre></td></tr></table></figure><p><strong>提取更新话数：</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> tag <span class="keyword">in</span> soup.find_all(<span class="string">&#x27;div&#x27;</span>, class_=<span class="string">&#x27;detail&#x27;</span>):</span><br><span class="line">  bf = tag.find(<span class="string">&#x27;span&#x27;</span>, class_=<span class="string">&#x27;data-box&#x27;</span>).get_text()</span><br><span class="line">  bf = <span class="built_in">float</span>(re.search(<span class="string">r&#x27;\d*(\.)?\d&#x27;</span>, bf).group())</span><br><span class="line">  hua.append(<span class="built_in">float</span>(bf))</span><br><span class="line"><span class="built_in">print</span>(hua)</span><br></pre></td></tr></table></figure><p><strong>提取播放量：</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> tag <span class="keyword">in</span> soup.find_all(<span class="string">&#x27;div&#x27;</span>, class_=<span class="string">&#x27;detail-state&#x27;</span>):</span><br><span class="line">    bf = tag.find(<span class="string">&#x27;span&#x27;</span>, class_=<span class="string">&#x27;data-box&#x27;</span>).get_text()</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;亿&#x27;</span> <span class="keyword">in</span> bf:</span><br><span class="line">        num = <span class="built_in">float</span>(re.search(<span class="string">r&#x27;\d(.\d)?&#x27;</span>, bf).group()) * <span class="number">10000</span></span><br><span class="line">        bf = num</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        bf = re.search(<span class="string">r&#x27;\d*(\.)?\d&#x27;</span>, bf).group()</span><br><span class="line">    bfl.append(<span class="built_in">float</span>(bf))</span><br><span class="line"><span class="built_in">print</span>(bfl)</span><br></pre></td></tr></table></figure><p><strong>提取追番人数：</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> tag <span class="keyword">in</span> soup.find_all(<span class="string">&#x27;div&#x27;</span>, class_=<span class="string">&#x27;detail-state&#x27;</span>):</span><br><span class="line">    bf = tag.find(<span class="string">&#x27;span&#x27;</span>, class_=<span class="string">&#x27;data-box&#x27;</span>).next_sibling.next_sibling.get_text()</span><br><span class="line">    bf = re.search(<span class="string">r&#x27;\d*(\.)?\d&#x27;</span>, bf).group()</span><br><span class="line">    zf.append(<span class="built_in">float</span>(bf))</span><br><span class="line"><span class="built_in">print</span>(zf)</span><br></pre></td></tr></table></figure><p><strong><code>.next_sibling</code>是用于提取同级别的相同标签信息</strong></p><h2 id="数据分析与统计"><a href="#数据分析与统计" class="headerlink" title="数据分析与统计"></a>数据分析与统计</h2><h3 id="引入numpy："><a href="#引入numpy：" class="headerlink" title="引入numpy："></a><strong>引入<code>numpy</code>：</strong></h3><p><strong>由<a href="https://so.csdn.net/so/search?from=pc_blog_highlight&q=%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84">多维数组</a>对象和用于处理数组的例程集合组成的库</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><p><strong>利用 <code>np.divide</code> 将数组对应相除求出平均每话的播放量:</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pjbfl = np.divide(bfl, hua)</span><br></pre></td></tr></table></figure><h2 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h2><p><strong>存储方式：<code>.txt</code>：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/wps8D58.tmp.jpg" alt="img"> </p><p><strong>将解析后的数据存入文本文件：</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./data/B_data.txt&#x27;</span>, <span class="string">&#x27;r+&#x27;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(soup.text)</span><br></pre></td></tr></table></figure><p><strong>解析后的数据：</strong> <img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20211209144339958.png" alt="image-20211209144339958"></p><p><strong>存储方式：<code>.xlsx</code>:</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/wps8D59.tmp.jpg" alt="img"> </p><p><strong>将提取后的数据存入Bilibili.xlsx文件：</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dm_file = pandas.DataFrame(info)</span><br><span class="line">dm_file.to_excel(<span class="string">&#x27;Bilibili.xlsx&#x27;</span>, sheet_name=<span class="string">&quot;动漫数据分析&quot;</span>)</span><br></pre></td></tr></table></figure><p> <strong>番剧排行榜：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/wps8D5A.tmp.jpg" alt="img"></p><p><strong>电视剧排行榜：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/wps8D5B.tmp.jpg" alt="img"></p><h2 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h2><h3 id="采用Matplotlib进行可视化"><a href="#采用Matplotlib进行可视化" class="headerlink" title="采用Matplotlib进行可视化"></a><strong>采用<code>Matplotlib</code>进行可视化</strong></h3><p><strong><code>Matplotlib</code>是一个在 <code>python</code> 下实现的类 <code>matlab</code> 的纯 <code>python</code> 的第三方库。</strong></p><p><strong>绘图示例:</strong>        <a href="https://matplotlib.org/stable/gallery/index">https://matplotlib.org/stable/gallery/index</a></p><p><strong>PDF版本示例:</strong>   <a href="https://github.com/matplotlib/cheatsheets">https://github.com/matplotlib/cheatsheets</a></p><h3 id="设置中文字体："><a href="#设置中文字体：" class="headerlink" title="设置中文字体："></a><strong>设置中文字体：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_font = font_manager.FontProperties(fname=<span class="string">&#x27;./data/STHeiti Medium.ttc&#x27;</span>) </span><br></pre></td></tr></table></figure><h3 id="绘制图形，实现数据可视化分析："><a href="#绘制图形，实现数据可视化分析：" class="headerlink" title="绘制图形，实现数据可视化分析："></a><strong>绘制图形，实现数据可视化分析：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, ax1 = plt.subplots()</span><br><span class="line">ax1.stem(dm_name, dm_play)</span><br><span class="line">plt.title(<span class="string">&#x27;播放量数据分析&#x27;</span>, fontproperties=my_font)</span><br><span class="line">ax1.tick_params(labelsize=<span class="number">6</span>)</span><br><span class="line">plt.xticks(rotation=<span class="number">90</span>, color=<span class="string">&#x27;grey&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;播放量（万）&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;番剧名&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="具体绘制实现五种数据可视化分析图："><a href="#具体绘制实现五种数据可视化分析图：" class="headerlink" title="具体绘制实现五种数据可视化分析图："></a><strong>具体绘制实现五种数据可视化分析图：</strong></h3><p><strong>播放量数据分析：</strong> </p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/wps8D5C.tmp.jpg" alt="img"> </p><p><strong>更新话数和播放量数据分析：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/wps8D6C.tmp.jpg" alt="img"> </p><p><strong>平均每话播放量数据分析：</strong>   </p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/wps8D6D.tmp.jpg" alt="img"> </p><p><strong>平均每话播放量数和播放量数分析：</strong> </p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/wps8D6E.tmp.jpg" alt="img"> </p><p><strong>追番人数和播放量数据分析：</strong> </p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/wps8D6F.tmp.jpg" alt="img"> </p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Echart使用</title>
      <link href="/Echart%E4%BD%BF%E7%94%A8/"/>
      <url>/Echart%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>ECharts，缩写来自Enterprise Charts，商业级数据图表，一个纯<a href="https://so.csdn.net/so/search?from=pc_blog_highlight&q=Javascript">Javascript</a>的图表库，可以流畅的运行在PC和移动设备上，兼容当前绝大部分浏览器（IE6/7/8/9/10/11，chrome，firefox，Safari等），底层依赖轻量级的Canvas类库ZRender，提供直观，生动，可交互，可高度个性化定制的数据可视化图表。创新的拖拽重计算、数据视图、值域漫游等特性大大增强了用户体验，赋予了用户对数据进行挖掘、整合的能力。</p><h2 id="常用网址"><a href="#常用网址" class="headerlink" title="常用网址"></a>常用网址</h2><p><strong>在ECharts官网运行编辑实例：</strong></p><p><a href="https://echarts.apache.org/examples/zh/index.html">Examples - Apache ECharts</a></p><p><strong>ECharts<code>option</code>中各参数详细配置项：</strong></p><p>[Documentation - Apache ECharts](<a href="https://echarts.apache.org/zh/option.html#title">Documentation - Apache ECharts</a>)</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20211026211420723.png" alt="image-20211026211420723"></p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="Echart主题设定"><a href="#Echart主题设定" class="headerlink" title="Echart主题设定"></a>Echart主题设定</h3><p><strong>先进入echarts 官网，找到主题下载</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20211026210603170.png" alt="image-20211026210603170"></p><p><strong>配置好了选择下载，选择JSON版本</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20211026210749390.png" alt="image-20211026210749390"></p><p><strong>将json文件放入项目文件中并引入</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    </span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> cdw <span class="keyword">from</span> <span class="string">&quot;../../../../assets/theme/cdw.json&quot;</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> obj = cdw;</span></span><br><span class="line"><span class="javascript">echarts.registerTheme(<span class="string">&#x27;cdw&#x27;</span>, obj)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> myChart = echarts.init(<span class="built_in">this</span>.$refs.tc7,<span class="string">&#x27;cdw&#x27;</span>);</span></span><br><span class="line"><span class="javascript"><span class="comment">//var myChart = echarts.init(this.$refs.tc7,&#x27;dark&#x27;);  // 也可以直接使用官方主题</span></span></span><br><span class="line"><span class="javascript">    </span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用服务端返回数据的异步加载和更新"><a href="#使用服务端返回数据的异步加载和更新" class="headerlink" title="使用服务端返回数据的异步加载和更新"></a>使用服务端返回数据的异步加载和更新</h3><p><strong>详细请参考官方文档：</strong></p><p><a href="https://echarts.apache.org/zh/tutorial.html#%E5%BC%82%E6%AD%A5%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%9B%B4%E6%96%B0">Documentation - Apache ECharts</a></p><p><strong>实例：</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;折线图&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 100%; height: 500px;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">       <span class="keyword">import</span> * <span class="keyword">as</span> echarts <span class="keyword">from</span> <span class="string">&#x27;echarts&#x27;</span></span></span><br><span class="line"><span class="javascript">       <span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="attr">chartColumn</span>: <span class="literal">null</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="attr">mydata</span>:<span class="literal">null</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="attr">salePrice</span>: <span class="literal">null</span></span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">            &#125;,</span></span><br><span class="line"><span class="javascript">            <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">                <span class="function"><span class="title">drawLine</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.chartColumn = echarts.init(</span></span><br><span class="line"><span class="javascript">                        <span class="built_in">document</span>.getElementById(<span class="string">&#x27;折线图&#x27;</span>));</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.chartColumn.setOption(&#123;</span></span><br><span class="line"><span class="javascript">                    </span></span><br><span class="line"><span class="javascript">                <span class="attr">title</span>: &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="attr">text</span>: <span class="string">&#x27;汽车价格对比阶梯折线图&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="attr">textStyle</span>: &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="attr">fontSize</span>: <span class="number">25</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="attr">color</span>: <span class="string">&#x27;#ffffff&#x27;</span>&#125;</span></span><br><span class="line"><span class="javascript">                &#125;,</span></span><br><span class="line"><span class="javascript">                <span class="attr">tooltip</span>: &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="attr">trigger</span>: <span class="string">&#x27;axis&#x27;</span></span></span><br><span class="line"><span class="javascript">                &#125;,</span></span><br><span class="line"><span class="javascript">                <span class="attr">legend</span>: &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="attr">data</span>: [],</span></span><br><span class="line"><span class="javascript">                    <span class="attr">textStyle</span>:&#123;</span></span><br><span class="line"><span class="javascript">                            <span class="attr">color</span>: <span class="string">&#x27;#ffffff&#x27;</span><span class="comment">//字体颜色</span></span></span><br><span class="line"><span class="javascript">                        &#125;,</span></span><br><span class="line"><span class="javascript">                &#125;,</span></span><br><span class="line"><span class="javascript">                <span class="attr">grid</span>: &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="attr">left</span>: <span class="string">&#x27;3%&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="attr">right</span>: <span class="string">&#x27;4%&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="attr">bottom</span>: <span class="string">&#x27;3%&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="attr">containLabel</span>: <span class="literal">true</span></span></span><br><span class="line"><span class="javascript">                &#125;,</span></span><br><span class="line"><span class="javascript">                <span class="attr">toolbox</span>: &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="attr">feature</span>: &#123;</span></span><br><span class="line"><span class="javascript">                        <span class="attr">saveAsImage</span>: &#123;&#125;</span></span><br><span class="line"><span class="javascript">                    &#125;</span></span><br><span class="line"><span class="javascript">                &#125;,</span></span><br><span class="line"><span class="javascript">                <span class="attr">xAxis</span>: &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="attr">type</span>: <span class="string">&#x27;category&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="attr">data</span>: []</span></span><br><span class="line"><span class="javascript">                &#125;,</span></span><br><span class="line"><span class="javascript">                <span class="attr">yAxis</span>: &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="attr">type</span>: <span class="string">&#x27;value&#x27;</span></span></span><br><span class="line"><span class="javascript">                &#125;,</span></span><br><span class="line"><span class="javascript">                <span class="attr">series</span>: [</span></span><br><span class="line"><span class="javascript">                    &#123;</span></span><br><span class="line"><span class="javascript">                        <span class="attr">name</span>: <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                        <span class="attr">type</span>: <span class="string">&#x27;line&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                        <span class="attr">step</span>: <span class="string">&#x27;start&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                        <span class="attr">data</span>: []</span></span><br><span class="line"><span class="javascript">                    &#125;,</span></span><br><span class="line"><span class="javascript">                    &#123;</span></span><br><span class="line"><span class="javascript">                        <span class="attr">name</span>: <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                        <span class="attr">type</span>: <span class="string">&#x27;line&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                        <span class="attr">step</span>: <span class="string">&#x27;middle&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                        <span class="attr">data</span>: []</span></span><br><span class="line"><span class="javascript">                    &#125;</span></span><br><span class="line"><span class="javascript">                ]</span></span><br><span class="line"><span class="javascript">            &#125;);</span></span><br><span class="line"><span class="javascript">            axios.post(<span class="string">&quot;http://127.0.0.1:5000/carSalePrice.json&quot;</span>).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.salePrice = response.data;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(<span class="built_in">this</span>.salePrice)</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.chartColumn.setOption( <span class="comment">//动画的配置 异步加载数据</span></span></span><br><span class="line"><span class="javascript">                        <span class="built_in">this</span>.salePrice</span></span><br><span class="line"><span class="javascript">                    )</span></span><br><span class="line"><span class="javascript">                &#125;);</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EChart </tag>
            
            <tag> 前端 </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git常用命令清单</title>
      <link href="/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95/"/>
      <url>/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Git常用命令清单"><a href="#Git常用命令清单" class="headerlink" title="Git常用命令清单"></a>Git常用命令清单</h1><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/git_001.png" alt="img"></p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="git有四个个工作区："><a href="#git有四个个工作区：" class="headerlink" title="git有四个个工作区："></a>git有四个个工作区：</h3><p><strong>工作区（workspace）</strong></p><p><strong>暂存区（index/stage）</strong></p><p><strong>本地仓库（local repository）</strong></p><p><strong>远程仓库（remote repository）</strong></p><h2 id="新建代码库"><a href="#新建代码库" class="headerlink" title="新建代码库"></a>新建代码库</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在当前目录新建一个Git代码库</span></span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个目录，将其初始化为Git代码库</span></span><br><span class="line">$ git init [project-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载一个项目和它的整个代码历史</span></span><br><span class="line">$ git <span class="built_in">clone</span> [url]</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示当前的Git配置</span></span><br><span class="line">$ git config --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑Git配置文件</span></span><br><span class="line">$ git config -e [--global]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置提交代码时的用户信息</span></span><br><span class="line">$ git config [--global] user.name <span class="string">&quot;[name]&quot;</span></span><br><span class="line">$ git config [--global] user.email <span class="string">&quot;[email address]&quot;</span></span><br></pre></td></tr></table></figure><h2 id="增加-删除文件"><a href="#增加-删除文件" class="headerlink" title="增加/删除文件"></a>增加/删除文件</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加指定文件到暂存区</span></span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加指定目录到暂存区，包括子目录</span></span><br><span class="line">$ git add [dir]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加当前目录的所有文件到暂存区</span></span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加每个变化前，都会要求确认</span></span><br><span class="line"><span class="comment"># 对于同一个文件的多处变化，可以实现分次提交</span></span><br><span class="line">$ git add -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class="line">$ git rm [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class="line">$ git rm --cached [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改名文件，并且将这个改名放入暂存区</span></span><br><span class="line">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 提交暂存区到仓库区</span></span><br><span class="line">$ git commit -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交暂存区的指定文件到仓库区</span></span><br><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交工作区自上次commit之后的变化，直接到仓库区</span></span><br><span class="line">$ git commit -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交时显示所有diff信息</span></span><br><span class="line">$ git commit -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用一次新的commit，替代上一次提交</span></span><br><span class="line"><span class="comment"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></span><br><span class="line">$ git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重做上一次commit，并包括指定文件的新变化</span></span><br><span class="line">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出所有本地分支</span></span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有远程分支</span></span><br><span class="line">$ git branch -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有本地分支和远程分支</span></span><br><span class="line">$ git branch -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，但依然停留在当前分支</span></span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，并切换到该分支</span></span><br><span class="line">$ git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，指向指定commit</span></span><br><span class="line">$ git branch [branch] [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，与指定的远程分支建立追踪关系</span></span><br><span class="line">$ git branch --track [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到指定分支，并更新工作区</span></span><br><span class="line">$ git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到上一个分支</span></span><br><span class="line">$ git checkout -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立追踪关系，在现有分支与指定的远程分支之间</span></span><br><span class="line">$ git branch --set-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并指定分支到当前分支</span></span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择一个commit，合并进当前分支</span></span><br><span class="line">$ git cherry-pick [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程分支</span></span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出所有tag</span></span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个tag在当前commit</span></span><br><span class="line">$ git tag [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个tag在指定commit</span></span><br><span class="line">$ git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除本地tag</span></span><br><span class="line">$ git tag -d [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程tag</span></span><br><span class="line">$ git push origin :refs/tags/[tagName]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看tag信息</span></span><br><span class="line">$ git show [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交指定tag</span></span><br><span class="line">$ git push [remote] [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交所有tag</span></span><br><span class="line">$ git push [remote] --tags</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，指向某个tag</span></span><br><span class="line">$ git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure><h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示有变更的文件</span></span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前分支的版本历史</span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示commit历史，以及每次commit发生变更的文件</span></span><br><span class="line">$ git <span class="built_in">log</span> --<span class="built_in">stat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索提交历史，根据关键词</span></span><br><span class="line">$ git <span class="built_in">log</span> -S [keyword]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个commit之后的所有变动，每个commit占据一行</span></span><br><span class="line">$ git <span class="built_in">log</span> [tag] HEAD --pretty=format:%s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span></span><br><span class="line">$ git <span class="built_in">log</span> [tag] HEAD --grep feature</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个文件的版本历史，包括文件改名</span></span><br><span class="line">$ git <span class="built_in">log</span> --follow [file]</span><br><span class="line">$ git whatchanged [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定文件相关的每一次diff</span></span><br><span class="line">$ git <span class="built_in">log</span> -p [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示过去5次提交</span></span><br><span class="line">$ git <span class="built_in">log</span> -5 --pretty --oneline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有提交过的用户，按提交次数排序</span></span><br><span class="line">$ git shortlog -sn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定文件是什么人在什么时间修改过</span></span><br><span class="line">$ git blame [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示暂存区和工作区的差异</span></span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示暂存区和上一个commit的差异</span></span><br><span class="line">$ git diff --cached [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示工作区与当前分支最新commit之间的差异</span></span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示两次提交之间的差异</span></span><br><span class="line">$ git diff [first-branch]...[second-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示今天你写了多少行代码</span></span><br><span class="line">$ git diff --shortstat <span class="string">&quot;@&#123;0 day ago&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交的元数据和内容变化</span></span><br><span class="line">$ git show [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交发生变化的文件</span></span><br><span class="line">$ git show --name-only [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交时，某个文件的内容</span></span><br><span class="line">$ git show [commit]:[filename]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前分支的最近几次提交</span></span><br><span class="line">$ git reflog</span><br></pre></td></tr></table></figure><h2 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载远程仓库的所有变动</span></span><br><span class="line">$ git fetch [remote]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有远程仓库</span></span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个远程仓库的信息</span></span><br><span class="line">$ git remote show [remote]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加一个新的远程仓库，并命名</span></span><br><span class="line">$ git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取回远程仓库的变化，并与本地分支合并</span></span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传本地指定分支到远程仓库</span></span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强行推送当前分支到远程仓库，即使有冲突</span></span><br><span class="line">$ git push [remote] --force</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送所有分支到远程仓库</span></span><br><span class="line">$ git push [remote] --all</span><br></pre></td></tr></table></figure><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 恢复暂存区的指定文件到工作区</span></span><br><span class="line">$ git checkout [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复某个commit的指定文件到暂存区和工作区</span></span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复暂存区的所有文件到工作区</span></span><br><span class="line">$ git checkout .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span></span><br><span class="line">$ git reset [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置暂存区与工作区，与上一次commit保持一致</span></span><br><span class="line">$ git reset --hard</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span></span><br><span class="line">$ git reset [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span></span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span></span><br><span class="line">$ git reset --keep [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个commit，用来撤销指定commit</span></span><br><span class="line"><span class="comment"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span></span><br><span class="line">$ git revert [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暂时将未提交的变化移除，稍后再移入</span></span><br><span class="line">$ git stash</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成一个可供发布的压缩包</span></span><br><span class="line">$ git archive</span><br></pre></td></tr></table></figure><h2 id="修改默认仓库账号密码"><a href="#修改默认仓库账号密码" class="headerlink" title="修改默认仓库账号密码"></a>修改默认仓库账号密码</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">控制面板-&gt;用户账户-&gt;凭据管理器-&gt;windows凭据</span><br><span class="line"></span><br><span class="line">删除对应的账号密码</span><br></pre></td></tr></table></figure><p>参考自阮一峰老师：<a href="https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html"> 常用 Git 命令清单 </a></p>]]></content>
      
      
      <categories>
          
          <category> Standard </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Standard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决仓库分支过多问题</title>
      <link href="/%E8%A7%A3%E5%86%B3%E4%BB%93%E5%BA%93%E5%88%86%E6%94%AF%E8%BF%87%E5%A4%9A%E9%97%AE%E9%A2%98/"/>
      <url>/%E8%A7%A3%E5%86%B3%E4%BB%93%E5%BA%93%E5%88%86%E6%94%AF%E8%BF%87%E5%A4%9A%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\02gaoke\00Practice&gt;git clone http://git.gaokeyun.cn/yangqiang/seu2021_doc.git</span><br><span class="line">Cloning into &#x27;seu2021_doc&#x27;...</span><br><span class="line">remote: Enumerating objects: 632, done.</span><br><span class="line">remote: Counting objects: 100% (632/632), done.</span><br><span class="line">remote: Compressing objects: 100% (596/596), done.</span><br><span class="line">error: RPC failed; curl 56 Recv failure: Connection was reset</span><br><span class="line">fetch-pack: unexpected disconnect while reading sideband packet</span><br><span class="line">fatal: early EOF</span><br><span class="line">fatal: fetch-pack: invalid index-pack output</span><br></pre></td></tr></table></figure><h1 id="原因分析："><a href="#原因分析：" class="headerlink" title="原因分析："></a>原因分析：</h1><pre><code>分支过多导致的问题</code></pre><h1 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h1><h2 id="关闭压缩功能"><a href="#关闭压缩功能" class="headerlink" title="关闭压缩功能"></a>关闭压缩功能</h2><pre><code>C:\02gaoke\00Practice&gt;git config --global core.compression 0</code></pre><h2 id="克隆最近修改的文件"><a href="#克隆最近修改的文件" class="headerlink" title="克隆最近修改的文件"></a>克隆最近修改的文件</h2><pre><code>C:\02gaoke\00Practice&gt;git clone --depth 1  http://git.gaokeyun.cn/yangqiang/seu2021_doc.gitCloning into &#39;seu2021_doc&#39;...remote: Enumerating objects: 3, done.remote: Counting objects: 100% (3/3), done.remote: Total 3 (delta 0), reused 0 (delta 0)Unpacking objects: 100% (3/3), 218 bytes | 19.00 KiB/s, done.</code></pre><h2 id="然后获取完整库"><a href="#然后获取完整库" class="headerlink" title="然后获取完整库"></a>然后获取完整库</h2><pre><code>C:\02gaoke\00Practice&gt;cd seu2021_docC:\02gaoke\00Practice\seu2021_doc&gt;git fetch --unshallowremote: Total 0 (delta 0), reused 0 (delta 0)</code></pre><h2 id="拉取所有数据"><a href="#拉取所有数据" class="headerlink" title="拉取所有数据"></a>拉取所有数据</h2><pre><code>C:\02gaoke\00Practice\seu2021_doc&gt;git pull --allFetching originAlready up to date.</code></pre><h2 id="本地创建分支"><a href="#本地创建分支" class="headerlink" title="本地创建分支"></a>本地创建分支</h2><pre><code>C:\02gaoke\00Practice\seu2021_doc&gt;git branch* masterC:\02gaoke\00Practice\seu2021_doc&gt;git branch yq2021</code></pre><h2 id="切换本地分支"><a href="#切换本地分支" class="headerlink" title="切换本地分支"></a>切换本地分支</h2><pre><code>C:\02gaoke\00Practice\seu2021_doc&gt;git checkout yq2021Switched to branch &#39;yq2021&#39;</code></pre><h2 id="添加到本地库"><a href="#添加到本地库" class="headerlink" title="添加到本地库"></a>添加到本地库</h2><pre><code>C:\02gaoke\00Practice\seu2021_doc&gt;git add *C:\02gaoke\00Practice\seu2021_doc&gt;git commit -m &quot;yq2021&quot;[yq2021 d5cd6e5] yq2021 1 file changed, 1 insertion(+) create mode 100644 &quot;\346\246\202\350\246\201\350\256\276\350\256\241/my.py&quot;</code></pre><h2 id="提交到服务器的分支"><a href="#提交到服务器的分支" class="headerlink" title="提交到服务器的分支"></a>提交到服务器的分支</h2><pre><code>C:\02gaoke\00Practice\seu2021_doc&gt;git push -u origin  yq2021Enumerating objects: 5, done.Counting objects: 100% (5/5), done.Delta compression using up to 12 threadsCompressing objects: 100% (2/2), done.Writing objects: 100% (4/4), 412 bytes | 206.00 KiB/s, done.Total 4 (delta 0), reused 0 (delta 0), pack-reused 0To http://git.gaokeyun.cn/yangqiang/seu2021_doc.git * [new branch]  yq2021 -&gt; yq2021Branch &#39;yq2021&#39; set up to track remote branch &#39;yq2021&#39; from &#39;origin&#39;.</code></pre>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Excel文件导入MySQL workbench</title>
      <link href="/excel%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5%E5%88%B0MySQL%20workbench/"/>
      <url>/excel%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5%E5%88%B0MySQL%20workbench/</url>
      
        <content type="html"><![CDATA[<h1 id="将Excel文件导入到MySQL-workbench中"><a href="#将Excel文件导入到MySQL-workbench中" class="headerlink" title="将Excel文件导入到MySQL workbench中"></a>将Excel文件导入到MySQL workbench中</h1><h2 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h2><p><strong>MySQL workbench版本</strong> <span class='p inline-tag t-red'>8.0</span></p><h2 id="将excel文件另存为到桌面，保存类型选择CSV-逗号分隔"><a href="#将excel文件另存为到桌面，保存类型选择CSV-逗号分隔" class="headerlink" title="将excel文件另存为到桌面，保存类型选择CSV(逗号分隔)"></a>将excel文件另存为到桌面，保存类型选择CSV(逗号分隔)</h2><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/20190927130701829.png" alt="img"></p><p><strong>保存完桌面上文件显示为这样的，然后右键打开方式，选择记事本打开</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/20190927131220596.png"></p><h2 id="记事本显示的数据都有逗号隔开，再另存为，编码选择UTF-8，保存"><a href="#记事本显示的数据都有逗号隔开，再另存为，编码选择UTF-8，保存" class="headerlink" title="记事本显示的数据都有逗号隔开，再另存为，编码选择UTF-8，保存"></a>记事本显示的数据都有逗号隔开，再另存为，编码选择UTF-8，保存</h2><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/20190927131327894.png" alt="在这里插入图片描述"></p><h2 id="打开workbench右键点击数据库中的Tables，点击Table-Data-Import-Wizard"><a href="#打开workbench右键点击数据库中的Tables，点击Table-Data-Import-Wizard" class="headerlink" title="打开workbench右键点击数据库中的Tables，点击Table Data Import Wizard"></a>打开<code>workbench</code>右键点击数据库中的<code>Tables</code>，点击<code>Table Data Import Wizard</code></h2><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/20190927131745455.png" alt="在这里插入图片描述"></p><h2 id="选择桌面上文件的路径"><a href="#选择桌面上文件的路径" class="headerlink" title="选择桌面上文件的路径"></a>选择桌面上文件的路径</h2><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/20190927131848643.png" alt="在这里插入图片描述"></p><h2 id="这里可以将数据导入到已有的数据表中，也可以直接新建表"><a href="#这里可以将数据导入到已有的数据表中，也可以直接新建表" class="headerlink" title="这里可以将数据导入到已有的数据表中，也可以直接新建表"></a>这里可以将数据导入到已有的数据表中，也可以直接新建表</h2><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/20190927131925452.png" alt="在这里插入图片描述"></p><h2 id="一直点下一步，最后完成导入"><a href="#一直点下一步，最后完成导入" class="headerlink" title="一直点下一步，最后完成导入"></a>一直点下一步，最后完成导入</h2><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/20190927131941795.png" alt="在这里插入图片描述"></p><h2 id="最后刷新下数据库表单，Tables中就可以看到导入的数据库表"><a href="#最后刷新下数据库表单，Tables中就可以看到导入的数据库表" class="headerlink" title="最后刷新下数据库表单，Tables中就可以看到导入的数据库表"></a>最后刷新下数据库表单，Tables中就可以看到导入的数据库表</h2><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU3MzE4Ng==,size_16,color_FFFFFF,t_70.png"></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Butterfly主题美化</title>
      <link href="/Hexo+Butterfly%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/"/>
      <url>/Hexo+Butterfly%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo-Butterfly-主题美化"><a href="#Hexo-Butterfly-主题美化" class="headerlink" title="Hexo+Butterfly 主题美化"></a>Hexo+Butterfly 主题美化</h1><h2 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h2><p><strong>Butterfly 已经更新到<span class='p inline-tag t-blue'>3.8.4</span>， 目前采用版本为<span class='p inline-tag t-red'>3.8.3</span></strong></p><h3 id="侧边栏电子时钟"><a href="#侧边栏电子时钟" class="headerlink" title="侧边栏电子时钟"></a>侧边栏电子时钟</h3><h4 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖:"></a>安装依赖:</h4><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install hexo<span class="literal">-butterfly</span><span class="literal">-clock</span> -<span class="literal">-save</span> </span><br></pre></td></tr></table></figure><h4 id="在-config-yml中配置插件"><a href="#在-config-yml中配置插件" class="headerlink" title="在_config.yml中配置插件:"></a>在<code>_config.yml</code>中配置插件:</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># electric_clock</span></span><br><span class="line"><span class="attr">electric_clock:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 开关</span></span><br><span class="line">  <span class="attr">priority:</span> <span class="number">5</span> <span class="comment">#过滤器优先权</span></span><br><span class="line">  <span class="attr">enable_page:</span> <span class="string">all</span> <span class="comment"># 应用页面</span></span><br><span class="line">  <span class="attr">exclude:</span></span><br><span class="line">    <span class="comment"># - /posts/</span></span><br><span class="line">    <span class="comment"># - /about/</span></span><br><span class="line">  <span class="attr">layout:</span> <span class="comment"># 挂载容器类型</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">class</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">sticky_layout</span></span><br><span class="line">    <span class="attr">index:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">loading:</span> <span class="string">https://cdn.jsdelivr.net/gh/tzy13755126023/BLOG_SOURCE/theme_f/loading.gif</span> <span class="comment">#加载动画自定义 </span></span><br></pre></td></tr></table></figure><p><strong>效果如下：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20210914220124949.png" alt="image-20210914220124949"></p><h3 id="随机背景图"><a href="#随机背景图" class="headerlink" title="随机背景图"></a>随机背景图</h3><div class="note warning"><p>此处需要对源码进行修改，慎重考虑。</p></div><h4 id="授人以渔"><a href="#授人以渔" class="headerlink" title="授人以渔"></a>授人以渔</h4><p>此处参考了<strong>会飞的小弋</strong>的教程，不过他的butterfly版本较低，现今源码已改变，故这里进行梳理。</p><p>通过网页的<code>search</code>功能基本就能锁定到背景页面的css，显然页面是用的<code>id</code>选择器，且<code>id</code>为<code>web_bg</code>，元素为<code>background</code></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#web_bg</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">999</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&quot;/img/banner/6.jpg&quot;</span>);</span><br><span class="line">  <span class="attribute">background-attachment</span>: local;</span><br><span class="line">  <span class="attribute">background-position</span>: center;</span><br><span class="line">  -webkit-<span class="attribute">background-size</span>: cover;</span><br><span class="line">  -moz-<span class="attribute">background-size</span>: cover;</span><br><span class="line">  <span class="attribute">background-size</span>: cover;</span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过用<code>js</code>的<code>document.getElementById(&#39;web_bg&#39;)</code>发现并不能取到想要的值，是因为此处不是采用的<strong>行内式</strong>，不过既然知道了<code>web_bg</code>参数，就可以进行全局搜索</p><h4 id="修改源码"><a href="#修改源码" class="headerlink" title="修改源码"></a>修改源码</h4><p>在 <code>butterfly/layout/includes/layout.pug</code> 下找到如下代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">footer#footer(style=footer_bg)</span><br><span class="line">    !=partial(&#x27;includes/footer&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br></pre></td></tr></table></figure><p>在其下追加变成，<strong>注意缩进</strong>，<code>script()</code>与上面的<code>!=</code>对齐</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">footer#footer(style=footer_bg)</span><br><span class="line">    !=partial(&#x27;includes/footer&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">if !is_post()</span><br><span class="line">    script() var bg_index = Math.floor(Math.random() * #&#123;theme.background_num&#125;);var res = &#x27;background-image: url(&quot;/img/banner/&#x27; + bg_index + &#x27;.jpg&quot;); background-attachment: fixed;&#x27;;document.getElementById(&#x27;web_bg&#x27;).style = res</span><br></pre></td></tr></table></figure><p>这里的<code>if !is_post()</code>表示文章页面不采用随机背景，如果需要随机则可以把这句话删去。文章背景色是采用主题设置中的<code>background</code>值</p><h4 id="添加图片"><a href="#添加图片" class="headerlink" title="添加图片"></a>添加图片</h4><p>在<code>\source\img</code>目录下新建<code>banner</code>文件夹，然后就可以把图片按照<code>0.jpg</code>、<code>1.jpg</code>、<code>2.jpg</code>这个顺序放入，同时在 <code>butterfly/_config.yml</code> 里添加以下内容</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 随机背景图banner的数量</span></span><br><span class="line"><span class="attr">background_num:</span> <span class="number">8</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
          <category> 美化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 界面美化 </tag>
            
            <tag> Hexo </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo配置加强版live2d看板娘</title>
      <link href="/Hexo%E9%85%8D%E7%BD%AE%E5%8A%A0%E5%BC%BA%E7%89%88live2d%E7%9C%8B%E6%9D%BF%E5%A8%98/"/>
      <url>/Hexo%E9%85%8D%E7%BD%AE%E5%8A%A0%E5%BC%BA%E7%89%88live2d%E7%9C%8B%E6%9D%BF%E5%A8%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo配置加强版live2d看板娘"><a href="#Hexo配置加强版live2d看板娘" class="headerlink" title="Hexo配置加强版live2d看板娘"></a>Hexo配置加强版live2d看板娘</h1><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p><strong>如果已经安装过官方提供的live2d，需要先卸载！</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-helper-live2d</span><br></pre></td></tr></table></figure><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><strong>项目下载地址：<a href="https://github.com/stevenjoezhang/live2d-widget">https://github.com/stevenjoezhang/live2d-widget</a></strong></p><p><strong>下载解压到：<code>themes\butterfly\source\</code>文件夹下</strong></p><h2 id="设置路径"><a href="#设置路径" class="headerlink" title="设置路径"></a>设置路径</h2><p><strong>打开项目目录进入修改autoload.js文件，将live2d_path设为自己的路径，一般为绝对路径：</strong><code>/live2d-widget/</code></p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20210826171753095.png" alt="image-20210826171753095"></p><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p><strong>打开butterfly下的layout下的includes目录，点击修改head.pug文件，在文件末尾粘贴：</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">script(src=<span class="string">&#x27;/live2d-widget/autoload.js&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="开启"><a href="#开启" class="headerlink" title="开启"></a>开启</h2><p><strong>在主题配置文件下即butterfly下的_config.yml中添加以下代码：</strong></p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 看板娘* </span></span><br><span class="line"><span class="attr">live2d:</span>  </span><br><span class="line"><span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>运行项目就可以在左下角看到一个可换装、可聊天的动态加强版看板娘啦。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20210826170620016.png" alt="image-20210826170620016"></p><h2 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h2><h3 id="修改看板娘的位置"><a href="#修改看板娘的位置" class="headerlink" title="修改看板娘的位置"></a><strong>修改看板娘的位置</strong></h3><p><strong>在<code>live2d-widget</code>目录下的<code>waifu.css</code>中的<code>#waifu</code>选择器下修改：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20210826170948905.png" alt="image-20210826170948905"></p><h3 id="修改聊天内容"><a href="#修改聊天内容" class="headerlink" title="修改聊天内容"></a><strong>修改聊天内容</strong></h3><p><strong>在<code>live2d-widget</code>文件夹下的<code>waifu-tips.js</code>文件中</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20210826171338176.png" alt="image-20210826171338176"></p><h3 id="修改首次加载的模型"><a href="#修改首次加载的模型" class="headerlink" title="修改首次加载的模型"></a><strong>修改首次加载的模型</strong></h3><p><strong>如果你不喜欢默认的第一个模型，可以指定首次加载的模型。修改<code>modelId</code></strong><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20210826171517898.png" alt="image-20210826171517898"></p><h2 id="bug归纳"><a href="#bug归纳" class="headerlink" title="bug归纳"></a>bug归纳</h2><div class="note warning"><p>使用张书樵大神的魔改方案时，<code>Pio酱</code>和<code>Tia酱</code>的模型不能像在其他网站看到的那样可以换装。</p></div><p>这里主要是因为张书樵大神的魔改方案使用的CDN路径是通过接入的<a href="https://github.com/fghrsh/live2d_api">live2d_api仓库</a>的<code>jedelivrCDN</code>链接，根据该项目的<code>model_list.json</code>和指向的<code>model</code>文件夹内的模型的<code>index.json</code>来确定模型资源。而<code>Pio酱</code>和<code>Tia酱</code>的模型装配是配合有后端服务器的API装配方式，依赖于后端生成的<code>textures.cache</code>来获取模型资源。解决方案是将模型装配模式由<code>单模型 多组皮肤</code>转换为<code>同分组 多个模型</code>。</p><details green><summary> 解决方法 </summary>              <div class='content'>              <div class="tabs" id="tab-id"><ul class="nav-tabs"><li class="tab active"><a class="#tab-id-1">懒人配置方案</a></li><li class="tab"><a class="#tab-id-2">更改模型配置方案</a></li><li class="tab"><a class="#tab-id-3">鸣谢</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tab-id-1"><p>修改张书樵大神的项目内的<code>~\live2d-widget\autoload.js</code>,将模型资源由<code>cdnPath</code>改为<code>apiPath</code>。</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">  // 加载 waifu.css live2d.min.js waifu-tips.js</span><br><span class="line">  if (screen.width &gt;= 768) &#123;</span><br><span class="line">  Promise.all([</span><br><span class="line">  loadExternalResource(live2d_path + &quot;waifu.css&quot;, &quot;css&quot;),</span><br><span class="line">  loadExternalResource(live2d_path + &quot;live2d.min.js&quot;, &quot;js&quot;),</span><br><span class="line">  loadExternalResource(live2d_path + &quot;waifu-tips.js&quot;, &quot;js&quot;)</span><br><span class="line">  ]).then(() =&gt; &#123;</span><br><span class="line">  initWidget(&#123;</span><br><span class="line">  waifuPath: live2d_path + &quot;waifu-tips.json&quot;,</span><br><span class="line"><span class="deletion">- //apiPath: &quot;https://live2d.fghrsh.net/api/&quot;,</span></span><br><span class="line"><span class="deletion">-  cdnPath: &quot;https://cdn.jsdelivr.net/gh/fghrsh/live2d_api/&quot;</span></span><br><span class="line"><span class="addition">+ apiPath: &quot;https://live2d.fghrsh.net/api/&quot;,</span></span><br><span class="line"><span class="addition">+  //cdnPath: &quot;https://cdn.jsdelivr.net/gh/fghrsh/live2d_api/&quot;</span></span><br><span class="line">  &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><div class="note warning"><p>这个apiPath就是live2d_widget的原作者<a href="https://www.fghrsh.net/post/123.html">@fghrsh</a>搭建的。但是这个API纯粹是用爱发电的产物，随时可能到期，虽然已经喊了三年了。。。详见<a href="https://www.fghrsh.net/post/170.html">Live2D 看板娘 API 迁移公告</a>，所以最好还是采用<a href="https://github.com/fghrsh/live2d_api">自建api</a>的方式。</p></div></div><div class="tab-pane" id="tab-id-2"><p>上面已经说到过，张书樵大神的魔改方案其实已经实现了<code>本地化API</code>，只是因为模型配置路径不同才导致无法换装的。所以其实只要注意配置模型时，保证每个可以展示的模型都有相应的<code>index.json</code>并且在<code>model_list.json</code>里有相应的模型路径就可以了。</p><p>直接使用配置好的本地化项目的路径：<br>       修改张书樵大神的项目内的<code>~\live2d-widget\autoload.js</code>,修改<code>cdnPath</code>。</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">  // 加载 waifu.css live2d.min.js waifu-tips.js</span><br><span class="line">  if (screen.width &gt;= 768) &#123;</span><br><span class="line">  Promise.all([</span><br><span class="line">  loadExternalResource(live2d_path + &quot;waifu.css&quot;, &quot;css&quot;),</span><br><span class="line">  loadExternalResource(live2d_path + &quot;live2d.min.js&quot;, &quot;js&quot;),</span><br><span class="line">  loadExternalResource(live2d_path + &quot;waifu-tips.js&quot;, &quot;js&quot;)</span><br><span class="line">  ]).then(() =&gt; &#123;</span><br><span class="line">  initWidget(&#123;</span><br><span class="line">  waifuPath: live2d_path + &quot;waifu-tips.json&quot;,</span><br><span class="line">  //apiPath: &quot;https://live2d.fghrsh.net/api/&quot;,</span><br><span class="line"><span class="deletion">-  cdnPath: &quot;https://cdn.jsdelivr.net/gh/fghrsh/live2d_api/&quot;</span></span><br><span class="line"><span class="addition">+  cdnPath: &quot;https://live2d-api.vercel.app/&quot;</span></span><br><span class="line">//因为jsdelivr不支持50MB以上的包的加速，可能报403错误，所以用的vercel的CDN服务。</span><br><span class="line">  &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>除了让原有模型换装可用化以为，还顺便添加了<code>和泉纱雾</code>，<code>血小板</code>和<code>香风智乃</code>的模型哦。</p></div><div class="tab-pane" id="tab-id-3"><div class="tag link"><a class="link-card" title="糖果屋教程贴" href="https://akilar.top/posts/615e2dec/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/Akilarlxh/akilarlxh.github.io/img/siteicon/favicon.ico"/></div><div class="right"><p class="text">糖果屋教程贴</p><p class="url">https://akilar.top/posts/615e2dec/</p></div></a></div></div></div></div>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
          <category> 美化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 界面美化 </tag>
            
            <tag> Hexo </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora入门</title>
      <link href="/Typora%E5%85%A5%E9%97%A8/"/>
      <url>/Typora%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Typora入门"><a href="#Typora入门" class="headerlink" title="Typora入门"></a>Typora入门</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Typora是一款轻便简洁的Markdown编辑器，支持即时渲染技术，这也是与其他Markdown编辑器最显著的区别。即时渲染使得你写Markdown就想是写Word文档一样流畅自如，不像其他编辑器的有编辑栏和显示栏。</p><ul><li>Typora删除了预览窗口，以及所有其他不必要的干扰。取而代之的是实时预览。</li><li>Markdown的语法因不同的解析器或编辑器而异，Typora使用的是<a href="https://help.github.com/articles/basic-writing-and-formatting-syntax/">GitHub Flavored Markdown</a>。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20210819175048608.png" alt="image-20210819175048608"></p><center style="color:#C0C0C0">官网首页</center><h2 id="关于-Markdown"><a href="#关于-Markdown" class="headerlink" title="关于 Markdown"></a>关于 Markdown</h2><p>Markdown 是用来编写结构化文档的一种纯文本格式，它使我们在双手不离开键盘的情况下，可以对文本进行一定程度的格式排版。你可以在 <a href="https://sspai.com/post/36610">这篇文章</a> 中快速入门 Markdown。</p><p>由于目前还没有一个权威机构对 Markdown 的语法进行规范，各应用厂商制作时遵循的 Markdown 语法也是不尽相同的。其中比较受到认可的是 <a href="https://github.github.com/gfm/">GFM 标准</a>，它是由著名代码托管网站 <a href="https://github.com/">GitHub</a> 所制定的。Typora 主要使用的也是 GFM 标准。同时，你还可以在 <code>文件 - 偏好设置 - Markdown 语法偏好 - 严格模式</code> 中将标准设置为「更严格地遵循 GFM 标准」。具体内容你可以在官方的 <a href="http://support.typora.io/Strict-Mode/">这篇文档</a> 中查看。</p><h3 id="语法偏好"><a href="#语法偏好" class="headerlink" title="语法偏好"></a>语法偏好</h3><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20210819151516826.png" alt="image-20210819151516826"></p><center style="color:#C0C0C0">严格模式</center><h3 id="智能标点"><a href="#智能标点" class="headerlink" title="智能标点"></a>智能标点</h3><p>我认为「智能标点」是比较有趣的一点。它可以自动帮你将不是很美观的直引号 <code>&quot;</code> <code>&#39;</code> 转化为更美观的弯引号 <code>“</code> <code>‘</code> <code>’</code> <code>”</code>。具体内容你可以在官方的 <a href="http://support.typora.io/SmartyPants/">这篇文档</a> 中查看。关于直弯引号在 macOS 上如何输入你也可以看 <a href="https://sspai.com/post/38342">这篇文章</a>。</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20210819151704847.png" alt="image-20210819151704847"></p><center style="color:#C0C0C0">智能标点</center><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20210819173300202.png" alt="image-20210819173300202"></p><center style="color:#C0C0C0">代码块</center><p>Typora 中代码的插入也可以分为行内和块间两种：</p><ol><li>行内代码：用 <code>...</code> 或 <code>...</code> 括起代码，代码会以主题中设置的样式出现在行内，但不会实现代码高亮。</li><li>代码块：输入 ````` 后并输入语言名，换行，开始写代码，Typora 就会自动帮你实现代码高亮。Typora 原生支持许多编程语言代码块的语法高亮，基本日常常用的编程语言它都能很好地支持。<br>除此以外，你也可以直接换行开始写，而后再选择语言。</li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;折线图&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 100%; height: 500px;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="空格与换行"><a href="#空格与换行" class="headerlink" title="空格与换行"></a>空格与换行</h3><p>Typora 在空格与换行部分主要是使用 <a href="http://www.commonmark.cn/w/">CommonMark</a> 作为标注规范。与前文提到的 GFM 一样，CommonMark 也是比较流行的 Markdown 语言规范（解析器）之一。</p><ul><li><p><strong>空格：</strong>在输入连续的空格后，Typora 会在编辑器视图里为你保留这些空格，但当你打印或导出时，这些空格会被省略成一个。<br>你可以在源代码模式下，为每个空格前加一个 <code>\</code> 转义符，或者直接使用 HTML 风格的 <code>&amp;nbps;</code> 来保持连续的空格。</p></li><li><p><strong>软换行：</strong>需要说明的是，在 Markdown 语法中，换行（line break）与换段是不同的。且换行分为软换行和硬换行。在 Typora 中，你可以通过 <code>Shift + Enter</code> 完成一次软换行。软换行只在编辑界面可见，当文档被导出时换行会被省略。</p></li><li><p><strong>硬换行：</strong>你可以通过 <code>空格 + 空格 + Shift + Enter</code> 完成一次硬换行，而这也是许多 Markdown 编辑器所原生支持的。硬换行在文档被导出时将被保留，且没有换段的段后距。</p></li><li><p><strong>换段：</strong>你可以通过 <code>Enter</code> 完成一次换段。Typora 会自动帮你完成两次 <code>Shift + Enter</code> 的软换行，从而完成一次换段。这也意味着在 Markdown 语法下，换段是通过在段与段之间加入空行来实现的。</p></li><li><p><strong>Windows 风格（CR+LF）与 Unix 风格（CR）的换行符：</strong>CR 表示回车 <code>\r</code> ，即回到一行的开头，而 LF 表示换行 <code>\n</code> ，即另起一行。<br>所以 Windows 风格的换行符本质是「回车 + 换行」，而 Unix 风格的换行符是「换行」。这也是为什么 Unix / Mac 系统下的文件，如果在 Windows 系统直接打开会全部在同一行内。 你可以在 <code>文件 - 偏好设置 - 编辑器 - 默认换行符</code> 中对此进行切换。</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20210819174430348.png" alt="image-20210819174430348"></p></li></ul><center style="color:#C0C0C0">空格与换行</center><p>下附以上各空格、换行、换段的测试结果图。具体内容你可以在官网的 <a href="http://support.typora.io/Line-Break/">这篇文档</a> 中查阅。</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/5c2fbaa53b27666a7fd0b07ac3e100bf.png" alt="img"></p><h2 id="Typora操作"><a href="#Typora操作" class="headerlink" title="Typora操作"></a>Typora操作</h2><h3 id="Typora快捷键"><a href="#Typora快捷键" class="headerlink" title="Typora快捷键"></a>Typora快捷键</h3><ul><li>加粗： <code>Ctrl + B</code></li><li>标题： <code>Ctrl + H</code></li><li>插入链接： <code>Ctrl + K</code></li><li>插入代码： <code>Ctrl + Shift + C</code>  – 无法执行</li><li>行内代码： <code>Ctrl + Shift + K</code></li><li>插入图片： <code>Ctrl + Shift + I</code></li><li>无序列表：<code>Ctrl + Shift + L</code> – 无法执行</li><li>撤销： <code>Ctrl + Z</code></li></ul><table><thead><tr><th align="left">快捷键</th><th align="left">作用</th><th align="left">快捷键</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">Ctrl+1</td><td align="left">一阶标题</td><td align="left">Ctrl+B</td><td align="left">字体加粗</td></tr><tr><td align="left">Ctrl+2</td><td align="left">二阶标题</td><td align="left">Ctrl+I</td><td align="left">字体倾斜</td></tr><tr><td align="left">Ctrl+3</td><td align="left">三阶标题</td><td align="left">Ctrl+U</td><td align="left">下划线</td></tr><tr><td align="left">Ctrl+4</td><td align="left">四阶标题</td><td align="left">Ctrl+Home</td><td align="left">返回Typora顶部</td></tr><tr><td align="left">Ctrl+5</td><td align="left">五阶标题</td><td align="left">Ctrl+End</td><td align="left">返回Typora底部</td></tr><tr><td align="left">Ctrl+6</td><td align="left">六阶标题</td><td align="left">Ctrl+T</td><td align="left">创建表格</td></tr><tr><td align="left">Ctrl+L</td><td align="left">选中某句话</td><td align="left">Ctrl+K</td><td align="left">创建超链接</td></tr><tr><td align="left">Ctrl+D</td><td align="left">选中某个单词</td><td align="left">Ctrl+F</td><td align="left">搜索</td></tr><tr><td align="left">Ctrl+E</td><td align="left">选中相同格式的文字</td><td align="left">Ctrl+H</td><td align="left">搜索并替换</td></tr><tr><td align="left">Alt+Shift+5</td><td align="left">删除线</td><td align="left">Ctrl+Shift+I</td><td align="left">插入图片</td></tr></tbody></table><p>注：一些实体符号在使用之后要加空格，还有一些实体符号需要在实体符号之前加”\”才能够显示。</p><h3 id="图片插入"><a href="#图片插入" class="headerlink" title="图片插入"></a>图片插入</h3><p>Typora 的图片插入功能是广受好评的。要知道，Markdown 原生不太注重图片插入的功能，但你可以在 Typora 中：</p><ul><li>直接使用 <code>右键 - 复制 Ctrl + V</code> 将网络图片、剪贴板图片复制到文档中</li><li>拖动本地图片到文档中</li></ul><p>Typora 会自动帮你插入符合 Markdown 语法的图片语句，并给它加上标题。</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20210819195033429.png" alt="image-20210819195033429"></p><center style="color:#C0C0C0">复制图片</center><p>你也完全可以使用图床来保证文档在分享后图片仍能正常显示。</p><p>更强大的是，Typora 支持在拖动或 <code>Ctrl + V</code> 网络图片后自动将其保存到本地。你可以在 <code>文件 - 偏好设置 - 编辑器 - 图片插入</code> 中选择复制到哪个路径，什么情况下需要复制。</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20210819194937889.png" alt="image-20210819194937889"></p><center style="color:#C0C0C0">图片插入</center><p>这一功能保证了即使网络图片源失效了，你还有本地的备份可用。同时也能使你的文档文件夹更合理、完整。</p><h3 id="打字机模式和专注模式"><a href="#打字机模式和专注模式" class="headerlink" title="打字机模式和专注模式"></a>打字机模式和专注模式</h3><p><strong>「打字机模式」</strong>使得你所编辑的那一行永远处于屏幕正中。</p><p><strong>「专注模式」</strong>使你正在编辑的那一行保留颜色，而其他行的字体呈灰色。</p><p>你可以在 <code>视图 - 专注模式 / 打字机模式</code> 中勾选使用这两个模式。</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/8b4e14ef732a23d4cc2a8fb1f8ec016c.gif" alt="img"></p><center style="color:#C0C0C0">两种模式</center><h3 id="实时预览"><a href="#实时预览" class="headerlink" title="实时预览"></a>实时预览</h3><p>我想很果断地下这个结论：到现在还不支持编辑界面实时预览的 Markdown 编辑器基本可以退出市场了。Typora 在这一方面显然已经领先了一大步——他们连 Markdown 语法的标记都在实时预览中消去了。当你离开正在编辑的有格式的文本段后，Typora 会自动隐藏 Markdown 标记，只留下<strong>「所见即所得」</strong>的美妙。<em>他们把这称为 Hybrid View。</em></p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/f99c9ce02e2728ec6c64b443947fc67e.gif" alt="img"></p><center style="color:#C0C0C0">所见即所得</center><p>为了防止一些程序 bug 的发生（虽然在我使用下来感到是很少的）导致格式问题无法修改，Typora 保留了一个<strong>「源代码模式」</strong>。你可以通过 <code>视图 - 源代码模式</code> 或左下角的 <code>&lt;/&gt;</code> 按钮进入。</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/bcda9c4e35725b7297a6b90d8745564e.gif" alt="img"></p><center style="color:#C0C0C0">源代码模式</center><h3 id="大纲-文件侧边栏"><a href="#大纲-文件侧边栏" class="headerlink" title="大纲 / 文件侧边栏"></a>大纲 / 文件侧边栏</h3><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20210819200541814.png" alt="image-20210819200541814"></p><center style="color:#C0C0C0">侧边栏-大纲</center><p>Typora 会根据你 Markdown 标记的 H1、H2、H3…… 各级标题为你呈现一个大纲。</p><p>你也可以选择查看文件夹中的文件，但由于目前 Typora 只支持查看 md 文件，图片文件会显示乱码。</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20210819200711298.png" alt="image-20210819200711298"></p><center style="color:#C0C0C0">侧边栏-文件</center><h3 id="emoji-表情"><a href="#emoji-表情" class="headerlink" title="emoji 表情"></a>emoji 表情</h3><p>如今 emoji 表情越来越多地出现在一些网站文章中，但在桌面端（特别是 Windows 系统）文本编辑器上插入 emoji 是一件十分麻烦的事情。在使用 Typora 之前，我打出 emoji 表情的办法基本有两个：</p><ol><li><strong>输入法联想：</strong>优点是比较方便，但会插入一张图片而不是一个字符，在许多情景下都不是很合适。 </li><li><strong>复制 emoji 符号：</strong>优点是能保证符号的形式，但显然每次用都需要去复制，比较麻烦。</li></ol><p>在 Typora 中，你可以用 <code>:emoji:</code> 的形式来打出 emoji，软件会自动给出图形的提示，还是比较好用的。</p><p>:sunglasses:</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20210819201306641.png" alt="image-20210819201306641"></p><center style="color:#C0C0C0">Typora 中输入 emoji</center><h3 id="目录（TOC）"><a href="#目录（TOC）" class="headerlink" title="目录（TOC）"></a>目录（TOC）</h3><p>输入 <code>[ toc ]</code> 然后回车，即可创建一个“目录”。TOC从文档中提取所有标题，其内容将自动更新。</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20210819204451866.png" alt="image-20210819204451866"></p><center style="color:#C0C0C0">目录</center><h2 id="一个学术文档编辑器"><a href="#一个学术文档编辑器" class="headerlink" title="一个学术文档编辑器"></a>一个学术文档编辑器</h2><p>除了基本的文本编辑体验极佳之外，Typora 还是一个非常优秀的学术文档编辑器。当然作为一个轻量级的、基于 Markdown 的编辑器，它不能与那些 LaTeX 编辑器相提并论，但它仍支持了许多可用于学术写作的功能。</p><h3 id="LaTeX"><a href="#LaTeX" class="headerlink" title="LaTeX"></a>LaTeX</h3><blockquote><p>LaTeX 是一种基于 TeX 的排版系统，由于它易于快速生成复杂表格和数学公式，非常适用于生成高印刷质量的科技和数学类文档。如果你常阅读数学、计算机等领域的学术论文，你一定对 LaTeX 不陌生。</p></blockquote><p>Typora 原生支持 LaTeX 语法，你有两种方式输入 LaTeX 风格的数学公式：</p><ol><li><strong>行内公式（inline）：</strong>用 <code>$...$</code> 括起公式，公式会出现在行内。</li><li><strong>块间公式（display）：</strong>用 <code>$$...$$</code> 括起公式（注意 <code>$$</code> 后需要换行），公式会默认显示在行中间。</li></ol><p>具体的 LaTeX 语法在此不赘述了，你可以在 <a href="https://blog.csdn.net/happyday_d/article/details/83715440">这篇文章</a> 中查看。</p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>在 Markdown 中插入表格一直是一件比较头疼的事情。在一般的 Markdown 编辑器中，你可以通过以下的格式插入表格：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :-----| ----: | :----: |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br></pre></td></tr></table></figure><p>好在 Typora 为我们提供了图形界面的插入表格的功能，你只需要在行内 <code>鼠标右键 - 插入 - 表格</code> ，并输入行数和列数，Typora 就会自动生成一张样式不错的空表格。</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/1-162935603852713" alt="img"></p><center style="color:#C0C0C0">Typora 表格</center><h3 id="链接引用与脚注"><a href="#链接引用与脚注" class="headerlink" title="链接引用与脚注"></a>链接引用与脚注</h3><p><strong>链接引用</strong>类似于我们常在论文末尾看到的「参考文献」的写法，你可以通过 <code>[]:</code> 的语法来为你的文档加上链接引用。</p><p><strong>脚注</strong>在少数派的文章中也很常见，即某段话结尾右上角标有数字标记，页面底部进行注释的写法。你可以在需要插入脚注标号的位置写 <code>[^ number ]</code> ，再在下方通过 <code>[^ number ]:</code> 在文档中插入脚注。注意不要遗漏了脚注编号 <code>number</code> 前后的空格。</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20210819203639787.png" alt="image-20210819203639787"></p><center style="color:#C0C0C0">链接引用和脚注</center><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>除了前文提到的文件侧边栏，Typora 还提供了一些耦合度不高的文件系统。</p><ul><li><strong>快速打开：</strong>你可以通过 <code>文件 - 快速打开...</code> 或 <code>Ctrl + P</code> 快捷键快速打开最近的文档。</li><li><strong>保存：</strong>Typora 支持自动保存，一般很少有写好的文档丢失的情况。同时它也提供了诸如「保存」、「另存为」、「保存全部打开的文件…」之类的功能。</li><li><strong>导入：</strong>Typora 支持非常多的文件格式：.docx, .latex, .tex, .ltx, .rst, .rest, .org, .wiki, .dokuwiki, .textile, .opml, .epub。</li><li><strong>导出：</strong>Typora 原生支持导出 PDF，HTML等格式。你可以根据软件内提示安装 <strong>Pandoc 插件</strong>来导出更多例如 docx，LaTeX 等格式。 </li></ul><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20210819203219763.png" alt="image-20210819203219763"></p><center style="color:#C0C0C0">导出</center><h2 id="一个伪装成文本编辑器的浏览器"><a href="#一个伪装成文本编辑器的浏览器" class="headerlink" title="一个伪装成文本编辑器的浏览器"></a>一个伪装成文本编辑器的浏览器</h2><p>在图片插入的选项中，Typora 用了「复制图片到 ./${filename}.assets 文件夹」的说法，而这其实是网页前端常用的 Javascript 字符串模板语法的风格。</p><p>再比如，Typora 将更遵循 GFM 标准的 Markdown 语法模式称为「严格模式 Strict Mode」，这一说法常见于 HTML 和 JavaScript 编程中。类似「源代码模式」的说法也是同理。</p><p>当然，最明显的一点是当你按下 <code>Shift + F12</code> 快捷键时，页面会弹出一个基于 Chrome 的开发者工具栏，也就是我们在浏览器中常说的「审查元素」。</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20210819202953842.png" alt="image-20210819202953842"></p><center style="color:#C0C0C0">审查元素</center><h3 id="伪装从何而来？"><a href="#伪装从何而来？" class="headerlink" title="伪装从何而来？"></a>伪装从何而来？</h3><p>当我们把视角放在「Typora 是一个支持 Markdown 语言的文本编辑器」的出发点来考虑这个问题，一切就都显得很明白了。</p><p>John Gruber 在 2004 年用 Perl 创造了 Markdown 语言，这个语言的目的是希望大家使用「易于阅读、易于撰写的纯文字格式，并选择性的转换成有效的 XHTML（或是 HTML）」。也就是说，<strong>在 Markdown 诞生之初，它就是为了被浏览器阅读而设计的。</strong></p><p>我们在用 Markdown 语言撰写文稿的时候，其实本质上是在借助某种编程语言的转化（解析器）来编写一个 HTML 网页。Markdown 从它诞生之初就与 Web 技术有着及其紧密的联系。</p><p>Typora 利用解析器先将我们写的 Markdown 文档解析成为 HTML 文档，再为它嵌入一个 CSS 样式，最后再加上可能需要的脚本等。</p><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p>HTML 是一种标记语言，主要负责构成网页的骨架，它包含所有不加装饰的网页元素。在 Typora 的使用场景下则是所有的<strong>文本、段落、标题等</strong>的记号。</p><h4 id="HTML-标签"><a href="#HTML-标签" class="headerlink" title="HTML 标签"></a>HTML 标签</h4><p>Typora 支持许多常用的 HTML 标签，如果你了解 HTML 语法的话，你可以写出十分美观丰富的文档页面。</p><p>比如每张图片下的图片说明，就是HTML风格的文本：</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20210819202813266.png" alt="image-20210819202813266"></p><center style="color:#C0C0C0">HTML</center><p>事实上你可以在 Typora 中完成许多基本的 HTML 风格的文本输入，例如 HTML 字符、HTML 块、HTML 风格的注释，甚至是视频和音频。具体支持的功能和限制请在 <a href="http://support.typora.io/HTML/">官方文档</a> 中查阅。</p><p>有了这一功能，我们就可以在 Typora 中创造出远超普通 Markdown 文档的页面效果。</p><h4 id="导出为-HTML"><a href="#导出为-HTML" class="headerlink" title="导出为 HTML"></a>导出为 HTML</h4><p>Typora 原生支持将文档导出为 HTML 格式的文件，并选择是否要嵌入 style（也就是后文我将提到的 CSS 的部分）。</p><p>除此之外，由于其本身「浏览器」的属性，你可以直接在实时预览界面用 <code>Ctrl +C</code> 复制到 HTML 代码。一个实用的用处是将这些 HTML 代码直接 <code>Ctrl + V</code> 黏贴到微信公众号后台，基本可以保证两边显示效果相同。这一点不仅使公众号推送可以有更自由、美观的样式，也让编辑、排版更轻松了。（由于微信自带浏览器的一些特性，可能有少部分 CSS style 不能生效，建议多多校对。）</p><p>具体如何用 Typora 完成公众号写作，你可以在 <a href="https://sspai.com/post/40524">这篇文章</a> 中进一步了解。</p><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p>为了让文档更美观，我们可以为其加上 CSS style。我认为 Typora 对 CSS 的支持让它成为一众桌面笔记应用中最与众不同的一个。在 Typora 中 CSS 被称为「主题」，但其本质仍是 CSS 文件。你可以在 <code>文件 - 偏好设置 - 主题 - 打开主题文件夹</code> 看到这些 CSS 文件。</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20210819202407420.png" alt="image-20210819202407420"></p><center style="color:#C0C0C0">主题选择</center><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20210819202501265.png" alt="image-20210819202501265"></p><center style="color:#C0C0C0">主题文件夹</center><p>选择不同的主题可以使文档拥有不同的外观，但不会影响内容。Typora 自带了若干主题，你也可以在 <a href="http://theme.typora.io/">官网</a> 下载更多的主题。我选择的是Minit主题。</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20210819202121085.png" alt="image-20210819202121085"></p><center style="color:#C0C0C0">主题商店</center><p>除此以外，如果你有一定的 Web 编程基础，你当然也可以自己修改、新建适合你使用需求的 CSS 文件。使用 Typora 的「主题」功能写公众号的一个好处是，只需要每次都套用同样的主题，我们就可以在保证每次排版规范都相同的同时，节省许多重复的工作。</p><p>参考链接1：[Typora入门](<a href="https://www.cnblogs.com/hider/p/11614688.html#%E5%9B%BE%E7%89%87">Typora入门：全网最全教程 - Hider1214 - 博客园 (cnblogs.com)</a>)</p><p>参考链接2：[Typora 完全使用详解](<a href="https://sspai.com/post/54912">Typora 完全使用详解 - 少数派 (sspai.com)</a>)</p><p>参考链接3：<a href="https://www.simon96.online/2018/10/18/Typora%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%AD%E6%96%87%E7%89%88%EF%BC%89/">Typora入门（中文版）</a></p><p>参考链接4：<a href="https://www.jianshu.com/p/b7fd16a44508">Typora</a></p>]]></content>
      
      
      <categories>
          
          <category> Typora </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Github pages搭建Hexo网站</title>
      <link href="/%E6%90%AD%E5%BB%BAHexo%E7%BD%91%E7%AB%99/"/>
      <url>/%E6%90%AD%E5%BB%BAHexo%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h1 id="本地安装Hexo"><a href="#本地安装Hexo" class="headerlink" title="本地安装Hexo"></a>本地安装Hexo</h1><h2 id="Hexo-框架简介"><a href="#Hexo-框架简介" class="headerlink" title="Hexo 框架简介"></a>Hexo 框架简介</h2><p>Hexo 是一个基于Node.js的快速、简洁且高效的静态博客框架。Hexo 支持Markdown解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><p>优点：</p><ul><li><p>纯静态博客，部署简单、成本低廉、运行优化非常高效。</p></li><li><p>Hexo 静态博客框架可以在云端，也可以在本地电脑上甚至手机上。</p></li><li><p>Hexo 框架的博客网站没有网站后台，不存在后台安全漏洞的问题。</p></li><li><p>因为是纯静态的，几乎所有的 CDN 服务都可以完美的加速提升浏览速度。</p></li><li><p>搜索引擎对纯静态网站有天然的青睐度，收录、权重优先权明显。</p></li><li><p>纯静态网站会让网络攻击成本大大的增加也就是说纯静态网站被攻击的可能性更低了。</p><p>Hexo 中文官网：<a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></p></li></ul><h2 id="下载Hexo-依赖环境"><a href="#下载Hexo-依赖环境" class="headerlink" title="下载Hexo 依赖环境"></a>下载Hexo 依赖环境</h2><h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><p>下载地址：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a></p><p>具体配置方法可参考网上配置教程</p><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p>下载地址：<a href="https://git-scm.com/">https://git-scm.com/</a></p><p>具体配置方法可参考网上配置教程</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>鼠标右键出现Git Bash Here</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20210820143717076.png"></p><p>点击会出来一个基于当前路径的终端</p><h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><p>本地新建一个空文件夹，用来存放 Hexo 的文件和以后要写的博客文件，注意不要有中文路径，避免可能出现的问题。我这里建立在桌面，取名 MyBlog。</p><p>进入新建的文件夹，右键，选择<code>Git Bash Here</code>，依次输入下面的命令。</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装 hexo 框架</span></span><br><span class="line">npm install <span class="literal">-g</span> hexo<span class="literal">-cli</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化文件夹</span></span><br><span class="line">hexo init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 hexo 依赖包</span></span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>第一行安装 hexo 模块，-g表示安装全局模块；第二行是 hexo 初始化，会用 git clone命令去 GitHub 下载一个 hexo 默认模板代码库；第三行是安装依赖包，类似安装 pip 的 requirement 文件，会根据刚下载的代码库中的配置文件，下载并安装所需依赖包。安装成功结果，如下图。</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20210820144746249.png"></p><p>可能出现的问题：</p><p><strong><code>npm install -g hexo-cli</code>命令执行卡住，或者报错连接不上</strong></p><p>可能是 npm 源速度太慢，可以尝试修改淘宝源解决。</p><p>前面三条命令执行成功，Hexo 框架在本地就已经搭建好了，接下来启动hexo服务。</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成静态网站</span></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动服务器</span></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>启动成功如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20210820145255034.png"></p><p>此时，打开浏览器，输入网址<code>http://localhost:4000/</code>，就可以看到我们 Hexo 搭建的博客示例了。此时是默认主题，比较简洁，下一步我们换一个更精美的主题。</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20210820145426644.png"></p><p>可能出现的问题：</p><p>搭建hexo博客时，到了最后一步，<code>hexo s</code>后只出现代码，而不是首页。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%- partial(&#x27;_partial/head&#x27;) %&gt;</span><br><span class="line">&lt;%- partial(&#x27;_partial/header&#x27;, null, &#123;cache: !config.relative_link&#125;) %&gt;</span><br><span class="line">&lt;%- body %&gt;</span><br><span class="line">&lt;% if (theme.sidebar &amp;&amp; theme.sidebar !== &#x27;bottom&#x27;)&#123; %&gt; &lt;%- partial(&#x27;_partial/sidebar&#x27;, null, &#123;cache: !config.relative_link&#125;) %&gt; &lt;% &#125; %&gt;</span><br><span class="line">&lt;%- partial(&#x27;_partial/footer&#x27;, null, &#123;cache: !config.relative_link&#125;) %&gt;</span><br><span class="line">&lt;%- partial(&#x27;_partial/mobile-nav&#x27;, null, &#123;cache: !config.relative_link&#125;) %&gt; &lt;%- partial(&#x27;_partial/after-footer&#x27;) %&gt; </span><br></pre></td></tr></table></figure><p>原因：在<code>npm install</code>安装依赖时出现了错误。</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20210820144908361.png"></p><p>不难发现是<strong>ejs</strong>出现了问题。我们可以先执行<code>npm install ejs@2.7.4 --ignore-scripts</code>后再继续后续操作。</p><h2 id="更换-Hexo-博客主题"><a href="#更换-Hexo-博客主题" class="headerlink" title="更换 Hexo 博客主题"></a>更换 Hexo 博客主题</h2><h3 id="如何找主题"><a href="#如何找主题" class="headerlink" title="如何找主题"></a>如何找主题</h3><p>下面是我寻找主题的两种方法。</p><ul><li>官方网站</li></ul><p>Hexo 官网收录了几百个第三方主题，其中有许多中文开发者开发的主题。</p><p>在 Hexo 官网点击 themes，进入主题页，通过上方的搜索框可以根据标签搜索。</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20210820150632776.png"></p><ul><li>Github 搜索</li></ul><p>在 Github 官网搜索hexo-theme，选择All GitHub，</p><p>点击右上角Sort可以选择按Most stars数量排序，根据流行程度找到心仪的主题。</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20210821103338493.png"></p><p>我目前使用的主题是<strong>butterfly</strong>，这个主题功能强大、漂亮，且色彩丰富。</p><p>Demo 示例： <a href="https://butterfly.js.org/">Butterfly</a> | <a href="https://jerryc.me/">JerryC</a></p><p>GitHub 主页：<a href="https://github.com/jerryc127/hexo-theme-butterfly">hexo-theme-butterfly</a></p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/1b5abeaa3bf16cba6fdb2d3274ad3d9e.png" alt="image-20201226233544278"></p><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><p>以<strong>butterfly</strong>为例，在 Hexo 博客根目录下，右键，选择<code>Git Bash Here</code>，执行下面命令：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">git clone <span class="literal">-b</span> master https://github.com/jerryc127/hexo<span class="literal">-theme</span><span class="literal">-butterfly</span>.git themes/butterfly</span><br></pre></td></tr></table></figure><p>修改 Hexo 根目录下的 <strong>_config.yml</strong>，把主题改为butterfly</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br></pre></td></tr></table></figure><p>如果你没有 pug 以及 stylus 的渲染器，请下载安装：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install hexo<span class="literal">-renderer</span><span class="literal">-pug</span> hexo<span class="literal">-renderer</span><span class="literal">-stylus</span> -<span class="literal">-save</span></span><br></pre></td></tr></table></figure><p>最后在根目录下输入：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 清理 &amp;&amp; 生成 &amp;&amp; 启动</span></span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20210822102237177.png" alt="image-20210822102237177"></p><p>此时再到浏览器打开网址<code>http://localhost:4000</code>，可以看到我们的博客已经换上主题。</p><h1 id="基于-Github-pages-建站"><a href="#基于-Github-pages-建站" class="headerlink" title="基于 Github pages 建站"></a>基于 <strong>Github pages</strong> 建站</h1><p>现在这个网页只能本地访问，要想发布到互联网上，还需要将它部署在网站上。</p><p>博客的功能只要能阅读文章就够了，因此可以考虑将其部署在提供静态网页托管服务的网站上，这样就省去了购买服务器(ECS)，购买域名这些步骤，不仅省钱，更重要的是省事儿。</p><p>许多平台都提供了静态网页托管服务，其中最方便的当然是 GitHub Pages，只需要注册一个账号就可以使用。GitHub Pages的服务器毕竟在国外，如果觉得访问太慢，也可以选择国内功能相似的 Gitee Pages。不过目前使用Gitee Pages还需手持身份证的照片进行实名认证，较为麻烦，因此博主使用GitHub。</p><h2 id="GitHub-Pages-简介"><a href="#GitHub-Pages-简介" class="headerlink" title="GitHub Pages 简介"></a>GitHub Pages 简介</h2><p>GitHub 是世界上最流行的软件源代码托管服务平台，为什么要提供网页托管服务呢？</p><p>这是因为一个项目的主页如果只有源码，对新接触的人很不友好，不知从何处下手。虽然已经有了 readme.md 文件，但毕竟不如一个直观的网页来的直接。于是 GitHub 就设计了 Pages 功能，允许用户设计一个图文并茂的网页作为项目首页。</p><p>虽然 GitHub Pages 的初衷是提供自定义的项目首页，但是它的玩法不止这一个。因此许多博主都用这个功能来搭建自己的博客，因为它实在是太太方便了。</p><p>去GitHub Pages 官网 pages.github ，拉到最后，可以看到官方也推荐使用 GitHub Pages 搭建博客，并且提供了示例教程。</p><h2 id="GitHub-Pages-准备"><a href="#GitHub-Pages-准备" class="headerlink" title="GitHub Pages 准备"></a>GitHub Pages 准备</h2><h3 id="创建-GitHub-Pages-仓库"><a href="#创建-GitHub-Pages-仓库" class="headerlink" title="创建 GitHub Pages 仓库"></a>创建 GitHub Pages 仓库</h3><p>由于每个 GitHub 账户只能建立一个 GitHub Pages 页面，所以 <code>Repository name</code> 必须填<code>&lt;你的用户名&gt;.github.io</code>，如<code>xxxx.github.io</code>否则就会建立一个普通仓库，GitHub Pages 功能不会生效。</p><p>Description 填写仓库描述，比如xxxx’  blog等，可不填。</p><p>注意勾选 Public ，否则 GitHub Pages 功能不会生效。建议勾选 Add a README file，会自动生成一个 readme.md文件。</p><p>最后点击<code>Create repository</code>创建仓库。</p><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20210822104623122.png" alt="image-20210822104623122"></p><h2 id="GitHub-Pages-发布"><a href="#GitHub-Pages-发布" class="headerlink" title="GitHub Pages 发布"></a>GitHub Pages 发布</h2><p>我们把自己的博客生成静态 html 网页，提交到这个仓库目录下，就可以在我们的网址看到博客页面了，这就是 Hexo 框架部署博客的原理。</p><h3 id="安装-Hexo-发布插件"><a href="#安装-Hexo-发布插件" class="headerlink" title="安装 Hexo 发布插件"></a>安装 Hexo 发布插件</h3><p>在博客根目录下，右键，打开<code>Git Bash Here</code>。</p><p>输入下面的命令，安装<code>hexo-deployer-git</code>。</p><p>这个插件用于把生成好的静态页面上传到 GitHub Pages 仓库。</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install hexo<span class="literal">-deployer</span><span class="literal">-git</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chenduowen233/Myblog@main/img/image-20210822105228573.png" alt="image-20210822105228573"></p><h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>打开博客<code>根目录配置文件</code>(<code>…\MyBlog\_config.yaml</code>)或(<code>…\MyBlog\_config.yml</code>)，拉到文件最后一行，修改为下面的配置（没有的配置项自行添加），保存。</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 其中 xxxxxx 是前面多次用到的你的GitHub用户名</span></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: git@github.com:xxxxxx/xxxxxx.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure><p>最后执行下面命令：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><p>待命令执行完毕，打开浏览器，输入网址<code>https://你的用户名.github.io</code>，可以看到一个和第之前本地部署的一模一样的博客出现了。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 教程 </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/hello-world/"/>
      <url>/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
